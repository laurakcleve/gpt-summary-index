Hello and welcome to Swashbuckling with Code, I'm Jimmy Cleveland, and this video is all about Parcel, which is a popular JavaScript bundling tool. Now before I get into a brief description of what Parcel is and what it can do for you, I want to acknowledge that this is a pretty lengthy video, as you've probably seen, and that might be daunting to some people, or you may just be wondering, you know, why should you spend your time on it. So I do want to start out by pointing out that I do have timestamps for this video, and they're going to be covering each of the steps of the build that I'm putting together. And the nature of the video is that I'm going to start from kind of a bare-bones approach, I'm going to put each piece of Parcel together with some really common setups, which I'll cover in just a moment of all the different things that we're going to go over. But at each of those phases, I'm going to show kind of what Parcel's doing for you, what magic it's doing under the hood, kind of comparing and contrasting that to other bundlers such as Webpack, which I've covered previously in a few videos. I also make commits throughout the video, and the final repository will be uploaded, and it'll be in the description, in case, you know, you are jumping around to any different timestamps, kind of choosing your own adventure, and you want to reference the code at that point. The end state of the repo will be at the very end of the video. So you might have heard of Parcel, and you might be wondering what it is. So I'll give a brief description here. It's a JavaScript bundling tool, which is very similar to something like Rollup or Webpack, you might consider it a competitor to those. And the thing that it does that stands out is its innovations in sort of magically doing things for you. They commonly call it a zero configuration bundler, which has some debate on whether it's actually a zero config or not. But for most people's setups, the Parcel team claims that there's no configuration required, which is pretty appealing when you're contrasting that to something like Webpack, which obviously requires a kind of legendary amount of configuration that's very daunting for people. Now, if you're not really familiar with any of those, I'll just say that it's a way to use sort of modern JavaScript and have transpiling benefits so that you can get kind of cross browser support. It's a way to do work with frameworks like Viewer, React, or Svelte, or any of those, as well as even supporting TypeScript. I think Parcel is a great fit for newer JavaScript developers in particular, new developers in general, because contrasting that to Webpack, I don't think they should spend a lot of time learning how to configure everything and get wild with all this configuration before they just focus on making things and getting things done and learning how to actually build things. Webpack to me is something that you kind of graduate to when you need more customization and more fine-grained control. That's just personally my experience with it. Parcel is also great for experienced developers. I like it a lot as a sort of prototyping tool. When an idea hasn't really proven itself to be worthy of working on for a long time, it's just so fast to set up and have a lot of conveniences and you can kind of just get going and start working, getting things done. But there are also teams that use it for enterprise-level apps, so I just want to throw that out there as well. So let me briefly just kind of go over the list of what we're going to cover in this. A lot of those will be broken up into the timestamps that I mentioned previously, and then we'll jump into the video. So as I said before, we're going to be setting up a minimal project from scratch with Parcel, so that's where we'll start, kind of what entry points you need, what are the minimum files you need to just kind of get going, and what that output looks like right away. Along the way, I'm going to be showing when Parcel can sort of magically find dependencies for us and add them to our Node modules and to our package JSON without any configuration or manual package installs, which is really awesome. And we'll be covering Vue, React, Svelte, TypeScript, modern JS features like conditional chaining and fallbacks for those, also using a browsers list to customize those fallbacks for cross-browser support, importing images in JavaScript, which is a lot of times something you have to set up, SAS, stylus, styled components, pug, and multiple entry points as well. And a final note is that this entire project is showing many different ways that you can set up Parcel. It's not necessarily meant to be a realistic app, but it is demoing it from the perspective of creating a web app, like a single page app or a multiple entry point app. So now that you're equipped with an overview of what the entire video is going to be covering, let's start coding. All right, let's kick this off by creating our directory for this new project. I'm just going to call it Parcel. We're going to cd into that directory and then I'm just going to open it in code, my editor of choice. Let me bring that down here. Okay, close that. And we have this empty project. So what I'm going to do first is I'm going to create a source directory and I'm going to create an index.html in there. And then while I'm at it, I'm also going to create an index.js file. Okay, you don't have to put this in source, it's just what I'm going to do to save myself some time down the road. In our JS file, we're going to do something really simple. We're just going to console.log and I'll just say is work and I'll save that. And then I'm going to go over here to HTML and I'll just use the bang.mp shortcut and come down here and we'll say parcel example is the title. And then in this content I'll just put h1 parcel example just so we can see that. And then I'm also going to point to that script. So this is the minimum necessary for parcel to run. You need an entry point, which is an HTML entry point that you're going to point it at, and then it also needs to, you know, load in a script of course. So from there we'll just say dot slash index.js since it's in the same directory there. And that'll be it. So the next thing I'm going to do is I'm going to jump back over to the terminal. And rather than installing this locally, what I'm going to do is I'm going to say npx and we can just do parcel bundler and then we'll point it at our index.html. So if you're not familiar, npx is a way to kind of download a single time this npm package and run it. So at this point it says, oh you know what that needs to be source index.html you silly goose. So that's good to know that that tells you that no entries were found. We'll run that and you can see that it has built and is already serving us this server, which is really nice. So I'll click that and go to it and there we go. I'm going to inspect this and you can see my console log is working. So pretty simple, but just to show that's how easy it is to set up, you know, very very minimal config. Now this is a server with hmr which is hot module replacement, but we do have to enable that, which we'll do in just a moment. For now I want to show you, if we come over here into our directory, you'll see that we have this dist folder and this cache folder now. Interesting, huh? So the dist is just the output as you would imagine, but one thing that you want to pay attention to, while this is the same index.html file for the most part, you can see that this script has automatically pointed it to the built version of our javascript, which is going to be right here. And this javascript file, this is our bundle, is actually has a ton of stuff in it now. If we were to search really quickly for console.log is work, you can see that's there, that's the only code that we have. And obviously this is a bit of scaffolding for, you know, the future and all the other things that it's going to do, so it's a lot bigger than just our minimal one. But that's the gist of it. So that's really cool that, you know, right off the bat this index.html thing just takes care of that for us. We don't need any sort of plugins or anything like that. It'll just output it and point it to all the right files that it has for its entry point. Oh, I also should point out that you get source maps right out of the bat, which we'll see like a little more featureful in a moment, but just check this out when you look at this console.log in our browser. We'll bump that up a tiny bit more, I'm sure that's fine for now, but we'll probably want that in the future. This has this, where is it telling us? Oh, well, it's source index.js. Even though that's not the script that our server's, you know, loading, it's the source map telling us that. This is the actual full one. So that's pretty cool. So next we're going to enable HMR just to show that real quick. And I'll briefly talk about that. So this is our actual original index file, and just minus that for a moment. So here, in order to showcase that, what I'm going to do is I'm going to just add a simple little input field here, you know, type equals text or whatever doesn't matter, and just to kind of showcase the difference between hot module replacement and not. So HMR is sort of like live reloading, if you're familiar with that, where every time you save your document, you're going to, so it's commonly called hot reloading as well, by the way, HMR, but you know, with live reloading, every time you save the document is refreshed. And so the, that's great, but the problem with that compared to hot reloading is that you lose all of your kind of local app state or your app state in general. So where that's really useful is like, let's say you're kind of designing this component, and you're fiddling around with like some state that it takes a user a few clicks, or you're filling out a form or something like that. Every time you save, it's going to refresh that state. So I'm going to show that real quick. So we can show the comparison here. So right now, if I were to type, you know, whatever here in this silly, small little input, it's kind of small for you, but bear with me for a second, it's going to go away. What if I were to go and change my JavaScript in any way? So let's go, it's going to be hard to alt tab here, but let's go back to this index.js here. And then we'll just say, we'll change this to, it does indeed work. Now what's going to happen when I save this is that page is going to be reloaded really fast. Unfortunately, I can't tab to it fast enough to show you, I guess I could split it, but this, this little spinner will turn to an X just really briefly, but notice that our text is gone here. So just taking that away. So let's kind of show a contrast to that real quick. You know, it's probably worth showing, honestly. This should be good enough, even though it'll be hard to read here. So if I do this, and then I'm going to change this to whatever as well, as soon as I save that, see that blinks and then it goes away. So what we can do now, we're losing real estate here, is we can simply just in this script, in this entry point, we can say if module.hot, so it'll check for that, and then it'll say module.hot.except, there you go. And then when we save that, that's going to give us hot reloading. And so now, I don't believe we have to restart the server, but change things. We save, you'll see that this console was cleared. That's an HMR runtime, so that's a good indicator that it's working correctly. So now, if I type whatever in here, and then I also, you know, do some nonsense here, and I save, you'll see that my new log is there, but I didn't lose this state. And that's going to be true for like everything. What's really cool is like CSS will kind of be able to be injected. It uses like web sockets under the hood, but I'm not very knowledgeable about that, so I don't really want to speak to that. But yeah, you can think of it that way, that that's kind of like when you change your CSS and your dev tools, how the browser doesn't need to reload. Well, it's the same thing going to be with JavaScript and CSS now. The browser doesn't need to reload every time you're changing that, which is really neat. Now, let's actually install Parcel and run our scripts locally from some package.json stuff. So we're going to do, I guess we'll probably need an init, won't we? Did we already make a package? Nope, we didn't. So we'll do npm init dash y, just to skip all the questions, that's dash yes. And now I'm going to do npm i dash d, and we'll do the same thing, parcel bundler. So now we're just installing it locally, which is kind of the recommended way, you know, rather than relying on a global one. If you want to use the global one, that's fine, but typically you install it locally in your project so you can run all the commands. So now we'll pop back over to here, and we'll open our package.json right here. And in our package.json, we're not going to be doing any testing here, so I'm just going to make a script, and I'll make a dev script because that's what they do in the docs. Actually, you know what, that's going to bug me, so I'm going to make it start because it's just easier to type. Maybe I'll make both. And this one, all I have to do is run that same command that I ran at the beginning, just parcel and then point it at your entry point. Really simple and straightforward. Now we're going to run a build script as well at some point, and this parcel build index.html, that's all you do. So you're just going to tack on build onto the command, and that's going to build you a production version of your site, which is really sweet. And a quick note, you know, keep an eye on this parcel version that I'm using, because, you know, if you're watching this video in the future and it bumps and you have any sort of issues, typically that's the first place you want to look is make sure the versions are all the same. And I'll have a repo with this code up in the description of this video for those that, you know, want to reference it while following along, or it'll be the end state of the video basically. So if you just want to look at any of the code and see if you missed up any syntax or just want to reference it, it'll be there. Okay, so let's make sure our scripts run, right? Come back over to here, and the first thing I'm going to do is I'm going to do npm run build, and we can see we had no, you know, I did the same thing again. I don't know why I did that. Source. Source. The original docs have it in the root, and that was what was in my brain. Sorry. So npm run build, and voila! And it's pretty cool. It tells you how long it took to build, and the size of them right here. You'll notice that our bundle size is already 1.17 kb, which is actually probably a little bit bigger than webpack would be at this size, but I don't really think that has, you know, scalability problems to any extent. You know, I would keep an eye on that, but it's going to be, you know, as the app grows, it's going to need a lot of that code anyways. And then I'll do npm start. Start my server up, and there you go. We're back and running again. We can reload, and we can see everything is nice. Now something I want to show from that real briefly is if you go to our dist folder now, make this a little bit bigger, you'll see that here we have multiple files here. The same thing. If we go to index.html, it's only importing this one, but you'll see that there's this file, which looks a little bit different than before, right? And then there's this file, and each of them have their own map, and this is the one that we saw before. Well, that's because Parcel does not clean right out of the bat. It doesn't delete the dist folder every time you run, and it doesn't seem to have a command to do that from what I've seen. So, you know, you might want to add to your package.json, you know, whatever your operating system command for, like, let's say building or something you could do. You could do it on both, you know, rmrf dist or something like that. But the thing about that is, typically, it's not really that much of a problem because the server is only going to be running at one time. It's going to be running this one command, so there's not going to be that issue when you're actually deploying it. And if you're running it locally, you know, you can either delete it manually or you can put your own command for that. So I'm not going to do that. I just wanted to let you know about that. So for now, I'm just going to, you know, get rid of that. And I'm actually curious. I have the server running, so I wonder if I, like, save or something that's going to rebuild. It doesn't seem like it. I go to the index.html, save. Ah. Worth a try, worth a try, right? So let's restart that again. Built the bundle, reload the page, everything's working, and our dist is back to just having that single file, that single JavaScript file. So I think this is a pretty good time to set up a git repo and commit our changes real quick before we start doing some bundle stuff. And that'll actually help us track what parcel is changing in the package.json for us because it does that, and it's actually pretty neat, but, you know, a little magical. So we're going to do a.git ignore really simply, and we'll say node modules, of course, and we're actually going to ignore dist as well as.cache. Now, this.cache directory, I don't really know a ton about that other than it's what Parcel uses to keep the builds quick. So, you know, standard caching type stuff. I'm sure it's not standard. I'm sure it's very fancy, but you get the point. So then we'll go back over to the terminal here and git init, git add dash a, and git commit dash m, and we'll just make this, you know, initial, partial, parcel setup. I want to say parcel there so bad. So, you know, if you're using the the repo from the description, then you can go to look at any of the commits if you want to see that timestamp, but there's the name. So now that we have, you know, our git setup, so we have a fallback, a commit to fallback to, what I'm going to do is I'm actually going to do npm run build one more time just so that you have the data right in front of you. And just remember that this is this size. We'll come right back and look at it. 1.17 kb for our bundle. And let's compare this to webpack just to see. So we can actually just really quickly do webpack cli, and then we just say, okay, well, the mode is equal to production just to get that, you know, bundling normally. It does that by default, but it yells at you. So I'm going to add the flag. And here you can see this main.js is the bundle, and it says it's only 36 bytes. And let's actually look at the code just to see, you know, what it output here. Go to main.js. This is from webpack. Look how lean that is. It really just found, you know, that that was just a console log and nothing extra. So, you know, this isn't to hate on parcel or anything like that. Like, you know, you know, parcel 2 is coming out and has a bunch of advancements. This is webpack 5, so it's kind of the latest and greatest here. But as of right now, webpack is actually building a much leaner bundle just from this minimal example, which is interesting because a lot of people that do bundle comparisons, typically they're doing webpack 4 and parcel, but they show that parcels bundles are actually smaller and faster. So who knows? Everything changes at scale. I'm not trying to start a war between them or anything like that. I'm really just trying to, you know, give you the tools to show, okay, like, this is kind of how we can, you know, make sure to keep an eye on these things as we're progressing forward in the project and keep an eye on our bundle size. Okay, so I am going to wipe out that disk one more time because I don't care about any of that stuff right now. So some common confusion that comes up is that with, we are obviously building an app, you know, we're not building libraries right now, and a really common pattern for webpack and parcel is to build a single page app where you have the single entry point and then all of your routing is going to be done through JavaScript, whether that's React Router if you're using Router or any of the other frameworks ways of routing. A question that comes up a lot when I was doing webpack videos is, you know, how do you do multiple pages? Well, typically in a single page app that's going to be handled all through, you know, your JavaScript, but if you do want to do multiple entry points, you totally can. So I want to show that right off the bat. So in source, I'm going to make this folder now, a new folder here, and I'm going to name it just pages, and I'm going to move this index.html into that folder there, and I'm going to copy it. I think that'll maybe be slightly faster, and I'm going to rename this to about.html. And so in this about.html, well actually let's make a link to that just so we can go there really easily. So we'll do an a tag and then we'll just say slash about.html. Now this is an important thing. About us, or you know, whatever. I don't know why I picked that name. This is a very important thing. The dot html is required here. You're not going to get the pretty URLs from this, and I actually haven't figured out an easy way to do that with Parcel. There is a plugin that someone's made, but it didn't really have that many downloads, so I decided not to include it in the video. So if anyone knows how to handle this, I'm not really sure outside of, you know, on your server kind of hard setting that, but you know, obviously when you're running your dev server, you still have to have this. So it's kind of weird. If you don't know what I mean, I just mean that you can't type like this, which is commonly called a pretty URL. So we have to include the dot html. That's the point. And if we go over to our about html, let's just change this to the h1 to be, you know, about us, and you know, it'll have an a tag that goes back to slash index dot html, and then that will just say home. They're both going to import the same script for right now, just to get it running. And I'll get rid of that input, because we don't really need that input anymore, do we? Oh, and I almost forgot, we will need to actually move the directory up one, because our index.js, we put this in the pages folder, and we need to go up one. Very easy to forget that. I think that should be good. So let's npm start, start the server up. Let's see. Oh, you know what, we need to change our script. Haha, it's not good. So when we come into package.json, you know, we told it it's in source index html as the entry point. We want multiple entry points now, right? So we need to say source pages slash star. So we can use this pattern to say anything, start on html. We can say anything here that says source pages start on html, any of the html files and pages. Pages do the same thing, star dot html. Let's try that again. And that's how I built. So we'll come over here, we'll reload the page. You can see our console log still reporting. And now we have this about us page, which is kind of weird, because we went to the root. I've had this a couple of times, and it's pretty strange. Now we're at index html, it's like if you go to the root, it just like finds the first page in there, I guess. But now we're going between index html and about us. Let me see if we go to the root again, what it does. Yeah, I guess it just finds the first page. That's interesting. So I'm not going to get into fixing that on the server. I just want to show, you know, multiple entry points pretty easily. And the thing that you'll want to see right here is when we go to the about us page, it has the exact same JavaScript, right? And most of the time when you're doing multiple entry points, that's not what you want. So we'll just really briefly, you know, make another file here and source new file and do about.js console.log. The about page. Okay, go back over here. And that should have already reloaded for us. Oh, it didn't. Oh, we need to change our entry. I'm making all sorts of mistakes today. Go to about html. And then here we want to change our index to be about.js. Come back over here and it is already live reloaded for us. In this case, it's not hot reloading because I didn't put that hot tag. Keep that in mind. So that's really easy, right? Multiple entry points that are using their own JavaScript files. You'll see some crazy stuff that we can do with that in just a bit. Let's make another commit super fast. I'm just going to add all this stuff and then we'll say add multiple entry points. That's where we're at. The next thing I want to show is really cool. It is that you can have modern JavaScript features without any configuration as well. So let's do this. We're going to make an object here. Then in that object, I'm just going to make up some properties. I'll say A is for Apple Crisp, the light, and then B is going to be butter cream, and C is actually going to be a nested object for my purposes. So then we'll just chain it on. Cheese Danish. Beautiful. Then we're going to console log that. So first, we'll just log the normal, .c,.cd. So we're doing a regular chain. These are properties that all exist. I'm not to the super features yet. If we go back to home, you'll see, I'm just going to get rid of this log because it's silly, but you can see we're logging out. Cheese Danish. Not surprising. But if you go into dist and we're going to look at the source file here, and let's take a look at our console.logs. Can't type. You'll see that the code is very normal. Keep an eye on this. This console log right here, object C.cd, nothing fancy, no fancy transpiling or anything. Now, if we go back to, and I'm going to get rid of this one just to keep it clear. If we go back here and let's say we want to log that out, but we also wanted to log out something that did not exist. Let's say object.f.fa or something. I don't know why the letters I chose are what they are, but they are what they are. Now, I'm going to do this cool thing called conditional chaining of this question mark. I'll explain this in just a moment if you haven't seen this before. So what this is going to do is normally when we, I guess I should have showed that first. Normally, when we try to access this, we're going to get an error. I will show it first, why not? Because this property doesn't exist and we're trying to access something on undefined, which is obviously a big JavaScript no-no. But what this conditional operator here does is it falls back safely, and it says, does this exist? Okay, then does this exist? If anything in that chain doesn't, then it will just come back as undefined. So first, let's show the error. Uncaught type error cannot read property fa of undefined. Then I'm going to go back to having conditional there, and look at that. We got a safe fallback, undefined. Now, let me show you why I was having you glimpse that before in here. Notice that now, we're in our bundle, and this console log is pretty crazy. So this is transpiling an action. It's taking modern JavaScript features and using Babel, and making some cross-browser safe, browsers that don't have this feature yet, just without any configuration at all. That's really nice. I got to hand it to them for that one. That's really cool. Just because I am a sucker for being thorough, what I'm going to do is I'm going to copy-paste this, because you might not know that this works just fine in Chrome. Just paste that in and run the code. It works fine, right? What it's doing this for is something like IE, which dreadfully open. Gosh, every single time. Go away, so bad. I'm going to go to about blank, so I don't have to look at that. Okay, then how do I do this again? It's been so long. F12, developer tools. If you have to deal with this every day, I'm very sorry. I can paste this code in here, run it, and you can see that we get this syntax error when we try to paste that code, right? Now, if we go back to... I know I say it right, like you can answer me. We go back to this, and we... Oh, no. There we go again. So much pain. Okay, there we go. So we're running our server, which is running our transpiled code, and that was the point I was trying to show, is that this code runs correctly in IE11. So like I said, no configuration, and you've got some awesome cross-browser support. Now I'll purge that from my memory. So because I'm going to make some changes right here, I'm going to do one more commit, because I want you to see the diff here. So I'm just going to say show modern JS transpiling for that checkpoint. Okay, so for a quick reference, our package JSON here just has this one dev dependency that we've manually installed, the parcel bundler, okay? Now what we're going to do is we're going to add some SAS just to get straight to it. So in my source, I'm going to add a new folder. I'm going to say that this is a styles folder, why not? And I'm going to add a new file, and then I'm going to call this index.scss. And to save you some time, I will paste this in. So what we have in here is we're just using this main BG here with bisque is the color, lovely color, and then we're going to combine that with chocolate for a delicacy to remember. Now this chocolate is using a SAS variable just to show that we can. I just want to point out that you probably wouldn't have a lot of value from SAS variables when you have CSS variables, but you might still like them. So, you know, you do you. And then we also have some nesting here that's going on. Just, you know, the usual SAS stuff that you'd like. Now what I want to show with this is that I'm going to save this file, but it hasn't been imported yet at all, okay? So the only file change we have is this. But what I will do is I will go into, go away, I'll go into my index.js file, and we're going to import that in JavaScript. So we're just going to import, and then this is typically how you do it. You're going to go to styles and then index, oops, index.scss. I don't know why VS Code could never autocomplete CSS for me. I'm going to save that. And you saw on the left here, maybe, that something changed, right? And if we go over to this, a few things have actually changed. And I wish I could have Alt-Tabbed to show you fast enough, but behind the scenes, the server here, went and ran some stuff real quick, and actually went and downloaded SAS for us, added it to our package.json. Isn't that wild? So let's see if that did anything. Whoa, right? Pretty cool. So this is our page as before, and it's got all these styles already there. If we inspect this, we can see, this might be a little big for me, but for your sake, I'll bear with it. But the body, and this Chrome does this cool thing now where it like shows us flex box. It's kind of hard to see that you're hovering over it. So I've added flex for demonstration purposes to this. And you can see here that the background has been set there, and it's already like, you know, turned that SCSS into CSS. And that's why we just have this color chocolate here. We're using a CSS variable, but this was a SAS variable and it's been converted. Even though we're looking at the CSS, notice that it says index SCSS. And that's what I was pointing out before is, it has source maps built in without any special config property, which isn't that hard to set up in Webpack or anything like that, but it's kind of cool that it just comes right out the bat, right out the box. I mean, so here we can see the original color was set to this text color and all that good stuff. Not gonna go over source maps too much here. You know, it's just a way to see the original code if you aren't familiar with that so that we can troubleshoot easily in our own code. So it was that easy. We didn't even have to install SAS. I just made a SAS file and imported it and it worked. I'll also show you really briefly that say, you didn't want to install it or import it in your JavaScript. You can actually do the same thing in your index HTML with a link tag here. So if we did, you know, link CSS, we could then point to a.slash, where are we at? ..slash styles and then index.css. And actually let me comment that out just so you can see there's no styles. Come back here, come back in, and you've got styles again. Pretty cool, right? And I guess I could have just showed you that the link is here, but check this out. See how that name is different? It's doing all of the stuff behind the scenes for us. It's automatically building all those links for us and saying, okay, yeah, you imported this in the HTML file. And I know that when I get output that HTML file, I need to reconnect that up to the bundled version, which is gonna be minified in a production environment. So there's a lot of awesome magic behind the scenes going on that I wanted to point out. So I'm gonna put that back where it was. So I would prefer to do it here, but just know you can do that. Now, while all of those magical things do come with it that we've shown, one thing that it does not start with is browser prefixes. So if you go over to this, I was gonna show Flexbox to show that, but actually now that I think about it, I think that Flexbox might be supported in a wide enough browsers that the default, can I use browser list is going to be a little bit more is going to not auto prefix it. So to make sure, let's use a super modern feature here. So I'm gonna go into my index SAS file and for the H1, I'll add this line, these three lines, I should say, I'll put a break here. So we're gonna do a fun effect here and we're using this background clip, which is very modern. And to show you that actually, we can go to can I use here and there's this background clip text just to show that. And then when you hover over Chrome, you can see, whoops, right here. You can see it is supported, but it's kind of tiny for you, only with the dash webkit prefix. That's perfect, we need a vendor prefix to test that. And you'll see when we come over to our styles here that this doesn't really quite look right, or maybe you like that, but it's not what I'm intending. So let's set up some PostCSS to get that working. So I'll start by creating a new file and say postcss.config.js. This is where you normally dump all of your PostCSS config stuff, of course. And I'm gonna do module.exports equals object and we're gonna put a plugins key here. And this is just a pretty normal thing if you set up PostCSS is one of the main ones that you usually do. And I like to do PostCSS preset-env, which if you're familiar with auto-prefixer, this actually comes with it. It's a bunch of presets that they recommend. Now, when I save that, this is one of those times where nothing magical has really happened here. We still just have parcel, bundler and sass as our changes and nothing new besides that. I guess something that I kind of don't like here is while all this stuff is really magical and cool that it's auto doing all this stuff for us, right now we're trying to require something that the PostCSS preset-env and because we're so used to everything kind of handling it for us, it's kind of weird when we don't really get any sort of feedback here that that thing doesn't exist. It might be a lot to ask for though. So, whatever, you figure it out. So I'm gonna add that real quick. I'll do PostCSS preset-env. Now I'm not gonna actually add PostCSS, which would normally have to combine with it. And before I install that, I'm gonna show you that's because if you go to our node modules here, and I'll actually just do slash PostCSS, you'll see that we actually already have PostCSS. That just comes installed with parcel. And I've tested that out. It comes like with just plain old parcel, not any other additions to it. So they already have a bunch of stuff that they're including to kind of cover this, but they don't happen to have this preset. And I'm assuming that this is because, you know, bundle size, browser prefixes can add the bundle size. So maybe they opted to say that you should have to opt into that. So this is kind of the first sort of config that we're really having to do. And it's worth pointing out because there's a, it's a really hot topic. What is zero configuration in this world? You know, the parcel team has stated that, you know, they see it as, you know, the majority of use cases, not needing any configuration files consists of or accounts for zero config. And some people are absolute in that. And they're saying, no, if you have to do any config, it's not zero config. I don't really think it's that cut and dry. To me, you're setting up, you know, config for your own stuff. You're not having to configure, you know, right now, any of the Babel stuff or any of that stuff in this. I want to opt into kind of customizing that my own way. And I know parcel two is actually setting it up to where they're going to have a config file. So keep an eye out for that. So let's see, now that I've installed post-CSS preset ENV, if I just, oops, I just run start, we'll see if it does anything. Look at that, it just worked. Isn't that beautiful? So now we have this nice gradient behind our text. And if we scroll down here, we will see, oops, I'll be on the H1. You'll see that this linear gradient here, not the linear gradient, what am I thinking? The background clip, background clip added this vendor prefix for us, WebKit background clip. So that wasn't too hard, but let's take it one step further with the fact that on our body, we had this flex right here and it doesn't have a fallback for that. And maybe I want support for that. So what I'm going to do is also add a, let's go down to here. In the root, I'm going to add a.browserslistrc, okay? A dot is important, or you can do config file with JS. And I'm going to do last two versions, pretty standard here. I could do one or whatever, greater than 0.5%. I'm just kind of pulling these common numbers out of my head. And then IE11, that's the important part. So I'm going to save that. And then I'll come back over to here and we'll see if it worked. And you'll notice that that didn't do anything, okay? And so what you could do is you, or you might think is you could just like rerun the server. This is a common thing to see if it added that. And notice that, I just noticed my head might be in the way sometimes. Whoops, sorry. It looks like it's okay. Well, it wasn't in the way of that link, but move this over a bit. So this display flex still doesn't have any new WebKit properties. And I know that it should when it's trying to support IE11. So this brings me to something that's kind of a weird little quirk that I've found. It seems like saving this or saving any of like the entry points doesn't really get it to rebuild, but saving this post CSS config actually got it to rebuild for me. And check that out. I just saved that. I know you couldn't really see it, but I pressed Control S. And now I have all of these vendor prefixes and that'll just be that way from now on. It's like the caching is, might be a little too aggressive. It doesn't really know to check that unless you save post CSS config. So there's a little gotcha for you and a solution for it. So restarting the server isn't enough. You have to actually go and save the post CSS config file, which is weird because I added a browser's list file, you know, whatever. So let's top this section off by adding CSS modules because I had a little bit of a gotcha there too. And, you know, that's a common paradigm that people like to use. So let's show how to do it. Now with post CSS modules, what we're gonna do is I will add an additional H2 here just to get targeted. And then I'll say CSS module example. And then in my index.js, I'm just gonna be really silly and say, let's store the H2 as document.querySelector. We're just gonna grab an H2. And then we will say H2.classList.add. And, you know, normally I could add whatever I want here and show that that class was added just to make sure that, you know, we know it's working. And then what I'll do is I'll make a file that is called CSS modules.js or CSS. Let's call it modules.styles. And I'm just gonna make an H2, actually I'll make a class, I'll make a heading. And then I'll say Z32 and color is rosy brown. That's all I need. And then I will import that, but, you know, we import that as like styles or something that we wanna name it. And we'll go up, it's in this directory, isn't it? Styles slash module styles.css. And then I can just pass that class in here, styles.heading. Okay, now I'll just really briefly go over this if you're not familiar with it, you know, not the purpose of the video to explain every single thing in there, but really briefly, I can spend a moment. It's what you're doing here is you are making a regular CSS file, but with CSS modules, what happens is when you import it, you can actually access all of these different like properties on it. And you normally, you wouldn't do it in this way. This is a very silly way. It's just a quick way to demo it, but you would do it in like, let's say React, you know, you could import it and put it on your JSX, for example. And that will automatically hash the class name. So you don't have any scope conflicts and you can reuse the same class names over and over at like a component level scope. That's as much as I'm gonna go into it. But what I want to show here is that, you know, when I reload this, I just get undefined. It's a class name. So, you know, that's not that surprising. Can't automatically figure out every single thing we want to do. So I will npm i dash d post CSS modules. That's the plugin that you usually have to use for post CSS to use modules. That's a common way to do CSS modules. npm start, server backup. Saw it doing some module style stuff. Let's reload. And notice it didn't do anything. This is where the gotcha is gonna kick in. So the docs tell you that you need to go into post CSS config, and I'll actually show you this in the docs in just a moment, and say modules true. And that's all you need, right? Then when I reload here, it doesn't seem to have done anything. It doesn't update that. And if I restart the server, reload, still not doing anything. Sometimes you have to, like I said, you have to save this post CSS, which should have done it. There you go. One of the saves will trigger it. It's a lot easier to see when you have it in two separate windows, I'm sorry. And you'll see that you get this crazy error, post CSS eight for end users. And post CSS plugin, post CSS modules requires post CSS eight. It's a lot of saying post CSS. And I'll just show that in the docs so you know that I'm not crazy. If we go to CSS, what is it? Modules true. Oh, here it is. I don't know why I didn't find that when I searched it. Oh, because I had quotes around it. Duh. This is JSON. So yeah, modules true right here. Kinda tiny there. That's what they want you to have, but it actually breaks your stuff, unfortunately. And that's because it's not necessarily Parcel's fault here. Go back to that error so you can see while I'm talking about it. So the issue here, I've actually seen this on view forms for view three as well. Post CSS moved to post CSS eight, which was obviously a breaking change to move from seven. And a lot of the plugins that you install, like CSS modules by default are now paired with eight, but Parcel automatically installing post CSS for us installs seven. So I tried to manually install eight, but then it causes more problems with some of its backwards compatibility. It's a real nightmare. So the easiest way to get around this right now for me is to say npm i dash d and post CSS modules. What we got, really quickly, what we got when we installed modules was four. And we want version, you know, any three. So I'll do caret three at caret three. Okay. Now I'll do npm start again, and I've installed that. Let's see if it just works. I might have to save it again. And there you go. Look, I've got my color, my rosy brown. And then here's what you really wanna look at is this hashed class name. So once you know it, it's a really easy fix, but it was very annoying to figure out. Blah. So we've run into one of our first hiccups, obviously with sort of a zero config thing, but I don't really wanna hold that against you for that one, because like I said, Vue 3 has problems with it as well, though they do a bunch of auto-magical config stuff as well. It just seems to kind of be an ecosystem type thing where certain things are moving forward. And it would have been a lot easier, I think if I was, you know, in something where I'm installing every single thing, like I was in a web pack project, because I would actually be choosing to install post CSS and all my other stuff wouldn't rely on that different version, but not that big a deal in the end. So let's commit and move on from this one. We did a bunch of stuff here. We added a browser's list, and then we also did post CSS, and we added our Sass. We did all of that. So let's just say add Sass, post CSS, browser's list, CSS modules is too long of a commit name, but it's fine. There you go. So I think next ought to be TypeScript. I just want to show that my server is still indeed running. There you go. And coming on back to our code, what we're gonna do here is I'm going to change the index HTML to point to index.ts now. I'm gonna have to change... oh no, that one has its own, so I'll just change this one. And when I save that, it's going to get unhappy because that doesn't exist. So let me actually... I'll probably get mad either way, so I'll just save it. I'm gonna rename this to a TS file, and when I go into that TS file, you can see this is just VS Code. If you ever name something.ts, it's gonna automatically start giving you TypeScript hinting. But what we want to see is did it build? So we'll need to restart that because we changed some paths that didn't exist. That's fine. And look at that. It says installing TypeScript. Interesting, huh? And if we go to our package.json again, look at that. So it has now added TypeScript automatically for us. So if we go back over to our index.ts file, and I guess I should have showed that, you know, the server is actually running again here. We're still getting our cheese danish lovely console log. But one thing that's really cool is notice this little hint here. So it says property f does not exist. So it, you know, it's automatically detecting that in our object, and we're getting some very nice feedback. Lovely TypeScript. And this one, of course, does. This is, you know, something that you'd commonly deal with, you know, in the ecosystem. And then this error is just that CSS, whenever you import in TypeScript, it gets really mad unless you have type definitions for that. And there's a way to set that up, but I'm not gonna go over that. That's out of the scope of this video. But you'll notice something important here. There are these different errors in TypeScript, and particularly this one, and it's still built just fine. Hmm. Well, that's because parcel under the hood uses Babel to compile TypeScript and not the TypeScript compiler. And because of that, Babel essentially does not do type checking. The phrasing for that people debate. What it essentially means is that it's not gonna fail your build when types fail. It just, it's really just taking TypeScript and transpiling it to JavaScript and not doing any checks on the types at all. So this is hotly debated in the community in general for TypeScript, but particularly in parcel TypeScript. There's a whole bunch of GitHub issues where people are very angry about it, and understandably so. So parcel has kind of made this assumption for you, at least in parcel one, where they're kind of assuming you're treating it, I guess you would kind of say like a linter, where your editor is providing all of the type hints for you, and you, if you want to actually fail a build, you can fail it in your continuous integration, through PRs or something like that, so people can't merge code. I'll just show you a real kind of brief example. So you, because you have TypeScript, you could do something like tsc dash dash no emit and and or whatever, depending on your operating system. You have to do this a little bit differently in Windows. But this would make it to where when we go to build, well let's just show it, you know, why talk about it when I can show it, npm run build. It's gonna give you this type failure right here, and it's just gonna immediately fail. Oh, actually, tsconfig. Good thing I did that. So in order to run that command, you will need to at least have a tsconfig.json or whatever you want. You don't actually have to have anything in that, which is kind of funny. I'll just run a build, and now you can see it failing on this module.hot, except here. And it also failed, it should have failed on the other ones. Oh, there they are. Yeah. So your stuff won't build, and so you could do that. But really, that's not great when you're, you know, running a server and automatically changing every save and all that good stuff. It's only gonna run right at the beginning of that. So a lot of people are pretty upset about this, understandably, because, you know, the community of TypeScript, you know, wants that reliability for TypeScript to fail. It needs to be an absolute source of truth that's like, hey, if I clone this down and I run it and it builds, then I know it's good, because TypeScript. So I have not used TypeScript very much with Parcel for these reasons. When I went to set it up, I found all these things, and it was kind of turned me away from it. So maybe some people have found some workarounds that I don't know about. You shouldn't take, you know, my word is law here. This is just my experience for it. And it's kind of the downside is that, you know, the way that a lot of these frameworks add TypeScript support is just through the Babel or Babel, however you want to pronounce it, transpiling, which is cool because it's fast, but it kind of sucks because it doesn't actually do proper type checking. So this might be a deal breaker for you. For me it is. If I'm gonna do a TypeScript project, I'm probably gonna do Webpack still. Maybe it's not a deal breaker for you, and maybe you're fine with just VS Code, giving you the hints. The problem with VS Code, of course, or any editor, is that it's only going to show you the files that you see. It's not going to show you all the files in the entire project unless you had them all open. I think you've had enough of that rant. I just wanted to give you some context around kind of, you know, what's going on with that because it is one of the first kind of limitations that I've hit with Parcel. It doesn't mean that I wouldn't use it for other things, it's just currently I wouldn't use it for Webpack. And I also want to put it out there that the Parcel team knows about this and is said that they are working on changing the way that they're doing it based on community feedback and stuff. So, you know, keep an eye out for some changes there. Maybe it'll be Parcel too. You know, with all that kind of, I guess, that sort of negativity aside, we did get TypeScript up and running and compiling at least pretty quickly. So that's pretty nice if you're just wanting to dabble in it and, like I said, if you're satisfied with the way it is, then that's pretty cool. So we'll just we'll check this off as add TypeScript. And wasn't that neat that we just renamed the file TS and it automatically went and downloaded or installed TypeScript for us? Super crazy. Now here's where the fun begins. So we're gonna add Vue to our app now. And I should put a disclaimer out, this is gonna be Vue 2. It's at the time of the recording. Vue 3 is out, but it's on the next branch and support for it kind of iffy in different areas, especially with the PostCSS bugs that I had before in Parcel. So I'm just gonna do Vue 2 for now. And probably most people would be the most familiar with that as of this point. So what I'm gonna do is I'm going to create a Vue folder separately here. Look at that nice little icon they gave me, that's cute. And then I'm gonna make a index.js file and I will also, I'll just go ahead and make the app.vue file. We're just gonna make it a real simple, sort of like a Vue starter here. So this part I'll just do, you know, we're gonna import Vue from Vue. And I haven't installed it yet, keep in mind. And I'm gonna import app from the app.vue is what we named it. And then we'll just do, you know, the normal Vue. We're gonna render. I actually don't know what H stands for in this context. I've seen it put as like create element. I'm not really sure what that is, but whatever. This is the way that the build tool does it. Then we're gonna target root, right? Yeah, let's do root. So we're gonna mount it to root. I'll save that. And then for the app.vue I'm just gonna paste in some code to save you some time. I should have done that for the other one, but. Okay. Alright, so we've got a few things going on. I'm just gonna really quickly go through this. If you're not familiar with Vue, that's perfectly fine. I'm not gonna go into every little detail. It's gonna be a quick overview. Mm-hmm. And with, if you are familiar with Vue, then you should be able to decently follow along. But I do want to go through it to show you all the crazy stuff that's kind of going on here. So to start, we obviously, we're making our Vue app, and then we're going to render the app there. Doesn't have to be uppercase. I almost messed up. Someone else probably saw that. There you go. It was like so obvious. We're gonna render this app. This is just a normal format for it. And then we have this template. And you'll notice that we're using language pug for it. So this is pug syntax. And I actually like pug a lot. I used to use it a bunch, but whenever I'm doing Vue, I kind of like it. And we're gonna have this counter variable that you can see. And then we're just making a quick list. And actually, I am not going to be able to have this just yet, but maybe I should show it. I'll do, I'll delete it for now. Because I will actually mess it up. So we have a template, language pug. Then we move on, and we have a script. And notice we're using TypeScript. And we are, of course, getting the hinting here. I have purposely said this counter. I've set it to be a string, but it's obviously a number. So it's mad. And then here, just really brief, you know, data. We're gonna return counter. That's what we're rendering up here. And then we have a mounted set interval where it's just gonna count. Very simple. And then finally down here, we're using stylus. So I'm kind of just trying to get crazy. And we're using scope styles. And so I'm setting this up to where it's not just view, but it's also got pug, and it's got stylus, and it's got TypeScript, you know, all built into it. And we're just setting up some basic styles. This is stylus, if you've never seen it before. It's similar to Sass. Okay, so now that I've saved that, let's actually take our pages. We're gonna take our about one, and we're gonna commandeer that. We're gonna set that to view, since we're not doing anything nutty there. And I guess I need to update the link to be view. And then here, this is an index HTML, I'm gonna say, go to the view app. Yeah. And in view, we're gonna need an element of root to grab and kind of, you know, inject all of our view app into. We'll have a link to home still. Why not? And then this should say, view app goes here. And then this about JS, we're gonna go into the view folder and do index JS. And let's see if our server held up through all that. Probably not. I wasn't even running. Oh, well. See, it says, it really briefly said installing view. I don't know if you can see that, but I'll show you. Installing pug, installing stylus, hot reloading. Hmm. So let's open our browser and take a gander here. We have this link now, go to view app. Ooh, and it almost works, but the styles aren't working. But the code is. Don't worry, I expected that. I'm gonna show you why. So you can see that it's counting, which is pretty cool, right? Now, you might think that the styles aren't working because stylus or something like that. I mean, my syntax is weird and you wouldn't be crazy for thinking so, but it's not true. This is a really annoying gotcha that I ran into. And you know, I'm in a kind of crazy world of combining a bunch of stuff, but if you go into post CSS config, remember how we add to add modules true for that CSS modules? That actually breaks view and it's a known issue. So I'm gonna get rid of that and that's because they handle, like, they're scoping their own way, I guess. I'm not really sure. But when you just, like I said before, sometimes you save it, it doesn't work. So what I found you have to do to kind of get it to bust the cache is close the server, reopen the server, and then we'll just go into the entry point and we'll save. And I think that typically does it. No? Save post CSS config. There we go. Save that post CSS config, that's the secret. And there our styles are all working. We've got this lovely counter going on and we have a view app. So yeah, that CSS modules can't have that modules true in post CSS config if you're doing view. And you probably wouldn't anyways because you'd be doing it the view way. So I'm not gonna fault them for that one, but that gave me a lot of aches. But pretty cool, right? So we've got our, you know, our variables, bg styles, dark slate gray, text aquamarine, and then we're using them here just to kind of show stylus in action. And just a real quick hit on this again, notice that this is an error in TypeScript, but it's still building just fine. Just to reiterate that in view it's using TypeScript, but it still has the same problem. Still transpiling with Babel. Oh, and how could I forget? Let's go back to the package JSON here. Let's actually do the diff and show that again. Now this one's pretty wild. So you can see that it's, you saw it adding stylus and pug if you glimpse that really quickly. But you'll also notice that it, oh I don't want to open that. Go back here. Dependencies has been added and that's because view should be a dependency. I don't really know that view hot reload API should be a dependency, but they've chosen to put it there. But view typically should. And then this view template compiler and view component compiler, these were all added and put appropriately in dev dependencies along with everything else. I messed that up. Oh really you're gonna edit that for me, huh? So yeah, that's pretty cool. Once again, I'm really blown away by the the magic of Parcel and how, you know, just this one file having these references to these things it was able to pick all that up and just go ahead and install all those dependencies. Just fire away. I'll wrap this one up by showing that our post CSS stuff is actually still working in view though, which is good. So if we were to inspect this, we should see... let's do the... where's this container right here? Notice that we have these webkit properties here still for Flexbox. So it is showing that post CSS is still working. And even though it's annoying for me, I'm going to show you by fiddling with this again. So I'll go to post CSS config and I'll just make this an empty object, right? And I don't know if I have to restart the server for that. I do. So we'll do the old restart the server, go back into the code, save post CSS config just to make sure, and then reload this. And you'll see that those are all gone now. The webkit prefixes are not there anymore. So just to show that, you know, out-of-the-box view isn't coming with that, we added that with post CSS and the auto-prefixer. So let me throw that back in there real quick. Shut down the server, restart. It'll get real mad when you do that. As you can see, it dumped a bunch of logs out. And make sure that that's working again. I got to go back in here and save after. It's real tricky. You get some finicky behavior, but here you go. Okay, well I think that wraps up a view for us. Let us segue by going back and putting this line in here that I had before. This React app. Now we're gonna drop that in our project. Let's commit this real quick. And actually, ooh, I need that to not be there during this commit because it'll actually break the build. I don't know if you got to see that. Let me show you. See, it actually tries to look up this page's React.html because we had a link to it, which is kind of cool that it's letting us know that. But it will actually break your stuff. So I'll take that out while I commit this. Add view. And I guess I'll put pug stylus because they came along for the ride. Oh, let me undo that commit real quick. Do last commit. Thought I added them all. I guess I just barely changed that, didn't I? Yeah, that looks right. Cool. Okay, now let's put it back in. Boom. React time. So for this we're gonna do much the same. We will copy this view.html file. I'm just gonna paste it in there. I'm gonna rename it to react.html. And then here in the file, please go over to the file, we'll change this text, of course, to say React app goes here. We're gonna have pretty much all the same stuff except we're now going to look in the React folder for the index.js and we're going to make it a JSX file just to show that that works without any configuration because typically in Webpack you have to set up your resolvers for that. So that will have us coming over here and building a new folder and we're gonna make this folder react, of course, and add a file in there index.jsx. And then this is just your standard, I'll write this out real quick, import react from react. You could do it with star as react. That's how I should be doing it but I haven't updated my snippets. And then I, why didn't you do that? I'm going to go react dom and I haven't installed any of it again yet. No React installations yet. We're gonna have an app so we'll import app from dot slash app dot JSX. Well it'll be shorthanded. And then we're gonna render and let's render that app. And we'll do document dot. We'll use get element by ID this time here. And we're gonna get the ID of root. And because we don't have an app yet let's make that and app dot JSX. And I'm just gonna use a snippet real quick to get this done real fast. We're not gonna pass it anything. We'll just have a div and then we'll have an h2 because we already have an h1 on the page. And I will make that is react running. It's not really running, it just isn't rendering. Should be what it is but. Now is our server still running here? It usually won't be able to hold up to me changing file names around. So I'll restart that and you should see it installing React. Doing some extra stuff too. React dom. Hmm. Okay. Let's reload this and we're on the view one and we made this link to React. And React is running! At least it's rendering. Right? Let's make sure by adding some state real quick. It's one thing to transpile JSX but so what I'll do is I'll just I'll do IMRUS. Get that going there. We'll make that here and we just call it use state why not. And I'll start it off as false. And then what I'll do is I'll be really silly and on an h2 I will put an on click. And this on click is just gonna be an anonymous function and we're going to set state and we'll set that to the opposite of what our state is and then we'll change this to say oops. Huh that shortcut doesn't work. That's so sad. We'll change this to say what is state. What is state? And then we'll render the state and but we need to turn it into a string because otherwise it will just you know false out and be nothing. Really simple app here right? Let's go back here and see. We've got reactivity. It's like hard to do that without dragging. Now we come back to our code. You know the package.json you already saw it doing this but isn't that neat in the dependencies it is thrown in here react and react-dom. So it's done that for us as well. I'm kind of beating a dead horse at this point aren't I? But I I really think it's worth mentioning how each of these different frameworks it they've taken the time to handle and install things for you and quite frankly that's amazing. So I think the next thing that I'd want to you know make sure works is images because typically there's some configuration to do that in any sort of bundler right like especially JavaScript or rollup. It's not super hard but you know you're gonna need them. So I'm just gonna copy some images in here and all I've got is just a few different logos all right and what I'm gonna do is I'm just gonna straight up import this and say let's call this SWC logo from and we'll do dot dot slash images slash and it never auto completes these for me unfortunately but we'll do this logo dot JPG and then we'll just drop an image tag here and for the source we will make it point why did it not backspace both quotes rude. SWC logo. I'll get rid of that and I don't care about the alt tag right now obviously. Let's see if that loaded. Boom! No config. Just got images working from imports. Okay so that was a JPG. Let's just really quickly change that to a PNG and see how that behaves and oh my goodness that is big. Let's go down here and set the width just to be lazy and set that to like 800 and there you go. So you got a PNG loading right but can I do SVGs? Spoiler again. All right that looks the same right? So let's inspect it and look it's output this little file here dot SVG. So I guess that's a point to leave a quick note here is these are all image sources which is super cool that they work but actually rendering SVG code like the SVG XML code into the DOM so that you can change it with CSS selectors and stuff like that is always problematic for me and in a lot of frameworks especially I've had a lot of problems with it with React. You usually have to have some sort of package that converts it to React component and the syntax isn't quite the same as JSX etc etc. I've also had the same problems with Parcel. I had a hard time finding out how to like directly render it because if I just render you know SWC logo right now it's just gonna be text it's just the path. So if anyone knows like an easy way to do that that would be awesome if you could leave a comment on that because I always struggle to find a good way to render out my SVGs. You get it. You get it. So bam bam boom there you go images. Cool. Let's make a commit. Add React images. React in images. That was it. Now this really surprised me actually. Now this is cool. So that we have all the great flavors of CSS going we've got styles, we've got sass, we've got CSS, we've got CSS modules. We're gonna put style components in here now. And so what I'm gonna do is I'm going to import style components from here and then I'm going to create a style component and I'm gonna call it container. It's just a div, nothing crazy. And I'll put one thing on it for now just so we've got it. I'll do display flex right. I'm gonna save that. Oh I caught it. You can see it redoing some fancy stuff. And before I go over to the page, let's see, look at that. My mind was blown on that one. The React thing, the view thing, those were all really cool. But wow, like just an import of style components and you just detected that and installed it for me? That's cool. So let's change this to a container. If you aren't familiar with style components, I won't spend much time on that, but they're a CSS and JS type of format if you've ever heard that form. It basically takes every sort of set of styles and turns them into a component so that all the styles are scoped to that component. Also a very hotly debated thing, but I like them so go away. So here we'll do, you know, I'm gonna type this out just so you can see. So we can do flex direction column. I thought you could do FTC there. Can you do DF or display flex? Or is that, I'm just curious now, DF. Oh you have to do DFL. Yeah, okay. Anyways, I wanted to show this real quick that you'll notice that I have syntax highlighting in here and also I'm getting like emmet completion. You know, I can go PIC, place, it doesn't have that one. Let me show you another one. Let's do BGC for background color. We're gonna do midnight blue. Then we'll do color is cornflower blue. And then we'll do FFSS. This is really cool one that I like. If you ever just want to do a quick sans serif FFSS. And so what I'm showing here is that this is Emmet, if you're not familiar with it. I have to do control space for that one for some reason. And this works inside style components if you have, I believe you have to have a VS Code plugin. So you can actually do P40 here. And I've made you watch me type this up long enough so I'll really quickly do it. But what I wanted to show was style components. There's this plugin, VS Code style components. And this gives you syntax highlighting and kind of treats it as a language so that you can get the CSS auto completion for IntelliSense and all that stuff. So you're gonna want that if you're ever using style components in VS Code. All right, let's finish this up super fast. Not much left. I will do FC 64 here. And then we just need to do an a tag and then we're good. 28. Forgot what I did. And the color will be Alice blue, just so it stands out. Keeps with our blue color theme. All right, that's that. Now let's head on over to here. And yeah, look at that. Not the most beautiful, but it's all right. So this is just to showcase here really that, you know, we've got these hashed class names from style components. It just works. And usually style components works pretty easy because it's just JavaScript. But it's worth showing. And it's got all of these vendor prefixes. These actually aren't coming from PostCSS. Style components comes with them. So if you didn't have PostCSS installed, these would, you know, be here automatically. But I'm not going to waste your time showing you that. So let's add a quick link here. We'll do it above the image so we don't have to scroll down. So here I'll just do an anchor tag. And we'll go we're going to go to view.html just so we can bounce around. Go to the view app. And then I guess we also want slash index.html. Home. And isn't this cool? Like you've really easily between that beautiful gradient, you've really easily between all of this are just jumping around between all of these different React apps through multiple entry points are different JavaScript frameworks with a React app with a view app. Sorry, I was reading the text and it got in my head. You go to React app, you go to the view app, you go to the home. And that's really neat. It was pretty easy to set all this stuff up and a lot of it was real magical. So wild. I think that's pretty good. Let's commit that for a moment. So we'll say add React. Or no, we added style components, we already added React, right? Now it's really briefly, this will be fast, but I want people to know how to do this. Let's change it to TypeScript, React TypeScript. So all we need to do here is rename these files TSX. And then we'll rename this. Now, if you didn't have TypeScript already set up, it would actually detect this and it would automatically install it just so you know, and that's really cool. The index or the React HTML, we're going to have to change that to TSX. Okay. So there is one thing that you have to do here. Let's go back to index TSS. And you'll notice when you go into this, VS Code is actually telling you cannot use JSX without the dash dash JSX flag. Now that's because you have this empty TSS TS config. And when we, where's my, thought I had it on my clipboard. When you paste this, you need compiler options JSX React in order for that to work. Now, that's all you need. You go back to app, it's working fine. This will still be an error because that whole, you know, when you're importing images or CSS, it doesn't know what type that is. But it is now working and running. So let's make sure we change the file name. So of course, we have to restart the server. What did I mess up? app JSX. Oh, that's weird. It's app dot TSX. It should, it doesn't need the extension. It'll get mad if you do that. It sorted itself out. It was really weird. I just guess I just have to save the file again. It is I think it's just really aggressively caching this stuff to save build time, which sometimes is annoying. But I think you can disable that. Anyways, there we go. Reload the page, go to the React app. Oh, and our apps broken. That's not Bono. Oh, I think I might not have saved that. That's probably why I didn't update. Oh, I'm sorry about that. So here we go. Everything's working just fine. And we still have state and all that beautiful stuff. So that puts us done with that. But you you might want to see just really briefly, you know, some of the actual React TypeScript stuff working. So this will be super fast. I'll say typography equals a function that takes children. And it spreads its props because we're going to need the action off of that. And maybe you want to send class names or whatever. And then here we'll do an h2. Spread props onto it. Normally, you shouldn't do this. But if you're doing a component library, you might. It's getting a little long there, isn't it? No, you won't format that for me. Can you do jerk? Okay, so we have this typography. And now we're going to swap out this h2 for that. I don't know why I didn't change both my tags. And you'll see that we get a TypeScript error here. And it'll say property children is missing in type and then it's got the type whoops, on click any etc. And that's because you know, you need to do something like this, however you want to do it. React.fc to say it's a functional component. And there you go. So I just want to show that TypeScript, you know, working in IntelliSense, they're same thing as before, it's Babel. So it's not actually going to fail to build, you get it. So there you have it, TypeScript and React. So let's add all this stuff here. We had to change this ts config. That was pretty much the only thing and I wanted you to see that. So that you know that that is a minimum requirement. Add TypeScript and React. Okay, and I think a great way to wrap this up is to add Svelte to top it all off here. So we will go through this process real quick. We're going to copy the React page, we're going to paste that, we're going to rename it Svelte.html, you can name it whatever you want, of course. And we'll go up here. Svelte app goes here. I probably could just change that one word, huh? Stop being dumb. And here we might as well put some links. And we'll say we want to go to React app. I'm going to be lazy and just put view app, whatever. React view. We still got our root. I don't think we're going to need that, actually. I'll leave it anyways, though. And then here we're going to go to Svelte. And this is going to be index. And don't forget that's just a JS file coming up. And then we can go over here to our sidebar. And I will create at the source level a new folder. And this folder is going to be Svelte. Svelte. It's hard to type. Index.js. Did I put that in the right spot? Yeah, I did. And then I also need to add another file here. And that's going to be app.svelte. We're just going to use the same pattern. And this stuff I will paste for you to make it a little bit faster. Okay, so we're going to be importing the app. This is just a normal way to set up a Svelte app. We just target document.body. And the only difference is we're passing a prop here with the name Svelte. Then in our app Svelte, we will paste all of this code in here. And it should install that automatically. It might have. Let's check our package.json to see if it updated. It did not. Ah, yes, that's right. So let me very first go over really briefly the code in here so you can see what it's doing. And then I'm going to show you how Svelte takes a tiny bit more setup. Not much. But there is another gotcha. So we have a script tag. This is the normal business. We're exporting let name. And that is how Svelte is going to bind to that name or be able to pass that prop in. We have a count. We have a handle click. Nothing crazy. We have some styles, which Svelte does scope as well. And then we have this HTML here. And we just have an on click handle. And then you can see we're going to do this cute little logic you don't really need to pay too much attention to. But it's basically just to say how many times the click was counted and to have a little face. And you'll see it in a moment. And then we have our RLR links. Right. And I guess that's I don't know why I put those in here. I shouldn't even have those in here. I should have them in here. I'm a dummy. And what's kind of cool, I just want to show this is like, let's say that you got rid of the button. You'll actually get some nice little helper stuff from Svelte automatically just because VS Code and it will tell you that this thing is unused. And I really like that about Svelte. It's really dope. OK, so it's not working. Right. And I'll just let you know, even if we restart it, it's not going to make a difference. OK, this is one of the ones that, well, go over here. NPM start. It ran some stuff. You know, don't take my word for it. I'll just show you that. Right. I thought I put a link to Svelte. Now, let me do that real fast. React. Why can't I type that? Such a weird word. Svelte app. See, the monkey learned. Now go to the Svelte app real quick and you can see it's not loading. All right. So what's going on here is we actually do have to install this one. It doesn't auto detect it. And I might know why, but we want to add Svelte and then we need to add this parcel plugin Svelte and then also a parcel bundler. I think it's just parcel bundler. Not sure why. So we're going to install that and I will briefly show you in the docs. If you come over to Svelte. There we go. They tell you to install these as well. Parcel bundle or parcel plugin Svelte and then parcel bundler. Now, when I run this, though, it's going to get upset. I'll just briefly tell you that this. So what this is, is it's kind of a funny predicament. This also took me a little bit to figure out. So this is that the parcel plugin Svelte, the maintainer, I believe, didn't tag the newest version that fixes this error. And it's from many months ago. And so even if you do. So I'll do npm i dash d. Parcel plugin Svelte. And I'll do at latest. OK, I want to show that when I do that and I go to my package JSON. Parcel plugin Svelte is at 406 currently and multiple people prodded them to update the tag because they actually took the time and fixed the bug, but they didn't. The package is up on npm, but it doesn't show up. So you actually have to type it in manually and say 4.0.8. And there you go. That's that. And then when we do npm start. This was from an update to Svelte. I shouldn't say recent because it was like six months ago. So that ran. Go back over to here. And there we go. Now it's working. So, you know, before I move on, I don't want to, you know, be crapping all over this open source dev. Obviously, he's doing it for free. We should be grateful for his work. But it wasn't annoyance that I ran into just because they hadn't taken the time to tag it. But, you know, life happens. Who knows what's going on in his life. So thank you for all the work you do. Nameless soldier. So, oh, hi, Svelte. Here we go. And you can see we have this very upset face because we haven't clicked the button yet. Click the button. There's now a jolly face. Click there. There you go. You got a Svelte app. You've got a React app. You've got, you know, a Vue app. You can click things. All the different things, all sorts of setup and configuration in this. And I was actually going to show Tailwind with it, but there are more of those post CSS 8 difficulties that, like I said, the Vue 3 community had problems with it as well, and they had it with Tailwind, and that's how I learned about it. So I decided it would just, you know, lengthen the video too much, and I think you get the gist. I'll link this in the description just so you know. But how you get it working is there's this post CSS 7 compatibility build that Tailwind has because they talk all about it in this little article here. Like I said, I'll link it. And so it's a known issue. It's not necessarily Parcel's fault here. Like I said, Vue has the problem as well, and I'm sure other things do. So I won't go through setting that up. I'll just give you the link. And with that, I think we can call it here. I think we've seen a lot of the power of Parcel and how cool it is. And I know Parcel 2 is somewhere around the corner. I thought about waiting for it, but, you know, it was in alpha for like a year and beta in half a year. It's been a really long time. They've been doing a ton of cool work for it. There's all sorts of stuff to be excited about. But if you want to get in and use Parcel right now, you can see that it's pretty dang cool. I know we really breezed through a lot of content there really quickly, but I hope it showcased a lot of the really cool functionalities of Parcel, and maybe you'll be interested in using it for any of your projects. I haven't actually used it as an entire, like, enterprise project yet, but I'm really wanting to try that. But I use it for development stuff all the time because it's just really fast to set up, and I think it can get you really far. So, you know, you might not want to worry about setting up all the cool, crazy webpack stuff if you just want to kind of get going and start working on stuff right now. And, you know, if you have problems down the line, you can convert it to something else later. But I think it's really worth using. I hope you enjoyed this video, and I hope to see you in the next video.