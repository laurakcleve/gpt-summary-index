[{"page_content": "Welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and in this episode, we're going to be talking about Webpack. In particular, we're going to be starting a new project and setting up Webpack because I want to show you just how easy it can be to go from zero to having modern JavaScript transpiling for cross-browser support, as well as obviously all the good module bundling stuff that comes with Webpack. Now, the reason I picked this topic is because I've noticed quite a bit of anxiety around the idea of Webpack configs and getting it to work, and I think a lot of that stems from, I myself have had it in the past, I think that stems from all of the awesome tools like the view starters or create React app or that type of thing that give you a working Webpack setup right from the beginning. And that's awesome until you get down the line and you need some customization that it makes it a little more difficult to add, or especially if you just want to start all over, you don't really know what you're doing. So that is why I picked this because I think that Webpack is a little bit misunderstood because you always end up seeing a really, really advanced custom setup that's just crazy to follow. But it's actually quite simple to set up on your own and to add the pieces one by one and understand the basics of a standard Webpack config. And that's what I want to show you here. So we're going to be diving into all that. If you are unfamiliar with Webpack in general, just a real quick intro to it. In the past, there's been this long series of problems with JavaScript in the browser as far as having to load your scripts, load them in the right order to avoid name collisions, to deal with minification, bundling and all that type of stuff, and not just having one, you know, giant file, all that type of stuff. And over the evolution of time, Webpack has kind of proven itself to be the champion amongst that. There's been some awesome developments along the way that led to it. But at this point in time, if you want to break your JavaScript up into multiple files, and you want to have it, you know, bundle them efficiently into one file to serve so that not only is it fast, because there's that only that one file to download, but it also goes and builds this dependency graph of all the different imports, you can use the import, export or require common JS versus ES module syntax, as long as as well as getting all of the code splitting, and tree shaking and all that cool modern stuff. So there's a whole lot to distill there. That's as much as I want to talk about that for now. Because if you're here, hopefully, it's because you're just looking for how can I get this thing set up? And how can I understand this thing a little bit better? So I think we should just jump right into that. All right, let's kick this off with a simple project here. So we'll start off by making a directory. And we're just going to call that webpack, maybe setup, go into that directory. And then we can create an index dot j s file. Now you could create this with your ID or however you like, of course, we're going to start off with an npm init dash y, since we know that we're going to have some packages here dash y to say yes to all the flags or questions that pop up. And after that, I think what we'll do is we'll touch an index dot html as well. And then we will open our editor in this directory. Let me bring that down here. And here you go. So with our index j s, we'll start off just doing a real simple, you know, console dot log here. And we'll just say, ran from index dot j s, oops. And in the index html here, we can put use the bang emmet abbreviation to just create an HTML document. And then from here, well, let's actually go into this and say webpack testing, why not. And then we just want to create a script that is a type of source. And that source is going to point to our index j s file. And that's it. Okay. So I just always like to get everything just running first, and then kind of do it incrementally as we go along. And then we'll add our webpack once we need it. So to start with this, we will reveal this and explore for me. You know, I'll just open that up here. Might as well. So we're opening this HTML file in the browser. And if we go to the inspector and go to the console, we'll see that we had this ran from index j s, bump it up a little bit, since we really don't need a lot of space here. Okay. So obviously, our thing is working, no surprise there. Now, now let's do the first thing that's going to make it to where it will not work that will need webpack for which is, we want to import a file. So let's say we're going to import. Oh, I don't know, we're going to make, let's make a, a wizard here from slash wizard. That probably should just be default, but whatever, who cares. And then in this file, or in our directory, we'll do when wizard.js. And the wizard will export. And then we'll just say const wizard equals and let's just give it a name. Not really thinking about anything special here. It's just for demo purposes. And we just want to import that wizard. And then let's say, after we said ran from index j s, we'll console dot log that wizard. All right. Now, if we were to refresh this, you can see cannot use import statement outside a module. So we'd have to use a module type script import, which is pretty atypical to use as of right now, just due to support and everything like that from what I've seen. So we want a way to bundle this all together into into one file so that the the browser knows that it could just load this one script, and everything will be in order and have the proper scopes. And in fact, let's do one more example here. So we'll say, let's we'll import two things. So we'll have a barbarian. And if when you're importing, you don't have to put the dot j s extension just so you know. So we'll have this barbarian here. And then we will do barbarian dot j s export const barbarian equals huel mar. And there you go. Okay, and then we'll just console like that and console log this and this will be barbarian. Now obviously, that's not going to work. All right, same thing. So this is where we'll first introduce webpack. So we will go back to our terminal. And in our terminal, what we can do is npm i for install, so you can type out install if you like, and then I'm going to do dash uppercase D. This is the equivalent to install dash dash dev. But what we want to do is npm i dash D webpack. And you need webpack CLI whenever you're going to run webpack in this way. I don't know what happened there. The first command just hung. That was pretty weird. Okay. So we've installed webpack and webpack CLI now. And from this point on, really, all we need to do is put things in the right directories. Because what a lot of people don't know, or at least the people that I've anecdotally encountered, is that you don't need any configuration since webpack for to run it with a real basic setup, which is pretty cool. So what you can do, this shouldn't work, but until we change our folder directories, but you could do npx webpack here. And that will use npx to go and grab it's basically a an npm addition to grab the latest version of webpack or use your local one if you have it. In this case, it can't resolve dot slash source. So it's kind of pointing you to the problem, it'd be cool if they had a little bit better error message there, but it's in their docs. So what they want us to do is create a source folder, put our index JS in that folder, okay, update imports. Actually, we want to do all of our stuff in here. So might as well just put them all in here for now. Go to wizard, move that into source. And now we go back and index everything should work fine. So now we can run npx webpack. And you'll see that it ran. Pretty cool, huh? So it created this asset main JS. And what we're going to do is we're going to see that right here in the dist folder. So it's automatically set up to look in the source directory for this index JS and output to a main JS here. And here we have the file. So let's take a quick look at that real quick. And it's kind of interesting, huh? It's got use strict, so it automatically enables strict mode, which it does quite a few things. But that's essentially that it's going to make a lot of things that didn't used to cause errors in JavaScript now cause errors. Because down the road, you'll have more headaches if you don't know the errors up front. It does more than that. But that's the main thing. And then we've got a console log. And you can see they're using this comma between each one, which is interesting. So they're going to console log this console log this console like this. So you see, there's no like imports or anything like that, right? Like it doesn't have any concept, it doesn't even create those variables that we did. All it does is it takes all those files, puts it together. And it's like, what's the end result of this running, which is pretty cool. It's pretty lean. And you saw that it came minified. This semi colon just has to do with this whole wrapping this.", "metadata": {"title": "Creating and Understanding a Basic Webpack 5 Setup", "url": "https://www.youtube.com/watch?v=X1nxTjVDYdQ"}}, {"page_content": "Entire expression here thing. Don't worry too much about that. This is a function, obviously an arrow function that is then going to get called immediately after this is what's known as an iffy or an immediately invoked functional expression. So and that's that. Now we just need to put it in index HTML. We're good to go. So the index HTML we're actually going to put into our dist folder here so we can just relatively reference this. And we'll pretend that this is like this is our public or our distribution. These are the files that we're going to load up somewhere eventually. And so now instead of index JS, we'll just do main dot JS because that's our end result here. And if I were to open this up, in fact, I need to reveal this and open it again because it's changed directories for me. Inspect this over the console. And there you go. Just refreshing. You can see that it runs pretty cool. So what this has given us is, you know, module bundling right out the bat with zero configuration, which is really cool. We can use our imports. You can use require common JS or imports or anything like that. And that's pretty neat. Now, one thing I want to show you that was really interesting to me when I was messing around and looking at it. And I just really recommend like you don't need to get crazy getting into, you know, looking at your bundles all the time, but it's kind of nice to remove a little bit of that magic and see what's kind of going on under the hood and have some idea there. Right. Like we might not even know that this is causing a. Whoa, where did I go? That this is using a an arrow function on the output. So this actually wouldn't run on some older browsers, which some people might expect it to. But without Babel and without some settings, it's not going to. Now, something that's interesting here real quick is that I'm going to create a another file here and we'll just call this like, I don't know, get classes or something like that. And what I'm going to do is I'm going to create a function called get classes, and that is going to in here. We're going to get those imports from here and then we will paste those here and then we'll go over here and steal these buckaroos and paste those in here. So this is pretty silly, right? I'm just moving it into a function and then I'm going to do export default get classes. So now I've got this module that's whole purpose is to just import these two and then console log them. Now, what's interesting about this, though, to me is that if you were to import and we can call this whatever we want now, but we'll keep the name get classes from get classes and then we run it, get classes. What's going to happen here now, we need to bundle every time and at this point, we'll want to actually add a script because you might as well. And we'll have a build script and that is going to run Webpack, our local version of Webpack. So we don't have to use the NPX command to type it out anymore, though you could if you wished. So now we just do NPM run build. Oops, I didn't mean to not put a space there. It's going to build just fine. And then if we go back to our browser here, we reload. You'll see that this is the same and that shouldn't be too much of a surprise. But this might be. So if I click if you miss that, if I go to the console and I see where this ran from, I can just click main JS and go to the source. I can click this little pretty print here and take a look at it. And this will be nicer than going in and reformatting. Every single time in our editor, because this will stay this way if I reload. So you'll see that our output here is actually the same as before. That's kind of interesting, huh? So we've got these two variables that we're creating, and then we have a whole function that we're importing that imports those two things. And really, Webpack here doesn't care. It's just like, well, in the end, this is really all you need. So this is kind of neat, but also might be a surprise. You might expect to see some of those functions or variables or something created in here. And that's not what goes on. So I just want to show you that real quick. So that's the first step of having Webpack set up. It's pretty simple. If you just want the bundle import functionality and nothing special like that. There you go. That's all there is to it. Now, next, what we're going to want to do is add some Babel, Babel, whatever your preference, transpiling, because we want our code to work in a little bit older browsers. And so we're going to want to put that in the pipeline, which is just one of the default things that you're going to want to do when you're setting up a Webpack. OK, so in order to do that, we there's a couple different ways we can do it, but we're just going to opt for simplicity here. Simplicity sake, we want to come over here and say, OK, I want to now install and we're going to need Babel slash core. And we're going to need at Babel slash what we need. Preset ENV. Yes. And finally, we're also going to want Babel loader. Now, this is our first loader, and this is what Webpack uses to figure out how to handle certain operations. There's like file loaders in case you need to load your CSS and your JS or your images in your in your JS and all that stuff. But just so you that, you know, that's what loaders are a common terminology in Webpack. So we'll install this first and we need the Babel core for obvious reasons. That's the core. But we also need the preset ENV. And what that's going to do, it's pretty cool, is it's going to figure out automatically it has some default settings of what the kind of latest browser support, how much backwards compatibility we should have. That's sort of reasonable based on usage statistics in the Web. It's the best way to think about it simply. So if we come back to here, we can now create a new file called Webpack dot config dot JS. With that Webpack config, what we can do is start our module dot exports. Now, you do need module exports here. I believe there's a way to set this up to use, you know, the ES import export type syntax. But since you're not like by default running, you know, your your Webpack or your Babel on your actual this Webpack file, it's an entry point. I just stick to the module dot exports format. I have seen that you can do it other ways, but I'm not knowledgeable enough to know that part. So I just stick to this. It's pretty simple. OK, now from the beginning, what we want, we actually don't need an entry and an output, which you'll commonly see. And we'll add that in afterward. I just want to show the minimum thing that you need here. So you're going to need a module, right? And then your module is going to have a set of rules. OK, and those rules are an array of objects. And then at this point, you're just going to want to write a test. And the test that you're doing is essentially saying, like, what kind of files do I want to run this against? So in our case, we're going to escape the JS is a regular expression. And we actually want the dollar here and put that there. And so we're saying, you know, any file that ends in a dot JS, the dollar is just saying ending in. And then we want to exclude our node modules. We don't want to be running our transpiling on other people's stuff that we are importing any package or anything like that. And then this use object is a way to say, OK, well, what loader do you want to use to accomplish this? This is just a normal module and web pack. You do the same syntax for other loaders. And we want the Babel loader that we installed. OK, so it's maybe worth commenting here that without additional settings, this will reference a dot Babel, RC or any of the other Babel extensions. So you totally can just put your Babel preset ENV right here after this. But since you're almost always going to want to start doing a little bit more maintenance in the Babel RC file to tell it how to behave, you're going to want to create one ahead of time. You might as well just start there. And then all you need to do in this is pretty simple. You can just say presets. What presets do we need? Well, we need at Babel slash preset dash ENV. Sorry, my brain left me for a moment. OK, and that's that. So what this will do is web pack is going to say, hey, whenever I encounter any JS files, except for node modules, I will use the loader Babel loader, which knows to go and look at this. So that's going to use our Babel core with our Babel preset ENV, which is going to just kind of give us some standards to transpile to. Now, when we go back and we run NPM run build. We're going to see that the output is a little bit different, possibly. We might actually need some some things to make it different. Nope, it's the same at this point. There's nothing that really needs to be transpiled for the latest browsers. This arrow function used to for preset ENV, but we've moved to the point where it's so highly adopted that we don't need to transpile that for most browsers anymore. If you're using old, you know, or if you're trying to support really old browsers, then you would. And we'll dabble on that in a moment.", "metadata": {"title": "Creating and Understanding a Basic Webpack 5 Setup", "url": "https://www.youtube.com/watch?v=X1nxTjVDYdQ"}}, {"page_content": "Okay. So at this point, you've got your web pack all set up and it's pretty simplistic. And let's add some other things into it to kind of show that, uh, we have this Babel support actually working. Right. So we'll leave this, like we ran from index. We did the get classes. Everything's working great. Um, but now let's do like const object and we're going to make this object. So hard to come up with names. I'll just do like a simple, like alpha bees, Bravo. Okay. And then what I'll do here as I'll say, const new object equals dot, dot, dot object and C let's append Charlie here. Good old Charlie. And then we'll console dot log that new object. So we're going to use the spread operator, which is newer and just take our old object and turn it into the new one with C concatenated onto that. Okay. And at this point we should see some, uh, actual transpiling going on here. So the difference between compiling and transpiling is just that, uh, compiling is actually compiling to either a different type of language or yeah, that's the gist of it, but transpiling is kind of to the same language, but an older version of it. So it's adding backwards compatibility. Just a real quick one there. Okay. So we've run the build and we come back here and actually let's just use the browser here to reload this. And you'll see that we have, uh, all of this lovely code that it's added. It's a whole bunch here. You can see it still has our console logs. And at the end, it has this interesting little, like our function, uh, that, the, you know, this looks like an object assign or something like that. It's taking an object and then it's taking, um, this, it starts with an empty one, it has this new one. And then it adds onto it, the C Charlie, and you can go up here and see that there's a function are defined and we don't really need to dig into what all it's doing, but we can see it's doing some get own property descriptors and defined property and all that type of stuff. So there's a lot going on here that we would have to write to get this functionality and some older browsers that don't have, uh, you know, just default spread syntax, um, just to do that safely, kind of crazy, huh? There's a lot of stuff going on under the hood, but it's that simple. Just set that up. It's really neat. So coming back over to here, let's just kind of do this one thing at a time here. We've got this mode, right? And, uh, by default, it starts off at production and we're going to set it to, uh, this has to be a string, right? Yeah. Development. And just to show that before we run it, this, this is a like minified and mangled mangled means it takes all of the variable names and turns them into like one letter definitions to make it even smaller. So it's just kind of compressing it as tight as it can. No white space on one line, all that that's production mode. And the default starts like that. And that's why it was like that when we just ran it without any config file. Now we're going to change it to development. And when we do development, you'll see that when we run the build here, what did I do wrong? Invalid configuration object webhack has been initialized using a configuration object that does not match the API schema. Mode. Oh, I did it under module. I'm an idiot. Sorry. So, uh, yeah, that that's a, that's a root level property. Silly me. All right. And then we go to the domain again. You'll see, Whoa, it's got all these comments now. So it's, it's tried to give us a lot more information on what's going on. And this will allow for cool sorts of things, uh, like source maps, which we're going to add next. So if we were to reload this in the browser, once again, we'll see that it's a completely different whole nonsense setup, which is kind of cool because it does tell us, you know, some extra information and it gives us these little, um, where are they like source barbarian JS. It's telling us like where each of these files. What came from where the methods came from and all that stuff. Sweet. So next, okay. Now what we want is we're probably going to want to do a little bit of like source maps, so this is another root level rule. We don't need another module at this point. Uh, what we want is just this dev tool and we want to do source map. And I don't believe we need a package for that. We need, do need a comma here and we'll come over to here. We run it again and we're going to get kind of an auto builder in just a moment. Um, so we can just watch these files, but for now we're just kind of, you know, keeping it lean and we're going to do a little bit of a backup. You know, keeping it lean. All right. So it's made all these things and you can see now, uh, let's see if it says it here. It doesn't say anything about source maps. Let's go check it out though. So reload this and the difference here should be, let's see, main JS formatted. So. Oh no, it actually is working. I'm just being silly. No. Oh, it swapped over on me. That was weird. I must not have refreshed on this page or something. So you can see that, uh, it now tells us where these things are coming from. Get classes, get classes. It's pretty neat. Um, so if we were to click this here, it will take us to the actual file so we can see the code, not the, uh, you know, main that's been put everything together. So this, this main still exists and it's all inclusive. It's the only thing that the browser is actually running, but it sends along this little file here, main JS map. And what this is, is a way for it to map between the relationships between our all bundled code and the individual functions. And this helps us troubleshoot. So when we're in dev mode, we probably want source maps and that will allow us to troubleshoot bugs and errors and all that stuff much more easily. And we get that so easily by just adding dev tool source map. Now, at this point, we are pretty tired of running NPM run build over and over again. So let's get some developer experience up in here. And it's neat about webpack is it actually comes with a dash dash, whoops, dash dash watch flag. And what that is going to do is make it to our, let's show that what I'll do is I'll actually use the VS code terminal here. We'll run build. Um, and that's just so that I don't have to alt tab and you can see it. So it's run and you can see it's still just watching files for updates. Now let's, uh, we back here, we type this in with a lowercase and let's just change it to an uppercase, very minor change. Save that. You can see it recompiled that file. Pretty cool. Right? And, uh, we could go find that if we were, you know, we don't believe it. Oh, well, it's right there. Nice. Uh, wizard, rap one, all uppercase. So there you go. Now let's take it a step further though. What we can do is say we actually want to, uh, start up our own little server here. So we'll make a dev server property here, and that has a content base and you got to tell it like where to look for your stuff. And we would tell it, look in that disc directory. All right. Cause that's the default here. Right. And from that point on, we need to actually shut this down here. And, uh, I guess I could do it there, but what we want is to add, uh, another thing, web pack dev server. So this nice little package, we'll make it to where we can actually open up a server. Instead of just opening that file and refreshing it, we can have a sort of the normal, what you would expect, like hot reloading server here. And then it keeps all of our changes kind of in memory. So they update immediately, uh, in order to enable that, what we want is a script here and let's add a start script at the front and the start script is going to run web pack dash dash serve. Actually, I think it's just serve. Yeah, it is serve. I'm being silly. And that's all we want to run now. And then what we can do is go back to our terminal and say, NPM start. And notice that we got this nice little server here. Project is running. So let's see if that works. If we go over to our browser, um, we can, let's put that in this right here that I have opened this up console and we still get this, uh, oh wait, failed to load resource. This is different than I thought. The server responded with a status of 404, not found weird. Okay. I had to reload. Okay. So we're going to go ahead and run that. Weird. Okay. Live reloading enabled. Cool. Okay. So here's all that stuff. And then let's go back to our code and say, all right, well, um, you know, at the top of this, I'm going to say console dot log, get classes was called. Why didn't I put that together as a function? I don't know. Who cares? Get classes was called. Boom. Just like that live reloading. So now you've got a nice little server to simulate development. Um, it's all going through this index HTML, which is like what your actual thing would, uh, load your browser. And at this stage, you can actually host this if you want to, you can put it on Netlify or any other CDN or anything like that. It's just a series of files. And you can actually, um, because you have a build script, you can just tell if you use something like Netlify, you can tell it, uh, you know, every time I push for continuous integration to my repo, I want you to run the build command. And then that will output to the dist folder. And by default, it's going to, you just tell it that that's your entry point, dist or public or whatever you want. And it will serve up some files and you have a site at this point. Pretty cool. With some cool developer experience. Now, um, what I want to do just for a moment is just show you that, uh, typically you're going to see in your web pack config, uh, one little extra rule here. And I did it this way on purpose because I wanted to show you that you actually don't need this if you just want to use the default settings for source and dist. But what you can do is, uh, you can have an entry point here. And for that entry point, we want to say, we want to give it the relative path. So this is the entry to our index JS file. And so, well, any, you know, any row, any since Parallel or Mon somebody knows where it is, and then we're going to go ahead and select it. Press submit command. Let's give me, you know, 15 minute.", "metadata": {"title": "Creating and Understanding a Basic Webpack 5 Setup", "url": "https://www.youtube.com/watch?v=X1nxTjVDYdQ"}}, {"page_content": "File actually doesn't have to be index, but we're going to say it's index because that's what it is. And then I want to say, well, our output place, and let's put a comma there just to get rid of that. We need to do pass it an option, which has like the file name. And so that's what we want to call it. So let's say instead of main JS, we want to call it bundle.js for whatever reason, you know, maybe we have a reason. And then we need to give it a path. Now this one's a little bit weird. Um, I'm actually not sure why we can't use relative paths in this place. We need to use path resolve and use dur name and pass it whatever folder we want. Let's make a different folder. Let's make public. So we've got a different name, bundle JS, and then we've got a public folder. Now, a little bit information about this path is something that comes with node. So we can just do const require or const path equals require path. And then we'll have that no big deal there. We don't have to install another package or anything like that. And this dur name is also something that comes with node. Now, what dur name is going to do is it's going to find the directory or find the file that you're currently at this directory name of the file you're in. In our case, this is root. Now path actually requires a relative or an absolute path, sorry. And because of that, that's why we have to do path dot resolve to commit that absolute path. I suppose we could type it in ourself. The main reason you typically do stuff like this is because on different operating systems, you have different ways of, you know, creating the string for a path. And due to that, there will be some inconsistencies that you just hard coding it can't work. The thing that I was kind of curious on is why does entry not need that? I'm guessing it's a read write thing, but I don't know. So this is just the way that you do it is shut the server down, start it back up again. And we should see content not from webpack or from dist. Oh, that's actually because our server, we haven't changed that over yet. But I'm imagining it did compile our other stuff. Let's see. We should have a public now. Let's change dev server to well, actually, let's just run build. Maybe we'll say the content base is public now. npm run build. Here we go. So we've got public bundle JS, bundle JS map. And so yeah, you can see that working. So if you just need to change your name, for whatever reason, you can, you can totally just leave that off, though, if you don't, it's up to you. It depends on how complex your your setup is going to get, right. So I just wanted to show you that because you'll almost always see a webpack config with an entry and an output. And sometimes it's more complex, because you want to do chunking, or you want to do it into different things. But if you have a simple setup like this, you don't even need to put it, it's pretty sweet that it just comes without that, or comes with that setup, and you don't need that. So I think what we want to do now is make this sort of actually a production dev type scenario, because we really don't want this hard flag here for development, just hard coded right there, because we want to serve the minified assets to, you know, our actual users. So what we'll do to do that, is we'll say, hey, when you do start, I want you to do you know, webpack serve or whatever. But when we do build, we're going to we're going to set an environment variable, you can do this multiple ways. And we're going to set that to production. Okay. And so node env is a pretty common thing that would be used here. And then what we can do is we can create a variable and say const mode equals. And let's do something like process dot env dot node env, so that we can get any of our environment variables. And we're looking for the node environment variable, we'll say is that equal to production? Here's a ternary, well, then this is this variable will be set to production, otherwise, it will be set to development. And then here, we can actually change this and we don't want the string here, we want the variable to mode. And we could do the shorthand here, but we'll just keep it like this. So mode mode. All right. Now let's see if that actually worked. We go back to our terminal here, and we do npm run build. Now it should still start up in watch mode. But what we should see is that the main actually we changed that didn't we? We've got all sorts of nonsense going on here, you'd want to pick one or the other, obviously. But we now notice that bundle JS is bundled in a lovely way. And it's all minified and mangled and all that good stuff. So that's pretty sweet. Now, you could, obviously, you can use these variables to do other things too, like if for some reason you want a different output directories or all that type of stuff, you know, you can you can see kind of the customization that you can do here with with just this this idea. Now to test this out and make sure that we can still get you know, our dev files, what we would want to do is go to let's let's just say that we will make a little silly script here. That's like build dev, just for whatever reason. And we can do webpack dash watch. And then now if we go over to our terminal here, we'll do clear that npm run build dev. Okay, so it built everything, it's watching. And if we go to our bundle, you'll see that it's now in development mode. It's not minified, and it's got lots of fun things. And the thing that might kind of throw you off a little bit is that let's actually do this. If I do npm npm build, run build, sorry. And that will output my minified version. And then after that I do, you know, let's say I switched over to start because I wanted to serve, you might expect this serve because we're not passing the node environment production to it. Let me show you that for reference. This one right here, webpack serve, we're not passing this flag to it. So it should be in dev mode. And if we go and look at our bundle JS, you'll notice it's still minified, which is kind of confusing. But that's because in serve mode, it's actually not writing to that file. Like I said, it's keeping it in memory. So that's why that isn't changing over. But as you can see, the flag is working correctly. If for some reason we needed to build between dev and production, you could just leave it as production or take it off. All right. And with that, you're pretty much set with ES6 plus, you know, all the features, ES6, 7, 8, 9, whatever we're currently at when you watch this video. And I mean, it's funny to even call it ES6 plus because at this point, ES6 is so old. It's just like old timer logic. But there was a time when, you know, we couldn't use any of that stuff. And that's when Babel came and saved the day. So the thing that you should know that's very important with this setup right now is that this does not include proposed features. So you might see a new JavaScript feature that's being proposed currently. And if it's not in the, you know, the current stable versions that are out, then Babel is not going to transpile that until you opt into it specifically. I'm not going to show how to do that in this video, because that would make it run a little bit longer than the intended purpose, but just know that. And then there's one other thing that you need to know, and that's methods. This will confuse people quite a bit, is that you might think that you're automatically going to get method support for, I'll give you a quick example. So let's say if we were to console.log after this, we have an array that we just make on the fly, A, B, C, why do arrays always have three items? I don't know. It's weird for demo purposes. And let's say we want to do the dot includes method. Hey, do you include B? Well, this was ES7, if I recall correctly, and we will not get that transpiled. You might think that we would, but we will not by default from Babel. Why? Because it's a method. That's very important. That requires a polyfill. And to show you that, just that that's kind of not working, what I'm going to do is I'm going to switch back to dist being the main. So I'm going to delete this like public nonsense here. We're going to go back to our config and clean this up. And we're going to say, you know, I don't really care about these anymore. So we don't need an entry in an output. You know, some people might prefer to always have it, but for my purposes, we don't. And in fact, let's actually use start just so we've got our server running here. And if we go back to the browser, let's do this. Couldn't see it because it couldn't be reached. There we go. Okay. Cannot get root. Why? What's your deal, buddy? Do I just need to reload again? Oh, you know what? Ha ha. We got got here. That's because this was pointed out public. So now you know why you need that. So I'll leave that in. You do need to make sure this is pointing to the right direction, right content base. So now that's starting back up again. There we go. Beautiful. Okay. So you'll see that this was true. I should have put a string in front of it, but it came right after the object. So that's all there is to it. Now this might seem like you're good to go. This is a real gotcha. That's just because this is a modern browser and it does already support that. Okay. Now, if we were to go to our code of where this thing runs, I actually don't want source map in this instance. Let's just do a includes search, close this, see how the syntax is still here. Console log ABC and includes. It did not try to transpile that to an older one. And that's because by default, Babel is not going to do that for any methods that require polygons.\n\nThere's kind of a larger discussion about that, but the gist is that it would bloat up end result of your main.js significantly to just polyfill all of the methods. It's quite significant and you don't want that by default. A lot of people get tripped up on this because they think, oh, you know, preset env, I should just be good to go. Why is IE 11 failing when it tries to run this dot method? That's why. Now, if you're interested in getting those polyfills to work and seeing what you need to do to get all of your code transpiling for say IE 11, for instance, this is probably a good opportunity to subscribe and maybe check notifications because I'm going to be coming out with a video sometime relatively soon that will include a little more in-depth dive of all that transpiling goodness to kind of take a look at what you need to do to get all of your methods and everything working on older ones. We're going to talk about like browser lists and stuff like that. So you can kind of narrow down your focus and say, these are the browsers that my particular product needs to support. So if you're also interested in, let's say, React JSX, trying to get that going so that you've got, you know, your own kind of custom web pack setup that simulates a lot of the behavior of create React app, but you're going to want to, you know, add more customization. I'm also going to do a real quick build video of that in the near future. So same thing. If you're interested in that, subscribe and, you know, please give me any feedback if you liked or didn't like the pace of this video, if there was different information that you wanted, you know, leave a comment and I assure you I'll be listening. So I will see you on the next one.", "metadata": {"title": "Creating and Understanding a Basic Webpack 5 Setup", "url": "https://www.youtube.com/watch?v=X1nxTjVDYdQ"}}, {"page_content": "Hello and welcome to Swashbuckling with Code, I'm Jimmy Cleveland. In this video, we're going to cover the basics of publishing your first package, which includes publishing a scoped package. I'll have to assume that you already have Node installed and that you're familiar with the basics of installing packages, but that's really all you need to know to get going on this one. So I'm going to be showing creating a new NPM account so you can publish packages to it and just how easy it is to publish your first package and install it in a new project. Then I'm going to explain when and how you can unpublish a package, and I'll show that real quick. And then we'll switch over to using scoped packages so that we're not polluting the NPM registry namespace with a bunch of names that can never be used, just in case you're messing around and creating your own example packages for practice. I think it's a more polite thing to do. And now that you know what this video is about, let's publish a package. We're going to start by creating a really simple project that we can publish up to NPM and then install somewhere else so we can see this working in an action. So to do that, I'm going to create a directory. You can do that however you like. I'm going to use mkdir, and I'm going to just name it swashbuckling package example. I'm going to cd into that directory. At that point, I'll just open it with my code editor of preference vs code. It looks like it has to install an update. Great. So then in here, we're just going to create a file that's in index.js, you know, the basics of basics here, and I'm just going to console.log test package logs to console. Really, really simple just to make it do something here. We can go back to our terminal, and I can say node index.js just to run it in node and you can see that it logs to our console as expected. So after that, we probably want to make it a package. So I'm going to use npm init, and I'm not going to pass the dash y flag to say yes to everything this time because we actually do want to answer the questions here. So this is sort of a wizard to walk you through creating your package. So the package name will by default be the same as the directory that you made, which I'm going to go with. Then it's going to have the version here. Now I'm actually going to set my version to 0.1.0, which I'll explain in a moment. A description if you want to have one. Example package, please don't install. The entry point if you want to change it. So by default, it's going to be index.js. And that's why I created that file there in the root. We don't really care about a test command for this right now. And then a git repo. Not yet. Keywords is going to be useful if you want people to be able to search for it for specific things. So we could put, you know, example here if we wanted people to find it, or perhaps it's, you know, a React or Vue framework or Svelte or something like that. In this case, I don't want it to be found, so I'm not gonna put anything. And then the author be myself. I'll fill that in a moment. The license gets kind of tricky. It kind of depends on what you're doing. So I'm just going to leave it with default for now. We won't worry about it yet. So now we can confirm that everything looks fine. Yes, it does. Just press enter. Now, in order to actually publish this package, we're going to need an npm user for the registry for it to be assigned to. So I, of course, already have one. If you do npm who am I, it should print out who you are or if you're logged in. So this is my own, but I'm going to show you making a new one. So I'm going to npm log out, which if you want to see the list of commands, you can do npm dash dash help. And when you do that, it'll print out a bunch of stuff. Some of it's related to just installing packages and some of it's actually related to like your account. So we're going to be using publish pretty soon, but you can also see a login and a log out. And here's our who am I that we ran. So now when I run npm who am I, it will say this command needs you to be logged in. So that's what you're going to see if you didn't already have an account. So next, what we can do is we'll go over to the browser here and I already have npmjs.com open. You can just Google for it or go straight there. And this is where we need to create our account. So we can just do the sign up for free. There is an enterprise npm, but for most people, you're not going to be using that. And they're going to ask us to create some sort of username, which they'll identify us with, and then an email and a password. So mine's going to be crazy long. I'm gonna do swashbuckling with code. And then I'm gonna fill in my details and log in. And it's automatically going to redirect me to here. And I do believe you have to verify your email address before you can publish your first package. But let's test it and see. So now we can head back over to our terminal and try to log in as that user. So I'll do npm log in. It's going to prompt me for my username and then my password. Then it's going to ask for the email that I use for the account. And then it'll say I'm logged in. So if I do npm who am I, we're logged in. Before we publish the first package, I have to make a quick disclaimer here, you're probably going to want to hold off on publishing your own package and the steps that I'm about to do. Because it can actually be pretty difficult to remove a package from the npm repository. It's a nice thing that it's so easy and frictionless to actually get your own package up. But the problem is that once you push up a package, that name is reserved. So I would ask that if you are going to publish your own package, you try to pick a name that really no one's going to have like your username with package example, kind of like I've done. And I'm going to show how to unpublish that package. But if that package is used by someone else on the registry, you cannot unpublish it. And I haven't verified yet if you unpublish the package if someone else is able to reuse that name. I imagine they can, but I haven't confirmed that. Right after I show how to unpublish a package, I'm going to show how to make a scoped package. And that's a great time to follow along. A scoped package is going to let you tie package names to your username or your company name. And that'll make it to where you don't have to worry about taking up unscoped package names. I'll talk more on that when we get there. You of course can if you want to publish up your own package as you're following along. But I'm just recommending that as a courtesy to people because we could flood, you know, the market with a bunch of package names that then no one could ever use and don't ever get used. I might be overly cautious in this area. But now that I've explained that, let's move on with the video. So now that we have an account, it's pretty easy actually to publish. Let's try and see if we can yet. So you'll notice that we get this forbidden message here. And it's going to say, in most cases, you or one of your dependencies are requesting a package version that is forbidden by your security policy or on a server you do not have access to. So this is a pretty generic error here, unfortunately. So let's see if we verify the email, if that solves it for us. So in my inbox, I have this notification here, this email from NPM asking me to verify my email address. So I'm going to go ahead and do that. And then just do continue. And now we're verified. Let's see if we can publish now. And there you go. So I really wish that they would list that a little bit better. But it is in the documentation that you do have to verify in order to publish a package to the registry. So now if we go to our account here on the top right, you can click this profile or packages. If we go to packages, you'll see that our package is actually listed here. Swashbuckling package example. If I click on that package, sometimes that'll take a while if it's brand new. It'll take me over to what you would normally see when you look up a package here. And it's going to auto fill the readme if you have that in your project and a lot of that type of stuff. It'll even show the GitHub repo if it's over here. And it will tell you how to install", "metadata": {"title": "How to Create and Publish an NPM Package", "url": "https://www.youtube.com/watch?v=WRjJW8tseQg"}}, {"page_content": "over here. And it will tell you how to install it. So we can click this to copy it to our clipboard and see if we can install it in a new project. So now I'm going to open up a new tab. So in this new tab, I'm going to create a new directory as well. I'll cd into my vids directory to do that. And we're just going to name this something local like package consumer. We're not actually going to publish this one. cd into that as usual. And so I'm just going to start with an npm init. I'll just do dash y because I don't care about that in this case. And let's see if we can install that package. So I can actually paste from my clipboard here, this npm i that I copied from the site. And it says that we've installed the package. So let's open it up in code and see. Go to our package JSON. And you'll see that we have this one dependency installed since I didn't use any flags to install it. So we'll say this swashbuckling package example 01. Okay, and then let's really quickly use it. So I can create a new file index.js or whatever you like. So because I haven't made a function or anything like that, I can simply just import it here. So I'll say require and then it should auto complete for me. And let's just do that. And I go back to my terminal, I can run node index.js, and boom, logs to the console. So it's really that easy to publish a package. So overall, I think it's a pretty good thing how easy it is to publish up a package. And you can see the benefits of that with the massive ecosystem that is the npm registry, and how much JavaScript as a whole has evolved because of it. But there is some debate in the community on how frictionless it should be, you know, how much more authentication should we have and accountability and all that type of stuff. And then not to mention the problem of, you know, stealing names really easily and then never being able to use them. And there was a time where you could actually just easily remove your package from npm. But then there were a couple of incidents where packages were removed that tons and tons and tons of other packages and projects depended upon and it broke all of them. So now they make it a little more difficult to remove your package. And they don't even let you if it's installed in other packages on the registry as far as I know. So let's get back to that version thing. In our actual package project, we had this version set to 0.1.0. And I said I would explain that later. Well, it's later. So this right here, by default, it starts you as one. And that's pretty normal. This is semantic versioning, which I'll cover in a later video. But the idea here is that they want you to start on a major version, and I'm starting it on a minor. This is a common way of signaling that your package isn't ready to be used as like an everyday package, or that it's not stable yet. So when you're ready for it to be completely consumed by users, you would change this to one, which you can use with version flags. So now I'm going to show how to unpublish this package. And then we're going to use scoped packages, which, in my opinion, is a little bit more polite if you're just doing, you know, example throwaway packages. It's pretty good for testing. And I also use that in a lot of my package conventions. So let's get to that. So we go back to our terminal here, we can simply put npm on publish. Now we're going to get this error because you either have to pass a version that you want to unpublish, or you have to pass this dash dash force flag to unpublish the whole package. So when I do that, you can see it goes through successfully. If in this other project that I had over here, the package consumer, if I were to publish that up, and it was using that previous package that we were just on, it actually wouldn't let me unpublish it. I thought about showing that, but it kind of increases the length of the video. So you can take my word for it or look it up. So back to this. Now that we've unpublished it, do you think we can republish it again? Let's see. Oh, that's interesting, huh? This message is actually useful this time. It says cannot be republished until 24 hours have passed. So what we've created at this point is called an unscoped package. And there's two types of scoped packages, actually. There are public ones and private ones. And for private, you need an enterprise account. So we're just going to do the public one for now. So you can actually put the at symbol in front of it to make it a scope. And then you can put a slash for the package name. So this is saying that I'm going to have multiple packages under this at swashbuckling scope, most likely. And then this is the individual package name. And that's how people will install it with this name. So now let's try to publish this. So you're going to see that we get this payment required, which immediately kind of sends the wrong signal. And I wish they didn't do this. It is required if you're going to do an enterprise one. And what you're actually going to need to do is you're going to need to pass a flag for the first time that you publish this. So if you do npm publish, you can do dash dash access public, publish publish. Now that gets us further, but it says the scope is not found. So the point of this was to show that if you're not doing an organization level account, you're going to have to use your username for the package. So I did this at swashbuckling, but I actually need to put the full username here. So that's in this code base here. So we'll say at swashbuckling with code. It's very long. Now, if we run this exact same command again, it then publishes successfully. So now we can go back to our browser. And we have zero packages because we unpublished that old one. But if we refresh, we now have this scoped package. So now this is scoped to your user. So you can feel pretty confident that you can throw up as many as you want. And you're not going to be polluting, you know, npm with a bunch of names that can't ever be taken by anyone else. But again, these packages are public. So anyone could install them or look them up. Unless you're using an enterprise account, which you pay for in that case, then you can make a package private. That'll wrap up this video. I hope that that was useful. Because when I was first learning to do this, all of these errors were extremely not helpful, especially when I wanted to get into scope packages and stuff like that. So I hope that that clears some of that up. In the next video, we're going to go over versioning, what semantic versioning is, and how to increase the version of your packages whenever you make fixes and what's the right one to select. So until next time.", "metadata": {"title": "How to Create and Publish an NPM Package", "url": "https://www.youtube.com/watch?v=WRjJW8tseQg"}}, {"page_content": "Hello and welcome to Swashbuckling with Code. I'm Jimmy Cleveland and today I want to take you on a little tour of the Github CLI. In particular, I'm going to show you some practical commands that I've been using more and more to speed up my workflow. Many of you might not even know that there is a CLI tool for Github that you can use in your terminal, but many of you probably do know about it and you just haven't really dug into it or just didn't seem super practical to you or use it for a command here and there if you're anything like me. But recently I tasked myself with trying to dig into it a little bit more and incorporate it in my workflow. And I have to say that there's a few commands that I have a hard time living without now. So let's just jump into it, shall we? To get started with Github CLI you're gonna head over to CLI.github.com. I'll put a link in the description and I'm not gonna go through the setup for that. That's not what this video is for, but you can see they have a couple of commands that you can use to install it. Just know that you are gonna probably want to set up an auth token with SSH and go through that whole process of logging in, but it's pretty simple. CLI docs themselves are pretty hit-or-miss, honestly. They do have all the commands listed off on the side, but there's not a great search and sometimes some commands you would think are in one section or another. You have to click around a lot to figure them out and sometimes the output doesn't really show you what you can really do with the command, which I think is what's really missing. Some of them are great. Like I think the PR list one shows the output itself, which I really like just to kind of quickly see, oh, okay, when I input these commands, this is generally how they're used and what I'm gonna get back. But that's why I made this video. I'm gonna show you some practical commands. And then if you get interested in the GitHub CLI, you can dig into the manual itself and see if there's any commands that interest you. Now I'm gonna kick this off with one of my favorite commands that I think really showcases the power of the GitHub CLI and how much it can improve your workflow. And that is the gh repo create command. Now I'm using a snippet here in this clip to showcase the power of it and how fast but just with a few keystrokes, I can create a repo and I can set it to private and I could push it up immediately without having to do the clunky interface that you normally do where you go into the browser and you have to create a new repo and then you copy the lines that you need to do for, you know, a project that you've already started and been working on. But you're just like, okay, now it's a pretty good point to push this up. Super fast, super useful. This is one of the main commands that I like to use all the time. Now you can use the gh repo list command. I only use this just to see that my repo has been created so I don't have to go to the browser. I mean, I'll see that GitHub CLI demo at the top there. And if I don't really know what command to use, you can use help on any subsection or any argument of the gh-cli. So in this case, I'm kind of looking and I see, oh, well, there's an edit command. What does that do? Well, this is actually pretty cool because if I made a repo and let's say it's private and I wanted to switch it to public, I can just go gh repo edit and I can go down to the visibility and then I can just select public and it's done. That one's actually quite a few steps to do in the web UI. Now I told you I was going to show you how I created that snippet and I'm personally using Raycast on the Mac and you can see here. I've got a little snippet that's just gh rc shortcut. And what's cool about it is I have it move my cursor back to where it's supposed to put the name of the repo automatically when I type it in. You of course can use any shortcut tool you like, but in combination with snippets, this is a really powerful tool. Another common workflow for me that I use the GitHub CLI for is when I want to make a new branch and push up for a PR really quickly. So in this instance, like I'm creating a new commit real quick, I've just added a new feature or whatever and I want to make a PR really fast. I can simply type gh pr create and it'll ask me if I want to push up my branch if I haven't already. It then walks you through a little wizard each time, which is actually pretty useful because if you want to change the title or let's say that you want to create the PR as a draft, these are really useful little quick features you can do. You can also open it in the browser real quick if you just rather do it there. Just like that, you've got a PR created automatically. You can use the gh pr view command to look at the PR and see if any checks are running or just any information about the PR in general. I'll show you checks in a moment. But what's really cool then is you can use the gh pr edit to go back and edit your command so you don't have to go into the browser to do that either. In this case, I'm using it to add some reviewers to a PR that I've already created. And you'll see now when I use the gh pr view command, it shows those reviewers as part of the information for that pull request. Another handy pull request command is gh pr list and this lists out all of the pull requests for your project, which is super handy. There's also an alias gh pr ls for it. And once you've listed all those out, they all have the numbers so you can use gh pr view and then pass it a number to look at any pull requests, not just the one that's the branch that you're on. Now this next one is one of my favorites because it merges a bunch of really common commands into one and that's gh pr merge. And so what this will do is ask you how you want to merge the current branch that you're on and it will default into the the main branch that you're using. It will then prompt you if you want to delete the branch both locally and on GitHub, which keeps your repository nice and clean. And then it merges it in, it checks out the main branch for you, and then it also pulls down the main branch with the updates. So this is a common operation that I just always want to do is, you know, usually I go into the browser and I merge it and then in my terminal I go and I check out main and I pull down and it just does all these things in one nice little command and that's why it's one of my favorites. You can also use the pr merge command on branches that you don't have checked out. So if you do gh pr list or ls, you can list out all of the PRs and then you can just pick the number, so gh pr merge the number, and you can merge a different one if you like to. Now what's cool about this is it's not going to let you merge if there's conflicts or if the checks aren't completed or anything like that. So you don't have to worry about that problem. So let's say that I went to merge this PR and it wouldn't let me. And unfortunately, it doesn't give you that many details if you don't check it out. So I'll gh pr checkout the number, which is another handy little one. And then from there what I can do is I can run merge again on the branch that I'm on and it'll give me a little more information on what's wrong with it. It might be checks or it might have a conflict and it, in this case, it gives me actual command that I can use to run to pull down it locally and resolve those conflicts. So here I'm just demoing a common workflow for me that the GitHub CLI has sped up significantly. And you can see when I try to merge this again, I haven't pushed up my changes and it gives me some additional information that the branches have diverged. So that's pretty cool. And once your conflict is resolved, you push it up, you run the lovely merge command, and it does all the automation of checking out your main branch and pulling down and all that good stuff. And just to show you that I'm going to do a git log here. And you can see here that we have all the commits that we just recently did into the main branch. Another really handy command that's similar to pr list is the pr status command. What I like about this one is it kind of gives you the list of the PRs", "metadata": {"title": "Streamline your repo workflow with Github CLI", "url": "https://www.youtube.com/watch?v=in_H8MbiHpw"}}, {"page_content": "kind of gives you the list of the PRs that affect you. So it will show you the current branches PR that you're on. It will show you all PRs created by you, and it will show you any that are requesting a code review from you. I've only recently been incorporating this one in my workflow, but I have found it to be quite helpful and I'm starting to use it more and more. I don't typically just kind of run it over and over to see if there's anything waiting for me. My kind of workflow is that I have the GitHub app on my phone, and when I get a notification, I can just glance at it real quick. And instead of picking up my phone and looking at it at all, I just know that it's likely to be a PR and I can just tab over to the terminal, run that command real quick and see if there's anything waiting for me. The next thing I want to show with pull requests is how the CLI tool can be useful for workflows, like your tests, you know, Linton test or any continuous integration actions that you're running. So here I'm making a commit that's purposely going to fail our tests and creating a PR for that real quick, just to fire off that continuous integration. And I just kind of showcase here that you can also add a body real quick, and you can switch the CLI to use the editor of your choice. It starts off with nano, but you can use vim or emacs or whatever you like. But what happens when I submit this PR, which is still awesome and super fast, if I go to list it, if I list it too fast, it's not going to actually update with the workflows because it hasn't finished starting all that up just yet. So if you wait a moment, though, you can use gh PR views, the one that I normally use, and you can see that it says checks pending, you can also list out your workflows, but I haven't really found that to be super useful for me. Maybe y'all will find something cool. But I usually just stick to gh PR view. And where this is useful is mostly just multitasking. Like I can just fire that up. And I can be like, okay, the checks are pending. Let me go and do some additional work or whatever I was doing in another tab. And then I can come back and I can just check that real quick. And I'm like, Oh, no, all my checks are failing. And you can also see here if we use gh PR status, it will show our failing checks for branches that we might not even be on just any PR that we've created. So if you end up moving over to a new branch and working, that's a great command just to see like, oh, shoot, my other branch that I just created, it's failing. Gosh, darn it. Of course, once you fix that locally and push it up, all of your workflows will run again. And you could just use the gh PR view command again. And this time you should see that all of your workflow checks are passing. And as I mentioned previously, if you try to merge something that the status checks to workflow checks are not passing, well, then it will just not allow you to. So it of course does obey the rules of your repo. Another really handy set of commands from the CLI for me personally are the gist commands. This just actually makes just a lot more useful to me, because I can just create them on the fly. In this case, I'm just kind of showing that I can point it to a file that I just want to upload because I'm like, oh, this is a good example of how to do a thing that I'll probably forget how to do in the near future. And just with this command, you can hurry up and create a gist. You can also use gh gist list to list out all of your gists, gist list. And then that allows you to run the gh gist view command with an ID of the gist. There might be a more handy way to do it, but that's just usually how I do it. Now it will print that gist out into your terminal. So you can do some fun stuff from there, like pipe it into some sort of syntax highlighter. In this case, I'm just using NPX because I don't have it locally installed just to show the power of it that you can do just on the fly. But what it's really handy for for me is actually sending it into a file. Now this is of course on Nix based systems. You'd have to figure out how to do it on Windows, but I can just, you know, since it's downloading that and printing it out into the terminal, I can just send it into a file. And the only problem that I have with that is that it also kind of prints the description into the file. So I just have to go in and delete that description real quick. Another handy way to do this is the gist clone command. And the one thing that I don't like about this command is that it makes you create a directory, which is just kind of weird. I usually don't want that. I just want to put all the files in one thing, but I haven't figured out how to do that yet. But it's still really nice. It doesn't have that previous problem of, you know, inputting the description into the file. And if you have, you know, multiple files that you want to dump in just one relegated area, well, it works pretty well. You can of course pick the flavor that you like. Now I'm going to round this video off with a command that is actually not that practical, not one that I use very often, but it shows some of the power if you're kind of an automation nut or you are putting together some programs that are using the GitHub CLI under the hood. So you can use the gh search repos command and you can pass it tags or names or anything like that, that you want to do to search for certain types of repos. Now, in this case, I'm showing there's this AWS shell repo that I found at the top of the list here. Now that's a pretty simple command. It's not that useful. In general, you can use a repo view to take a look at that repo and it will show you the readme, which sometimes is really nice. If you're just looking for a command real quick, I could see some practical use for that. But what's really cool is that you can actually take the output and turn it into JSON and you can use a comma separated list to pick the properties that you want to put in JSON. So in this case, I want to know the watchers. I want to know the created at date. I want to know the updated at date, et cetera. And maybe I'm going to do some sorting or something like that. Again, not something I'm trying to pass off as super practical that you're going to use. I just think it's pretty cool to see that there is a lot of power and probably some really neat things that you can do with this command line. That's all I've got for you today. Hopefully this has interested you in taking a further look at the GitHub CLI and seeing if it's useful in your workflow. Maybe it is, maybe it's not. Go ahead and tell me in the comments if you've got any cool little tips that you like to use it for. But with that, thanks for watching and I hope to see you in the next one.", "metadata": {"title": "Streamline your repo workflow with Github CLI", "url": "https://www.youtube.com/watch?v=in_H8MbiHpw"}}, {"page_content": "Hello and welcome to Swashbuckling with code. I'm Jimmy Cleveland. We're going to be covering mocking asynchronous functions with Jest in this video. So mocking is a fundamental skill in testing for those of you who aren't familiar with it, and in this case it means to imitate and not to insult. So what mocking does is it allows you to avoid testing parts of your code that are outside of your control or to get reliable return values for that code. And one of the situations that's really desirable for mocking is an API request such as with Axios. And so that's what we're going to cover in this video. Now I have an accompanying blog post that I wrote some time back that you can use for a reference material if you'd rather read that than watch the video if that's your flavor, or if you just want to look at it afterward. It's on blog.jpdsa.com which I'll link in the description in case you want to check that out. But let's get to some mocking. Now let's start out with a brief overview of the project just so you know what's going on in it. I've just thrown together with a npm init really quickly, and then we have a test script that's just going to run Jest, and you'll notice that there's this Jest key here. That's a way that you can make a setup file, and I'll show you that in a moment. That's just for regenerator runtime for me so that I can use a sync await. And then we have Axios and Jest, and Axios is one of the things that we're going to be mocking to show that. Obviously we have Jest, and then we're going to have our Babel core, presetenv, and then that regenerator runtime. Okay? Now, what you're going to want to take a look at real quick is this setup test to show that it just has this import regenerator runtime. That's just a way that you can add like any sort of functionality that you want Jest to pick up, and I'd probably do this a little bit differently in a full project, but this is a pretty lean one just for an example so that you can see that. We have this Babel file that just has presetenv just so you know nothing's crazy is going on there, and that's pretty much it. The index we don't even need to really look at. So we have this swappy getter, which is what we're looking to test here, and I'm going to be doing this side by side here so that you can see the test running the entire time. So it'll be a little bit squished. Sorry about that, but you know we'll make do. I think it'll be okay. So we have this swappy getter, and what its functionality is is that it's going to import Axios, and then it'll export this function swappy getter, and it's going to hit the swappy API, the Star Wars API, if you're not familiar with it. You can use it. It's pretty cool. Here's the URL here, and you know I'll probably link it in the description just in case you haven't seen it, but it's a really nice little public API that lets you just kind of test out, you know, hitting things and getting data back. So in this case, we're going to look for people by ID that you pass in. We're going to return. I happen to know that it's res.data.name when it comes back, so I'm just trying to get back the name. It's a really simple contrived example, but I think it'll serve us for what we need. So the first thing we're going to want to do is, I guess, show that if I run npm run test, you'll see that we get this no test found, and you can actually do npm t for that just so that you know, and then you can also use a dash dash to pass on additional arguments, and then we're going to do dash dash watch in this instance. And so what that will do is start up our just watch command. You could, a lot of people will do this, make it so that your just just automatically starts out in watch mode. But typically I run this in CI and I use the same command, so I'm used to just passing the watch flag. So that's how I do it. You know, you do you, you do how you like. So what we're going to do is we're going to add a new file, and I'm going to do swappygetter.test.js. That will immediately update. It's pretty cool. And it'll tell you that you got to have at least one test. So, okay, let's start out here. I like to do mine with the describe block. I know some people aren't really a fan of the describe block anymore, but, you know, I still like it. I think it's cool to kind of group things, but if someone has pretty good arguments against it, I'd like to hear it. So then we're going to run this. I'm just using a little snippet library I have here, and I actually probably should enlarge that so you can see that. And then we're going to say should return a name. And so that's going to be our test. And then now we'll have our first test that doesn't do anything, and it's just, you know, successful, right? Nothing crazy. And then what we'll do is we'll import swappygetter from that directory, swappygetter. Now, because I'm just using Babel, I have to add the JS extension. You might be used to not having to do that just so you know. And stop formatting that. And then what I want here is I want to say const result equals and then we're going to call that function swappygetter. And then let's just log the results so that we can keep track of that so you can see what's going on. And then I'm going to say expect is a pretty standard test. Expect the result. We'll say to be, and then I'll just type the name in here. So in this case, it'd be like Luke Skywalker because it's number one. And you'll see what we get here on the left. Isn't this watch mode cool? It's just kind of like live updating as we test it. So we're getting this received an empty object. And that is because our swappygetter, just to take a look at that code again, it's returning this axios.get with a then returning it. So we're essentially getting a promise back, but we're not utilizing that yet. We're just trying to call it. Now, I know this is pretty obvious to most people, but I do see quite a lot when people are getting into mocks, especially for async stuff, like when I've been looking up stack overflow and stuff, I see often people thinking that their mock is not working right because they'll see received undefined here or they'll see just an empty object or something like that. And I just wanted to point out that that is what you're going to get if you're not even doing the prompts correctly in the first place. So maybe look for that if you ever run into that situation. Okay. Now I realize we're not even calling our function correctly here, right? It takes a number. So we might as well just pass that and say, yeah, it's still the same. It's still the same problem. Now you could use promise chaining here. In testing, I really prefer async await. I'm usually kind of 50-50 on either, but in testing, it's just a lot easier, in my experience, to use async await. So that's what we're going to do. And that's why, if you recall, well, let's actually look at that real quick. You'll see that this test passed now. Pretty neat, huh? And then save with, you know, make sure that it actually fails. And it does. It'll say expected Luke Skywalker. And now I've got Luke Skywalker. So what I was just saying was that remember in my setup tests, I have this, oops, I've got this regenerator runtime, and that's why I can use async await here in this case. I just want to point that out. So, you know, a lot of situations you'll be able to do that in your project already, but that's why and how I have mine set up. So, okay, cool. You know, we have an asynchronous test working here, but, you know, there's kind of an issue here that I want to talk about before I show you the mocking, and that's kind of the why of it. The issue here is that I'm actually hitting an API. So this is supposed to be a unit test for me. Obviously, it's a contrived example. You know, you'd probably have something doing something, and then, you know, the API you're hitting is just a side effect of that. That happens to go into it. But what I'm really trying to do is I'm trying to test this unit, not this integration. And where the problem commonly arises is that let's say the API is down for one, and now my tests fail, but my code is actually still working properly. The API just happens to be down. Or what if the API changes out from under me? You know, and I get different results back, and then I get false positives, and I think someone committed some different code that kind of messed my unit test up. It's not just a temporary blip in the API or an update or something like that. So these are some of the few reasons to get into mocks because really what you want to do is you want to test your code in isolation so that, you know, you're not relying on any sort of side effects here. So let me kind of show you what that looks like. So I can do a jest.mock, and since I'm in a test file, I can just call jest here. It'll be in the environment when the test is running. And I can actually just type axios. And you'll see that that fails, but what it says is cannot read property then of undefined. So what happens when you do jest.mock so that you know is there's actually a thing called jest.fn where you can create a mock function. It's a pretend function, but it has some additional functionality from, as a lot of saying function, it has a lot of functionality from jest that's allowing that. Let me show this real quick. If I go to SwappyGetter, I can log. This is when my test works. I can log axios. And you'll see that I have to scroll up a little bit here, but when it does it, you'll see it has this request, getUri, delete, get, there's our get method and all that stuff. So it's the actual function. But check this out. When I do jest.mock, it's kind of interesting, huh? You get this big long one. Wow, it goes far. It goes all the way up here, and you can see this isMock function is true, and then it has a bunch of methods on it. mockResolveValue, onceMockReturnValue. We're actually going to use a couple of these in a moment. So this is pretty neat. And if you're a little bit newer to this, this might kind of be weird to follow, but what's happening here is", "metadata": {"title": "Mocking Asynchronous Functions with Jest", "url": "https://www.youtube.com/watch?v=gA-uNj2FgdM"}}, {"page_content": "our await is, or our test here, the await is calling SwappyGetter. Now, when we call that, it actually calls this code here, and so we are running through all of this code, and so I'm logging out Axios, but because I import Axios in that module, this is swapping it out here. That's what this jest.mock does. It's going to say, hey, any time, this is the way I think about it, I don't know if it's 100% accurate, but it kind of gets my head around the weirdness of it. It's like, if you were ever going to import the Axios function, what I'm going to do is I'm going to give you a pretend version of that. So when this gets imported, it's actually our little jest.mock function, and that's why when we log that out, that's how it works. And it's a way that you can just kind of do a sanity check to make sure that things are working how you expect. Okay, so for now, we're not going to need that. Maybe I'll leave it just in case we do. We'll go back to actually fixing this. Now, the other thing that you might want to know is that this is a package that we've installed. So the jest.mock, you can pretend that it's like an import statement, because if you happen to want to mock an actual file or local code that you have, you could just do it like this. But in our case, we just want to mock this package. Okay, so now there's a couple ways to proceed. I'll show you a different one after I show you this first one. I kind of preferred this one in this case, but you know, it's good to know a few of them. So I'll show you a couple. But what you can do here is you can import and I like to start it with the name mock. And I'm going to call it mockaxios from you actually import it from axios. It's kind of weird. So what this is going to do is it's going to allow you to have access to your mock. This here is still going to to mock it for you know, the whole run of the test. But this gives you access to it. So you can do something like mock axios here. And then from that point on, you can chain onto it and say, Okay, I want the dot get method to mock implementation. This is one way to do this. I'll show you a shorter one after this. And the mock implementation takes a function. And that function itself. In this case, we're just going to promise dot resolve running out of room. So this promise dot resolve, what we're saying is, what I want you to do is pretend that the get method on our axios that we're mocking returns this. That's what it does. Okay, so now, it says swappy getter should return a name. That's the test. Notice we're getting undefined. And that's a good step in the right direction. Because what we're doing here is we're just returning promise dot resolve with nothing, essentially. Alright, so let's actually mock that data. Now we know if we go back to the function, that there is this res dot data dot name is what we want to get back after we call our get method. So let's just pretend that we have that let's just make an object up and return it. And say this is data. And that's an object and that has name. And then from that point on, let's just do let's get it passing first, Skywalker. And now we get some formatting. And you will see that our test pass and where we log the result right here. It's actually logging it out correctly. So let me show you this. It's kind of neat. So I'm going to do mock, you know, Jedi or something fun. I like to name it a pretend value when I'm testing it out just so that I know that it's not a real one. And that's also it just came to me. Another good reason to be mocking something because every single time that you run your test suite, you don't probably don't want to be hitting their API, you'd want to do that and integration test suite, which you probably run a little bit less often. At least in my case, it is. Okay, so we can see coming back to it that the test properly fails when we don't get what we want. So let's actually change this to say, mock Jedi. And now it's passing. Now what's cool about this, and this is why I like to do the import, you know, mock axios from axios thing that we're doing here is because you can actually do something sweet like this where you say, hey, I that mock axios dot get method, I want to expect that to have been called, we'll start with this one. Okay, so it looks like it passes, right? And then let's see times just so you can see it not working there. Let's do two to make it fail. Come back up here. expected number of calls to receive one. That's pretty neat, huh? So we're essentially the mocks themselves. They keep a store of data on them. And it one of the things that is keeping track of us, how many times has it been called with this test suite here. And so within this block, we're calling it one time. Now it's preferred in from everything I've searched up, and this is how I do it to use to have been called times instead of just to have been called, there's nothing wrong with to have been called, it's just cool to know that you know, your your function got called. But times not only says that the function get called, but it also makes sure that only got called once, because what if we accidentally called it multiple times? Well, we definitely don't want that. So that's just a good little safety check that you can add on there. And importing that mock axios allows you to do that really easily. And I like that. Now, because this is such a common thing, you can actually shorthand this is really cool. mock implementation, you can do mock, oops, it's lowercase mock resolved value, you can get rid of this whole function here and this promise resolve that we're doing. And we can just return, let's actually do it here. And then we'll get rid of this one. This is so hard to see here. Actually, we want this. There we go. So what we're doing here, just formatted this to make it a little bit easier to read for a moment, we're saying mock axios dot get dot mock resolved value. And then we just turn whatever we want. So that's just a little bit of a shorthand for that way that we previously had it. And it's a little nicer if you do it a bunch instead of having to write a whole promise and return that just so you know. Now you could end right here and think that you've got this all solved and beautiful, but you've actually left the bomb for yourself or someone else maintaining your code base in the future. Let me show you that. So I'm going to copy this test. So we have two tests running. And you gotta can't have a duplicate name. So I'll just say duplicate test just to show that we're going to run the test twice and check this out. We fail because we received number of calls to so the first test passed. But then it says the second test had two calls in it. All right. And that's because we're still keeping track of that state of how many times it gets called. It's throughout this whole suite running here. And so if we were to say, you know, set that to two, that would make it pass. But that's not obviously what we want. If we want to test it multiple times, we want to make sure it only gets called one time each time. So there's this cool little method, you can go up here. And there's an after each and a before each that you can call here. And it kind of depends on your situation, which one you're using. Most of the time, I just stick to one, but there are occasions where you might want to do it before every test or after every test. And that's what it's going to do. So you can give it a callback function here and tell it, you know, things you want to do before each test, you can use this to do just about whatever you want, you can set up some like local variables or objects or anything like that that you'd like. But what we're going to do here is there is a method that we want to pass. That's just dot clear all mocks. So in this case, now my test will pass, I can get rid of this log. So needed. So I'll clean it up a little bit. And now my test will pass even though I'm running the same one, because what we're doing is the mock data, we're clearing that after each test runs. Okay, so I'm gonna get rid of this one. Now, we don't need that anymore. But you should leave this here. Because some unsuspecting person will come in and they'll add a test and then they'll have a huge headache if you don't have something like this. So it's just a good thing to know. Now earlier, I told you that I was going to show you a different way to do this. And so let's do that right now. The way that you can mock this, so you can actually pass a callback here. And so what this will be is I'm just returning an object, go away. So I'm returning an object here. And I want to say that whenever you mock this, this is what I want you to return for the module. So then you, in this case, you might think that you want a get method, but you actually import the default export here, and then you call get from that. So what we want to do is say, okay, we then must have a default, that's how you do it, object, and then we do get. And then we're going to do that same thing. But we can just create a just dot fn, like just to create it on the fly here, might be a different way to do this is just how I've done it before. And then we're going to do mock resolve value, just like we did before. And then we'll update data, and then we'll do name. And then for the name, we'll obviously do mock Jedi and see if it passes. Okay, so you can see that it says axios default dot get is not a function. Now, the reason that this happens, this is a really confusing one to get stuck on, is actually we are using es module imports. And so we need to do underscore underscore two underscores es module.\n\nAnd so you can actually do named methods without that, or if you're just using require syntax, you don't need that. But in this case, because we're using es module imports and exports, and we want to use the default here, we need that. Now, I go back and forth between which way I like, you know, this is kind of nice to have it all encapsulated here. And then you don't even need to import this one if you don't use it for any of the other, you know, have been called methods or anything like that. So it's up to you, whichever you prefer. This other way is a little bit cleaner to me. And so I just kind of lean toward it, but it's your preference. You do how you like. There's also the option of globally mocking this, which I won't get into in this video. That's another way to do it. You know, if you're using axios all over, and you wanted to mock it, so that always returns the same thing. That's also an option. So you can check that out in the docs. But for here, I think that we have achieved the purpose of this video. And hopefully you have a bit a little bit better idea about mocking and how to mock asynchronous functions, in particular, the axios package in this case. And so wrapping up, I'll leave a blog post link to the one that I mentioned previously, the accompanying blog post for this, if you want to just review it quickly or you ever need to check up. It's a little bit older, so the material isn't exactly the same, but it's pretty dang close. And it's nice to just have a quick little syntax review every now and then, just in case you do. So thanks for watching the video, and I hope to see you in the next one.", "metadata": {"title": "Mocking Asynchronous Functions with Jest", "url": "https://www.youtube.com/watch?v=gA-uNj2FgdM"}}, {"page_content": "Welcome to another Swashbuckling with Code. I'm Jimmy Cleveland, and today we're going to go over Jest and its test coverage functionality, and we're going to use these coverage reports to sort of clue us into what we should be testing next and how much confidence do we have in our codebase. As you'll see throughout this video, I'm a big fan of coverage reports, and in particular using it in a sort of continuous integration fashion through your GitHub Actions or your Bitbucket Pipelines or whatnot. I'm going to be showing a little bit of that toward the end just so you can see the sort of cool functionality of it, but for the rest of it, what we're going to go over is how to use a coverage report, how to configure it to let you know how many files in your project are lacking coverage based on your specifications of what you want to cover, and we'll also configure some thresholds for what we consider to be sufficient for not only, you know, global coverage of the whole project itself, but maybe individual files or folders that need a little bit higher or a little bit lower coverage. I think to understand it better than that, it's easier just to see it in action, so let's start. So I've gone ahead and created this example repo to speed things up, and let me take you for a spin of it so you kind of know what's going on here. First thing you're going to want to see is that we have these scripts, and these scripts are going to say test, test watch, and test CI. So this is just your standard Jest run. This is going to be a Jest with watch just because I don't want to pass the additional flags every time, and the CI one in particular is going to be for our continuous integration, which is pretty standard, and that's going to be delved into a little bit later with GitHub actions. The only other thing you really need to know in this file is that we have Jest installed as a dev dependency. These are the only dependencies we have at all, any packages, and this at types Jest. If you're wondering why that's there, that's typically because if you're not getting auto completion and VS code for all of your Jest statements like expect and stuff like that, if you install the types for it, then you typically will. Now the next step is going to be the source folder, and we have various different things. We have a utils folder with a few things, and then at the root we have just this generate item, and we already have a single test written for it. Now each of these methods I'm going to go into, or I should say files, I'm going to go into and look at all of the different functions in them as we need to. But for just a start, what we are starting with is this silly example I've created of a generate item that I put just a bunch of conditional checks for demo purposes. And so you're going to call it, and it's going to give you back an object of like a base weapon or a base armor with some random generated stats. It's probably not the greatest example in the world, but you'd be surprised at how long it takes to come up with a decent example that is, you know, a good balance between contrived so that it is understandable, you know, but kind of not really realistic. But if it's too realistic, then it takes too long to get into and really understand all of it. So I think that this strikes a pretty good balance, hopefully. So just bear with me. So at this point, I'm going to hop back over to the terminal here, and I'm going to run npm t for just a shorthand for running the test command. And you can see that all our tests pass. Now the scenarios that I want you to imagine here as we're going through this code is that you're either a person who just wrote this, and you're kind of wondering, what should I test next? Or let's say that you are a maintainer or a co developer or someone else on a team that peer reviews this code. And you're trying to kind of figure out what's the stability of it, or maybe you're wanting to either refactor or fix some of the code. And you want to know what parts you can remove. And a really good first step to that is writing tests for those things. And I think that coverage really comes in fantastically here, because it's going to give you a good idea of what all of the code that is in the code base is actually covered by tests. Now I have some notes on what covered actually means, but I think it'd be better for me to just kind of show you what it looks like first, and then we can talk to that aspect. So what we can do is we can take our npm t command or test, and then we can use the dash dash to pass another flag to it. And then we can say dash dash coverage. And there you'll see that we'll get our first very interesting coverage report, which is nicely printed out in the terminal. So that's the usage of the dash dash coverage property. And if you're on yarn, you could actually just do yarn test dash dash coverage, you don't have to pass the additional dash dash just so you know. And of course, you could also make a script that does that for you. Now at a quick glance, we get some pretty good information here, we can see that it says that source utils is completely covered. The helper JS is the one that it's tested in there. And we'll come back to that in a moment. But the statements, branches, functions, and lines are 100% covered. So you know, statements are any individual statement of code lines, it the lines are going to be a little bit different than statements sometimes, but usually they kind of line up functions, obviously, is pretty obvious, I think, and then branches are just conditional logic, you know, such as ternaries, or if statements or switch statements or anything like that. It's even nice because it shows you the covered line numbers, in case you just want to zip right over to those. But you can see in the rest of our stuff, this, this all files is telling us this is like global coverage, this is what it considers our entire code base that's tested. And it's telling us that, you know, only 35% of our branches are covered, which it's giving the red color to kind of alert you to that. And then, you know, we're getting into the warning state for some of this other stuff. If we go in individually to generate item, you can see this is pretty feature paired up with that. And that so that's a pretty good indicator that this is largely affecting that. So let's go look at the generate item test real quick. So if we go into here, we'll see that we have a test right now. And it pulls in generate item. And then from there, what it does is we have a should create a weapon object test, we have an expected weapon. And this is just a pretty normal, like, here's kind of a generic shape. I let's kind of go through the test, actually. So we expect that weapon, which is going to be the result of calling generate item with the config of type weapon and the rarity epic, we want that to match an object. And there's various different ways to do that. Don't worry about that for the purpose of this video. But we're going to say, okay, I want it to match this expected weapon object. And so it should come back with a type weapon and a rarity epic, which is what we passed in. But it also should have at least a damage and a damage type. And that can be any number or any string. And that's because those are going to be randomly generated. So we can't 100% predict that at this point. If you want to see just really quickly kind of what that looks like, let's do a console dot log of weapon, what that comes back as, I'll come over to here, and we'll just run npm t once. And here you can see this is generally what it comes back. So it's going to say the type is weapon, the damage is piercing damage 19 attack speed zero, as that's not written in yet. And then rarity is epic. So we're kind of in the middle of building this thing, you can think of it that way. So at this point, whether you've written the code yourself, and you're coming back to it a later date, or you're doing it now, or like I said, you're a maintainer, you're kind of wondering, all right, what should I test next? Okay, so what you could do is you could obviously go into your generate item. And if you just wrote this code, you'd probably be able to guess that. Well, we generate out a sort of a weapon and an armor. So we probably need to test armor, right? But if you're a maintainer, or you've come back to it from a little bit in the future, it might be a little bit of like mental downloading to kind of get in here and look at all this", "metadata": {"title": "Reveal testing weakspots in your JavaScript code with Jest Coverage", "url": "https://www.youtube.com/watch?v=fQpvuRVDp-8"}}, {"page_content": "kind of get in here and look at all this code and all these functions and be like, Okay, yeah, there's a lot of stuff going on here. And okay, now I start to kind of get you know, what's going on. But you can kind of forego all of that. This is what I really like about coverage is with our coverage report. Let's do this. So if you go to the coverage folder, which has been generated for you, when you run the dash dash coverage flag, you can look into this l curve report. And there's going to be an index HTML. Now I'm just going to like reveal this and Explorer as a way to open it. Move that over here. So you can see that. And then I'm just going to open this file, just that simple. And what's cool is from this point on, I can then reload this anytime I rewrote my code. I wish there was a dark mode for this is blinding me. So we can see that it gives us this nice little diagram sheet. And you can see that source utils is 100% covered. Let's actually just take a quick peek into that. So if you go into source utils, we can see helper j s, everything's covered, everything's green and beautiful. And if we look at it, it tells us, oh, this is interesting, like this ran 21 times, somehow, and then 111, and then two x for this module that exports. Okay, so let's take a look. Why is that? Well, if we go back over to our utils, we have a test for helpers test. And you can see that what it's doing, because it's a randomly generated thing, we are looping over it this 20 ish times in this case, 21. And we're going to go and call it and we're going to get a random int of three, and we expect that to be greater than or equal to zero. So we know that it's going to start at zero, and then it should be less than three. This is a really nice thing that I like about tests just in general is they can kind of be a sort of documentation. If you're getting into a project or reviewing code, because this tells me immediately like, what the qualifications of this function are. In this case, I know that it is exclusive in the upper bound, which means that it needs to be less than three, even though we passed in three. And I know that it probably starts at and is inclusive at zero. So of course, I could figure that out from the code. But it's nice to get a little bit of confirmation. And this test pass after running at 20 or so times. So I've got a reasonable amount of confidence, you could run that as many times as you like. But that's the gist. So back to our report here. Let's now we can see why that lets you know that that test is running out that many times. Let's go back a bit here and look in our trouble area. So if we go to this generate item, we know that we've got some problems here. There's clearly some colors that we don't like typically. And when we're digging into this code, I've got this zoomed in a little bit for you. Normally, it'd be a lot smaller. Let me show you actually, it's like that small. I'll bump this up a tiny bit, or a large bit. And as we're looking through, this is actually the code that's being tested by that test file that we ran. And we only had that one test. But you can see it actually covered quite a bit of the code base. And what's covered is just basically the non highlighted sections, you can think of it that way. So it's run through and ran each of these, these one times. And this is where we first want to start whenever you see this little flag. This is an else path not taken. I know that's really tiny, it doesn't zoom that in for you. And what this is trying to tell us is that we know when you run this if condition, you know, some of these else's are not even run. So you're not really testing the full extent of this generate stat function that's in that file. You're only really testing for an epic rarity here. And it does this nice job of also highlighting that here for you. So statement not covered when you hover over that. And yeah, so that's a that's a pretty good just quick flag to say, all right, well, I know now that our tests don't even cover these examples. So I'm not feeling very confident that this function works to the full extent. Let's keep going down, though. So now we can see that this one generate base armor isn't covered at all, we hover over it, it says function not covered. So that's the functions part of the equation of the stats that come back to us. And it's just going to highlight that return just to show Yeah, you know, even though of course, the function wasn't covered, the statement wasn't covered either. Coming down here, this is a really nice one to get this if path not taken. So this is a sort of short circuit type of command to say like, hey, if you call generate item, and you didn't pass in a type, you know, in this case, they're just going to return null, maybe they return an error, or maybe they turn return, whatever, this is a condition that we really want to test, we don't only want to test what's known as like the happy path of, you know, the path to success of a function, we also want to test the ways in which the user might use it incorrectly. And how do we cover that? Do we fail gracefully? Do we throw an error like we intend? And so this is good to, you know, be notified that like, you know, you're, you're not even covering that either, you don't even run a test. This is kind of getting into the meaning of covered. And I'll finish it after I look at this quick line right here. This is just saying, same thing else path not taken, we can see that we do check base type item is a weapon. And then you know, that's successful, because we're generating on a weapon. And it runs this line of code, but we don't run this else, which is very clearly at this point for armor. So this sort of leads me into what does covered mean? Because it's very important, once you're getting into coverage, you can see the benefits right away, I think, as you start to dig into it. But what does it actually really mean? Well, it just means that when they say covered, it means that that code was run in a test. It doesn't mean that you've covered every possible scenario, that you have all of the functionality sufficiently covered, I guess is a better way to word that. So it doesn't really mean that your tests are even good. It just means that the code was run, it's kind of a bare minimum to say, is this even in a test? Does a test even run this code? And because you would get an error in some situations. And you know, if you've never run that in a test, then the test isn't going to fail on a simple error. So that's kind of like the bare minimum version of a test is does the code run and not throw an error? Unpredictably, I should say. Why this is important to get into early on is because I think coverage is a super powerful tool. I'm obviously doing a video about it for that reason. But it's also easy to get in the trap of saying, oh, I'm 100% covered, you know, I must be good. But that's not really true. That's like a starting point. That's a really good, you know, goal to get to a really high coverage percentage doesn't have to be 100. It depends on your code base. And you know what the other developers think. But it's just a really good way to start off and say, okay, now my test runs on all of the different code. And now what do I do to make this even more bulletproof? I'll be touching on that here and there as we go through it to kind of elaborate on that definition. But I think you've got enough of that earful. Okay, so now we, as the developers can come in here and oh, I forgot to actually mention, you know, this is a really nice way to show, hey, you know, when we run this, more clues that we need to run armor is that there's this yellow highlight here, this is a conditional highlight. And it says branch not covered. That's how you'll know for conditional logic, that one of the options has not been covered. So the code comes in here, and it runs this type equal to weapon, and it's true. And so it runs this function, but we never run it when it's false. Same thing here. You know, we say, oh, hey, do you have rarity? If you don't, then use common. So we can see that we always pass in a rarity property when we're calling it. So now we can take a stab at what we need to run next. So let's go over and kind of update one of our tests.", "metadata": {"title": "Reveal testing weakspots in your JavaScript code with Jest Coverage", "url": "https://www.youtube.com/watch?v=fQpvuRVDp-8"}}, {"page_content": "So if we go over to the generate item test here, we don't really need this log right here for now. I'm gonna make a new test. And so this will say should create armor object. You know, since we haven't covered that at all. And then in here, I'm just gonna show you that you can actually just run the code. You don't even really have to have a test to get coverage, which is a good and a bad thing, I guess. So we're gonna generate item. And from here, we're gonna do type and we'll set that equal to armor. And then what I'm gonna do is I'm going to set the rarity equal to... Let's do rare. Save that. Go away. Now, let's run test with coverage one more time. Oh, that was just test, huh? test dash dash dash dash coverage. We'll add that into our script pretty soon. Well, you can see our numbers got a lot better there. Okay? So let's go back over to our browser and we're refresh. Now check this out. I'm gonna refresh kind of like, let's say like down here. Let's see what happens. Boom, look at all that. All of that cleared. So just by calling that function, we have run our code in a test against all of this other functionality. We can still see that we have some weak points. We didn't check the don't pass in something. What happens? We got to this interesting branch where we always get zero here. I guess we'll kind of come back to that. And then we come up here and it looks like we ran most of this code too. And notice that some of these are being run two times now because we have these two different tests. And so they're always kind of this is kind of like showing you, hey, what path is traversed most through your tests? And you can see this kind of makes sense. We generated a rarity epic item and we generated a rarity rare item, rarity rare. And then we did not do the else, which is actually a common. That's the fallback. And that's why when we go down here, you know, we don't have this test today either. Now this is kind of one, this is really cool, but it's also to really emphasize that gotcha here of coverage that notice that I just ran the test. I just ran this code. I didn't even do an expector or anything like that. So it's a test that the code, you know, completes successfully and doesn't have an error when you pass it in an armor type. But it doesn't really test that anything useful comes back, right? So let's quickly do that. You know, we'll just copy this and I'll go back up to here and I'm going to copy this expected object as well. And obviously this is not for, you know, learning how to test every single thing here. We're just going over coverage. So we're going to make it path of least resistance. So let's say we got an armor and we expect that to come back as a rare. Let's actually leave that epic so we could see it fail. And then this case, it wouldn't have damage. So we could go over to our report here and be like, okay, what does it give us back? We could look at the code too, of course. Generate base armor. It looks like it gives us back defense and an armor type. So let's say defense and that's going to be a number, an armor type. And that's going to be any string. And if you're curious, that's just right up here. You can see what it does is it goes to this sort of const type where we're going to be picking from one of these things randomly when we generate it out. Not super important. Just if you're curious to follow along, don't worry about that too much. So now this expected weapon, we're going to change this to expected armor. And then generate item armor, blah, blah, blah, blah, blah. Oh, this right here. We don't want to pass in weapon. We want to pass in, we need to store this. Armor equals armor. And there we go. So let's do that. Let's test this one more time. And you'll see we got that fail, right? Now notice that the test suite failed. It still printed out our coverage report. We didn't get any sort of coverage fail yet, but we did get this failure. So we know that that's working somewhat as intended. It's really not the most rigorous test yet, but we're getting there. Okay, so that passes. Now the thing is that none of this really should have changed. And so once again, I know I'm beating a horse here, but such a strange expression. I know that I'm beating this to death, but we, I just want to go over this last time here that the coverage is not changing, even though we wrote a better test. So the coverage led us to say, yes, we need to test this thing, but we need to actually make it a useful test still. Okay, done ranting. So now we, let's like take it one more step further here. Let's say, okay, we know that we're not running this, this else statement here on rarity. And we also know that we're not running the shortcut here, short circuit, and we're not doing a common, which we would get from passing in no rarity at all. There's also this little thing here. So let's like just do one more pass super fast. So we'll write a test now. And this test is going to say, should default to common item when no rarity passed. Something like that. Okay. That got a little bit long. Sorry, let me see if I can scroll down over here. Oh, the challenges of zoomed in. Okay, so in this case, what did we have here? Well, we could just generate an item with just a type. So let's do, I'll do generate item, and we'll pass it a type equal to weapon. And that's it. Let's test that. Okay. Run our test here. And that's looking better and better, more and more green. We love to see that. And there you go. Look, now common is covered. And then we come up here and this is covered. So we're getting closer and closer. You can see we're kind of whittling away at this file and getting a little bit more confidence each time. Now, I'm not going to waste more time by, you know, writing a proper check test on this, because you're kind of getting the point. But let's say, all right, well, let's do one more here. I want my template here. So let's say that I want to do my short circuit, and then we'll kind of call it good on this file. So I'll say, should return null when no values passed. Or actually, in this case, it was no type passed specifically. And this is, again, nice for us to read, you know, coming into the project is sort of a documentation of like, when does this, what does this function do when pass these things. So we'll generate item. And when we generate that item, let's see what happens if we just pass it nothing at all. Okay, see, that's interesting, because we tried to destructure this property type of undefined. So in this case, the cover just kind of led us to an actual problem with our test, because the person writing this was like, okay, well, I'll just pull off type by default, yada, yada, yada. And then I'll check the types not there. And that's really the only situation where I want to, you know, catch here. I worded that poorly, but I think you get the point. So let's see what we can do about that. Okay. So if we come back over to our generate item, of course, we could just make it, you know, succeed by passing it or an object that was empty, let's say, but that's not really necessarily what we want. You know, we want to fix things as we go. So to get this passing, let's do something like this. Let's say that I'm going to, you know, cut this out right here. And I'm going to change this to maybe let's say item options. And we're going to by default, use a object, we're going to, you know, fall back to passing in an object if they didn't pass in anything at all. And that will let us do something like this, we'll say pull off type and rarity from item options. There's of course many ways you could do this. And this is just a quick way to make our code just a little bit more robust here, because now, we can guarantee that at least type can be pulled off of this empty object as undefined at the very least. So now let's run our test. And you can see that it passes now. If we go back over to our coverage one more time, and we refresh, you can see that this has hit many times, of course, and we now successfully check this scenario, this unhappy path here. And that's really all that's left. We've covered a lot at this point. And we've I feel a lot better about this, I think that anyone doing this should, especially", "metadata": {"title": "Reveal testing weakspots in your JavaScript code with Jest Coverage", "url": "https://www.youtube.com/watch?v=fQpvuRVDp-8"}}, {"page_content": "this, I think that anyone doing this should, especially if you're just kind of coming in and looking at some legacy code and building a little test harness around it, we can see that we started off with very low coverage. And now we're covering a lot more situations. Again, we need to write a little bit more robust tests there. But at least we're checking that you know, it doesn't just straight up fail. But what's glaring at us right now is this little bucko right here. And this is something that I just wanted to illustrate really quickly. So if we take a look and hone in on this code, what it's doing is it's saying, okay, this base item that we're kind of creating, I know we haven't gone through the code that much. But this base item at some point is checking, it's going to add the stealth bonus property to it. And you can see that if the armor type is light, you're going to get a three bonus. Otherwise, you're going to get a zero. Now what's interesting about that, though, is this armor type itself, let's actually go back to our code to check this out. So this armor type right here, you can see that we come up here, when we generate base armor, armor type is sort of randomly created from this list up here. And so this is outside of the control for us at this point, because we can just run this test over and over and over. And essentially, you know, one of these times, it's going to switch on us, which is pretty confusing. Let me try to show that real quick. Let's actually add a log, though, while we're doing it. So we have this one generate armor case, right? So let's log out armor. So we have an armor that is the light type, which means that you get the bonus of three, right? And so now you can see it flipped here. So flip from three to zero. And just to show you one more time, if I run that again, we got light again. And now we got heavy this time, if you're not noticing, that's right here. And then when we flip over here, it's going to change every time. So this is kind of something to know here is that like, you know, the coverage gets a little trickier or tests in general get trickier when you have randomly generated things. And so at this point, what you would probably want to do is do some sort of mock the method that you're testing. And or you could make it to where you have overrides that you can pass in. So you can get some hard returns. hard coded returns. This is what I mean by that. And this gets a little bit too much into a side rant. But I'll just note that, you know, we're testing generate item only. And, you know, in our tests here, each of these tests is really just calling generate item. But we really, if we're doing unit tests, you know, we should be calling some of these individually to test them, and not relying on our test to kind of go through each of those things. So that's what I feel about it. So there's various different ways that you could cover this. I'm just showing that to you. And we're not going to solve that here, because it attracts too much from the main point of the video. But just know, this is something that coverage is a little bit tricky to track, but actually can be really helpful. Because I've had times where if I have some sort of random thing, all of a sudden, you know, my, my test coverage will be lower. And I have some stipulations to fail it. And from that, what will happen is it will reveal to me that my tests aren't actually that good, because they're kind of random, whether they cover something or don't or run one track or another. Okay, so now we've gone through this process of utilizing coverage to kind of hit to us what to test next. And I think that this is a really good tool, if you're newer to testing, to kind of introduce you to what you know, what really should I be testing. And like I said, also, it's really nice when you're coming into another code base, and you can get a good idea of how well covered all their code is. So, you know, I think it's pretty awesome. Hopefully, you do as well. But let's move on to the next part of coverage where we can make it even more powerful here. And that is to add a config option. Now, what I want to show first for that to kind of reveal that actually, let me remove my log super fast. I'm not flooded with that. We've used its purposes. And for now, we're going to be done with generate item test for a little bit. When we ran this test, this coverage report here, we noticed that this source utils helper JS was 100% covered here, right? Now, what's interesting about this, there's a couple things. When we go to utils, notice we have this get biggest change file in here, but that's not in our coverage report. Huh, that's interesting. And then if we go to the tests of the helper one, this is the other thing, we only test this get random int version of it. But if you go to helper, there's actually a get random int in range as well. Hmm. Well, let me start with this one. This get random int in range is actually being tested by generate item, because generate item imports it, let me go up here, and uses it. And so through writing the tests of generate item, you've indirectly tested get random int in range. This is good and bad. I mean, it's great, because you are still testing it in sort of a real use case scenario, but you're not really directly testing. The bigger problem to me, though, is this get biggest change is like not reporting to me that it's not tested. And that's because the default, which I think is a good default for jest and coverage is that it's only going to run without any additional configuration, mind you, it's only going to run against tests that exist. So this helper test JS imports, get random int and runs it on that. And because of that, because it's importing this file right here, it's going to put that into the coverage report. But get biggest change doesn't have any tests that run it at all directly or indirectly. And so it's just not going to be in our coverage report. And this is nice, because it's a good way to ease yourself into testing. But I want to be a little more strict. I really want to know out of all of my files, what is tested, what is not, what is covered, what is not. So in order to accomplish this, what we'll do is we'll make a jest dot config dot JS, you could also do this as a jest property in your package JSON, but I think this is the better way to do it personally. And then we'll do module dot exports. I think this can also be in a JSON file, whichever you prefer. And we're going to start with this property here. And it is going to be collect coverage from and that will be an array. And so what we'll do here is we'll say I want to test against source. And then I'll do star star slash star dot j s. And so what that's going to do for me here is I'm going to say, you know, I want to test anything in my source directory, because that's my actual code. And, you know, maybe I should show you just really quick. Let's say what if we didn't do that source? What if we just did star star dot j s? This is kind of interesting, huh? So notice this jest config dot j s was now tested. And all these different other things in the coverage folder were tested. So that's kind of the point that I'm getting at is that we don't want to test every single thing in our project, because some things are generated, some things are node modules, some things are etc. So what we want to do is go back to this point where we can say anything in my source directory. That's what I've written now so that, you know, you can also do something like this where you say, don't test this. There's a couple of different ways to do this. Don't do anything that has node modules in the name. I don't think you actually need to do this because I think by default it's going to ignore coverage. The ignore coverage setting is going to have node modules added to it. They show it a lot in the docs, and so it doesn't really harm anything. So I always throw it in there. Now, this also allows you to ignore, you know, specific files just so that you know, like if you wanted to ignore, let's say, get biggest change is something that we're not ready to run coverage test at all on right now. Well, you could throw that in the ignore if it's, you know, blocking you from moving forward for some reason. You'll see why it would be blocking you in just a moment, actually. So let's run coverage again now. We should get a much slimmer report. But now look at this. We", "metadata": {"title": "Reveal testing weakspots in your JavaScript code with Jest Coverage", "url": "https://www.youtube.com/watch?v=fQpvuRVDp-8"}}, {"page_content": "slimmer report. But now look at this. We have added get biggest change to the source utils when before it only had helper.js, and it's telling us that it is 0% covered. And look at this global. We used to be, so let's go up here a little bit. Look how good we used to look. Great 93.33 branch. That's fine. That's actually pretty good. Then down here, you know, that was that one conditional that we couldn't cover. And now it's so much lower because this file overall has dropped it. I really like this because it's a good way to kind of it's like a measure of confidence of, you know, of all my files. How well tested are they? Well, if some things are like completely not tested, they're really going to bring down your overall confidence rating in the code base.", "metadata": {"title": "Reveal testing weakspots in your JavaScript code with Jest Coverage", "url": "https://www.youtube.com/watch?v=fQpvuRVDp-8"}}, {"page_content": "Now, if we hop back over to our coverage report here, now when we come back here to the root, you'll see that this source utils, which used to be all green, now our source is actually green, but source utils is much more hit up. And if we click on that, you'll see that this is all the stuff that we haven't run any path whatsoever. Now, to speed this up a little bit, I'm going to, you know, toss in a couple of tests right here that I've pre-written just to show you that getting covered a little bit better. So I'm going to make a file real quick here for this in source utils. I'll write a new file and I'll just call it get biggest change dot test dot js. Paste this. So I've got a few test cases already in here now. And so as we can see, when we call them, all we're really doing is we're just saying, hey, call get biggest change with a thousand. In this case, it's copper pieces and the copper pieces are passed in and we say, OK, well, that should be exchanged to one platinum if we want the biggest change version. And then here, you know, you can see you get two platinum and three copper. And finally here, we're testing a big number like 40. So come back over to here, run our coverage again. We'll see that's looking a little bit better. It's yellow, right? Let's come over here and our coverage report and refresh. We're looking a lot better, right? It's kind of fun. So really, all we need to do is cover, you know, oh, hey, you didn't actually cover any scenarios where you give them back gold or where you give them back silver. And so I'll do that super fast. I'm just going to copy this test here. And I'm going to pass some silly scenarios. So let's say you pass in 100 or maybe 200. Doesn't really matter. That should give you some gold. Pass in another one. Let's do 70. Should give you seven silver. Run that. Nice. Getting better and better. You can see uncovered line is still line 11, which we'll come back to here. Perfect. But this line 11 where we didn't pass anything is the last thing. So let's go back up to the top. And normally I'd write another test just to kind of identify this a little bit better. But I think this is fine for now. So let's pass in nothing. Now, what we should expect to get back is just this object of no coins whatsoever. And oops, go back over here, run it. Ooh, look at all those hundreds. And there you go. Now we have this file fully covered. So let's show how we can make the impact of that a little bit more drastic, actually. This is where it gets really fun to me. So we've set up a config to where we're making it to where we actually know now, like if any code in our source folder whatsoever is not covered. And of course, we could expand that to your project's needs, however you like. But what if well, actually, look at this. We can see that it's the test, regardless of fails or not. We go all the way back up here. When this was terrible, the test still pass, which is good. That's what we want. But we're going to be wanting to add this into some continuous integration in a moment. And to where what the result of that is going to be is every time on GitHub, when a pull request is done into the main branch, for me, I'm going to run a coverage test. And if any tests fail, then you can't merge. And if the coverage falls below a certain threshold, then you can't merge. So let's set the first steps up for that. So in this just config, we're going to add on another property here. This property is going to be coverage threshold, not two H's. And that object here is really interesting. It's going to have a global property. This is the kind of the default way to set this up. And the global property here is really neat. What we can do is we can say, what global coverage do we expect to have? Well, we can target each thing. So we'll say for branches, I want 60. Let's say. Let's make it really high at first. So we'll say 90. Functions, 90. Lines, I guess we'll do the same thing for all of them for now. Now, you may be wondering, like, how would you come up with these values? I'll talk to that in just a second. Let me actually show you the impact of this. So right now, when we run it, we should be good. Because we've covered so many things. But check this out. What if we go back to this get biggest change test file here? And what I'm going to do, I'm going to wipe out all the rest of these tests. So I've commented them all out, and it only runs the one. Let's see what happens. Ah, interesting, eh? So now we get these right here, where it says global coverage threshold for statements 90% not met. 70.83 is what you got. And you can see that right here, confirming that. So what does this mean? What does this red text even do? Well, it's obviously alerting us, which is nice. But it's also going to return a sort of error exit code here that when we run it in our, in really any environment, but in particular for us, our continuous integration that we're about to have, it's going to fail when it doesn't meet this criteria. And that test will actually fail as a whole. So you're going to get a failure if your tests don't pass, which is obvious. But you're also going to get a failure if you don't have proper coverage. And this is to help protect your system or your project as it grows and grows and grows in scale. And people continue to add functionality and change functionality and all that stuff. If they're not adding tests as they do that, eventually you'll fall below this threshold and it'll fail you and be like, okay, it's time to write some tests, guys. So that leads me back to, you know, what I was saying before is like, okay, well, how do you come up with these numbers that we came up with here? How do you say, you know, what makes you decide 90, 90, 90, 90? It's really based on your preferences. If you have a new code base that you're trying to test slowly and build this test harness over, you know, maybe a legacy code base or something, you probably want to start lower and kind of increase the strictness as you go. If it's new, you should probably set it higher so that you're alerted really early. So let's go to another scenario here, actually, where, let me close this over here. We don't need that right now. So actually, what I'm going to do here is I'm going to bring all this back in, get us nice and covered, and I'll show you through a different type of example. So now we're passing. Okay. But let me show you a higher level override that we can do here for this next demo is we started with global. But what we can actually do is target individual folders and files how we like, which is really sweet. So in this case, I'm going to do dot slash source. And here I'll do utils. And so I'm going to say the utils folder is very important to my project because everything's using it. I want very high confidence there. 80, 90, not enough. So what I'll do is I'll just copy all of these lines here to override them. And I'm going to say 100. Got to be 100 everything for utils. Okay. So we'll come back here. We'll run this. And it's passing right now. So that's fantastic. We're very happy. But let me show you an interesting scenario. And then we're going to push this up, show some continuous integration. So let's say that if you recall earlier, there was this test here for helpers, and we're only testing one of the functions. Well, the other way that we were testing it was in generate item. This get random int in range was used. So what if someone, you know, in the future came in here and was like, you know what, I don't really like using it that way. I want to do get random int only. And that takes, well, actually, they could just leave it that way because it would just not pass in the second argument. So let's do that. And now you can see that we're not using this, right? So what's going to happen here? Well, when we run this coverage example, we're going to fail all of a sudden. And that's because we weren't directly testing this. And by this, I mean that that particular helper that we were indirectly testing before, and now we're not. Okay, so let's say someone did that. And now I'm going to create a new branch just to kind of show a normal kind of workflow example. And let's say, let's call it, you know, swap random int, something silly like that, right? Normally, I would", "metadata": {"title": "Reveal testing weakspots in your JavaScript code with Jest Coverage", "url": "https://www.youtube.com/watch?v=fQpvuRVDp-8"}}, {"page_content": "something silly like that, right? Normally, I would review all my, you know, different changes and stuff like that in VS Code. But for demo purposes, to speed this up, let's just commit it and say swap random. What was it? Get random int in range out. I won't get more specific than that. Okay, so now we'll push this. We're going to push this up here. Now, I've already gone and set this up, but I will show you kind of what that looks like really briefly. If we go over to here, you'll notice that this is my repo. And of course, GitHub's awesome is going to say, oh, do you want to you got a new branch that you've pushed up? Do you want to make a pull request? Well, yes, I do. So I'm not going to bother doing anything fancy here, of course, but we'll speed this along. And now what's happening is these checks are running automatically. This is your continuous integration. And you can click this to see some details. Let me open a new one here. And this is really neat. So the test and coverage. I don't know why it took me to that weird screen. We're about to run this and then we can see that it runs. Yada, yada, yada. And in this case, it passes. OK, so everything ran. Let me let me dig into that just so you can see. Everything passes, and that's because right now we're not we're just running a the just CI, but we're not doing our coverage yet. So I want to show you that when we push this up, even though it has failed our coverage, it's just passing the test. And that's all we required in order to merge. So if we go back over here, we'll see. Yeah, we're good. So let me show you that real quick by switching it. If I come back to here to my code and what I'll do is in the package JSON, I'm going to add a dash dash coverage flag here now to the test CI. So you don't have to really worry about this flag. It's mostly just for snapshots, the way that they run and see I to be a little bit more efficient. It's pretty standard for just and then the dash dash coverage here, obviously, is now we're going to be like, OK, well, I actually care about coverage as well. So let's add that. Add coverage requirement in CI. Check that. Push it up. And let's see what happens. So this is the this is that one run. So we need to back out of that. We'll see that this has started up again. OK, go on over to this. See, it runs checkout code diving into this part right here. Just follow it along. Error. It's kind of cool, though, you could see it did actually print out our little table here of all that stuff with the coverage. And it gave us these comments on why it wasn't met. But eventually we got this. This is what I was talking about before this exit code one. So when you get that, it's actually going to fail this step entirely. Notice now we have this red X. All checks have failed. So in my case, for my repo, and this is pretty common for any public repo, the administrator can override that if they want to. But even if you go to it's really nice, it's going to make you check this box. It's like, you're really sure about that. So cancel that here. And actually, if you want to see, I probably should be covering this a lot more in a CI particular video, but I'm sure some people will be curious. So I'll just briefly show you if you pop on over to your your settings in your repo. This has to be a public one to do this. If it's private, you have to pay for specific, you know, access to get bumped up. But you go to branches right here. You can see that there's this branch protection rules here. And if I go to edit, all I'm doing here is I named the branch main. And I'm saying I require these status checks to pass before merging test and coverage, because normally it'll still show up in the CI like so. It'll fail here, but it won't require it to pass to merge. It'll just kind of be like, hey, just so you know, this failed. You know, you could still merge willy nilly. So this nice little branch protection rule is saying like people can't even merge without admin access to this branch. If any checks fail, that's how serious you want to be about it. OK, so let's fix it real quick. So we'll go over to here again. And back to our files. And so we have this helper's test. So really what we want here, this this is kind of cool because the coverage has sort of shown a vulnerability in the way that we're writing our tests. And that's that we are indirectly testing through generate item one of these helpers. And we we can now be like, well, you know, I don't necessarily want to change the code base of generate item to use this anymore. You know, really, we delete this, of course, and we're just not going to use it maybe for now. Maybe you use it somewhere else. Who knows? But for this to not happen again, and for someone to know that they can confidently use this method in the future, we should probably write a test specifically for it. So that test is going to look, you know, something like this. Pretty much the same thing, but, you know, we'll call it between four and nine. We'll say that it should equal or be greater than four and should be less than nine. We'll run that. And this is what's really nice about CI is a lot of times you'll forget. In this case, we could actually just run NPM run test on CI since we have that script now. Oh, we got an issue here. Ah, yes. We're calling the wrong function. Well, that's always nice to get. Right. So we actually need to say import int in range. Good to know that that can fail, right? That's the nice thing about testing. And there you go. We could run it again and again if we want, but there we go. So what I was kind of saying was that what's nice about CI or continuous integration in this case, for this context, is that, you know, people are not going to remember to run the tests every single time they change code. They're just not. So this is a way to sort of enforce that. You could do it on the push level, every single push. In my case, it's been sufficient for me to say, look, you can't merge into the main branch until you pass these tests. So maybe you would do that on feature branches into any merges. It kind of depends on how complex your project is. So with that, now we'll show the passing pipeline. So let's say added add test. Proper grammar here for git commits add test for git random int in range. I don't know why I care about these messages. It's just an example. So we'll push that up. And because we have this PR open, it's automatically going to rerun. Sometimes this doesn't update right away, so you just refresh. I took a while. I took a couple of refreshes there. So here's our old failed one. I'll just leave that open. Now we can go over to here. These are pretty quick, usually. If you've got a lot of stuff going on, it can take longer. And there you go. And look, this was automatically swapped back. And now we can successfully merge this into our code base. So I can click that. I can say confirm merge. And there you go. It's really neat that you get to see the history here, too. It's like, oh yeah, at one point this failed. And then all your checks succeeded. Now if you're wondering how that works in particular, like I said, I'll probably be doing a continuous integration video if you guys want that and want to see more of the ways that you can do that in your project. Just let me know in the comments or on Twitter or whatever that you want to see more of that stuff. But just so you can kind of get a quick peek here, if you have this.github workflows, obviously this is on GitHub. It's different from Bitbucket or GitLab, but you have this folder structure and you can look it up on GitHub Actions. I just have this test.yaml file. And I'm saying on pull request on these branches. So any pull request to main, I want you to run this test coverage. And here's just the name of it. You don't need to worry about running on Ubuntu latest, checking out the code. It's a pretty standard step. But this is the part that we care about. We run npm ci, which is sort of npm install, but on the ci, a little bit leaner. And then npm run test ci. And it's that simple. So I'm just telling it to, you know, install my packages and then run this command that I have. And just with that little bit of setup, we", "metadata": {"title": "Reveal testing weakspots in your JavaScript code with Jest Coverage", "url": "https://www.youtube.com/watch?v=fQpvuRVDp-8"}}, {"page_content": "And just with that little bit of setup, we have some really awesome configuration to protect us and protect our code base and let us know what's going on and let us know when people change features. You know, what's really sweet about that is in that scenario that I just showed with generate item where I swapped out this value, this could be a PR that someone's making to my code base, whether it's open source, whether it's on a team. And I wouldn't have to dig through and find that that thing wasn't used or is used differently. I would immediately know from that test failing that, oh, we actually don't have any tests that actually test this helper out anymore. We're relying on that. So it's really awesome way to automate and keep yourself informed and keep the confidence in your project high. So that was a lot. But if you made it through all that, hopefully you're wiser for it. I think I've spoken to the benefits of the coverage utility function and coverage reports in general enough that I don't need to re go over them again here. I hope that was fun and interesting for everyone who stuck it through that. And I encourage all of you to try it out in your own projects and see how it makes you feel better about your code and what things you discover. I've learned a lot by using just coverage and tests in general about the soundness of my code. And that's why I'm a big believer of testing and unit tests and all the types of tests in general now. And with that, I will say goodbye and hopefully see you in the next video.", "metadata": {"title": "Reveal testing weakspots in your JavaScript code with Jest Coverage", "url": "https://www.youtube.com/watch?v=fQpvuRVDp-8"}}, {"page_content": "Hello, welcome to Swashbuckling with Code. I'm Jimmy Cleveland and in this video I want to talk to you about why I think the vast majority of you should not be learning Webpack in 2023 and what some battle-tested alternatives are that you should be looking into and that I'm going to be doing some videos on shortly as well. This is kind of a funny video for me to do because my Webpack series has actually consistently remained my most watched videos. And while I think that having some Webpack knowledge can really help your fundamentals in this world of bundling and transpiling and all that good JS stuff, I just don't think it's worth it for most developers with all the great alternatives out there now. Why I say most developers though when I say you shouldn't be learning Webpack in 2023 is because Webpack still remains a very flexible and customizable tool and there's a lot of frameworks and tooling out there that's built on it because of that flexibility. And you might also be in a work environment where your company is using Webpack or an older application that you're using is built on Webpack and you don't have the bandwidth to transfer it over to something newer. There's just a few niche scenarios where Webpack might make sense for you. But if you're starting a newer project now or you're just newer to web development in general and you're trying to get your head around all this transpiling, bundling nonsense, I just think there's some really nice lean tools, super fast, work pretty much out of the box that you can just dive into and get going. Because in the end you should just be making apps, right? So enough preamble, let's just dive into the build tools that I think that you should be learning in 2023. And that's build tools, plural, because you can just learn one of these, but I'm going to give you a few options for various different scenarios or personal preferences of developers that I think should cover the vast majority of use cases. And I'm going to have timestamps for each of these. So if you just want to look at one in particular and then bounce, that's totally cool. And keep in mind that I am going to be making some videos that get into some more depth on how to actually use these instead of just covering the highlights of what they have and what they offer. So if you're into that, you know, subscribe, hit the notification bell, whatever, you know, you do you. Okay, so as to not waste any more of your time, I'm going to start with the best one, the one that I think that most of you should be looking into, and that is Vite. Now I actually feel like this might be the favorite right now. But that just might be my social circles. And the main reasons are that it's super fast, it just works right out of the box. And you'll actually notice that quite a few of the tools in the ecosystem are starting to be built on this, including Astro if you're familiar with that. So what's really great about Vite is their documentation just really modern and fresh. And it just focuses on getting you going right at the beginning. And I love that you can dig into more details if you want to about their methodology and why they do the things they do. And that's also awesome. They give you some simple commands that you can run like npm create Vite, or you can use yarn or pnpm or whatever you name your app, and then you can provide a template or you could just leave that off. And then the CLI is going to walk you through this sort of wizard experience of asking you what JavaScript framework you want. They support vanilla JS, React, Vue, Svelte, all the good ones. And when you select each one, they also have a TypeScript option for each. And it's really cool. Once you hit it, it sets up your project with a little boilerplate. A quick note about the TypeScript though, that Vite uses, they do use ES build under the hood in development to transpile TypeScript, which actually doesn't do type checking on each build because it's way faster not to. And this is okay for a lot of you because your IDE is probably going to let you know about most of the TS errors. But if you want that actual type checking on your build process, you're going to have to set that up yourself in your own build process, or your CI or whatever you want to do with that. Just know that one of the interesting things about Vite that makes the developer experience so fast is that they don't actually bundle all of your code. Each time you make a save or change, they use native ES modules with hot module replacement for a faster cycle time. So you could of course just set up your own project with just native ES modules and import them into the browser and that'd be fine. But Vite adds some really cool tooling on top of that, including the hot module replacement. And if you're not familiar with that term, you might be familiar with hot reloading. And it's similar except it doesn't reload the page, it actually just kind of ejects the module so that when you save if you're like in the middle of filling out a form, and then you change something, the form will still be filled out, it doesn't actually fully refresh the page, it'll do the same thing with CSS, where you don't have to keep refreshing and get to your current state, it's just a lot faster development time. Now I mentioned that it uses ES build under the hood for development time to improve page load speed. But Vite also uses rollup under the hood for production builds. And that's really interesting. The reason they do that is because ES build actually is lacking in some functionality for code splitting, CSS splitting, such like that, which means that if you use ES build for the production build, your apps aren't going to be quite as performant in some situations as they would be if you use a real powerful tool like rollup that's just built with that feature set in mind tree shaking code splitting to the maximum all that good stuff. If you aren't familiar with all those terms, that's perfectly fine. You're probably going to pick them up as you go. Or you can check out my future videos, I'm going to be referencing them as I dig into each one. But it essentially really just equates to a better performant experience for your users when you're building apps. Another quick little cool thing about using rollup under the hood for production builds is that it can lean on the plugin ecosystem of rollup, which is super mature. And that means that if there's something that you can't customize with Vite, which is pretty well customizable, honestly, there's a bunch of rollup plugins that have kind of been ported over modified. So they work well with Vite, there's a whole list of them. And you can just grab one of those and do it pretty similar to a rollup config. Now I did mention that Vite uses ES modules, which some browsers, some legacy browsers might not support, well, they actually have an official plugin that they support in order to use it with legacy browsers, which sounds pretty cool. But I have never tried that. So I can't vouch for it. But it's there if you want to check it out. One of my favorite things about Vite that you get right out of the box is it's very similar to Parcel if you've ever used it where if you just provide a certain file type that it can handle or a certain configuration file, it's just going to automatically detect that without any setup required from you. So for example, if you add a post CSS config, it's just going to work. If you want sass or less or stylus or any of those, you do have to install the packages. But once you do and create the sass file, for example, you could just import that in your regular JavaScript code, and it's just going to load up and work just right. They've also got CSS module support built in, which I like to use whenever I'm kind of building something really lean. And they've also got great image support, static assets, SVGs, all that type of stuff, you just import them and it does all the work for you of turning it into a hash and your final bundle. You know, every time the file changes or whatever, you just import it and it'll make all connect all the dots for you, so to speak. And all of that comes pre-configured for you as soon as you pick the template for the framework that you want. So in summary, I think that Vite is probably the number one choice this year for the build tool that I think you should start with if you're looking to just quickly create a project and get going and have awesome fast cycle time. All right, if you're still here after that one, my next pick is going to be ES build. And why would you pick this over Vite? Well, particularly, I think that you should first start off knowing that Vite does use ES build under the hood for development at least. And that's what makes it so freaking fast. But if you want to use ES build itself, what you're going", "metadata": {"title": "Don't learn Webpack in 2023: A dive into 3 alternatives", "url": "https://www.youtube.com/watch?v=RAvdPTkVpCE"}}, {"page_content": "want to use ES build itself, what you're going to get out of that is kind of some lower level customization and leaner toolset. So if you're the type of developer that wants it as minimal as possible, and you don't mind doing a little bit of extra work to set some things up, this might be the tool for you. So with ES build, when you're starting out, you can just run an NPX ES build commander the like, and you give it your in file and your out file. And it's just going to bundle that up for you with some defaults and essentially have something that you can load up in an HTML file and it'll work. There is a configuration option built in, but it's a little bit weird. I would say that's one of the weird things about ES build is it doesn't feel quite as idiomatic for lack of better term, as normal in the JS ecosystem. It's just not very typical to how most JS build tools work. So you might just have to get used to that. But it is pretty simple to get an app up and running. And it's really fast. It's written with go under the hood. And that's the main reason for the speed, of course. But some of the downsides to ES builder doesn't come with a dev server or anything like that. You have to create your own HTML file and all that good stuff. It doesn't come with any of that out of the box like Vite would. It also seems to be pretty focused on either vanilla JavaScript or react with JSX. Most of the docs are covering only that I know that there are some plugins out there for view and spelt and such. And of course, Vite uses it under the hood. But this is another thing you want to know going in. Even if you're not really interested in ES build as a main tool, it might be worth just going through the getting started documentation. It's only going to take you 1520 minutes probably to get a react app up and running with pretty much no configuration. It's pretty awesome. You just create your standard react, react DOM or server client file, your index file, then you're going to make like an app file. In this example, I'm doing one from the react docs that just has a little counter and it's just going to automatically detect the JSX and set that all up for you and output the bundle correctly. Then you just create your own HTML file, you throw a little script tag pointing to that and bada bing bada boom, you've got a react app up and running. I think if you're making just a really simple app, this is a pretty good tool to have in your belt. But if you do need a lot of customization, be prepared to dig into the docs and really learn some stuff. Because personally, for me, it just wasn't the most intuitive tool to learn for quite a bit of use cases. Now I have to finalize with this point because it's going to segue into my next one. One problem that I really have with ES build is it doesn't seem very well built for libraries, even though they do mention that I'm someone who spent a lot of time on build tooling. So I wouldn't say that I'm like an expert, you know, it's not like I've built these tools myself. But if I'm struggling to make code splitting work out of the box on different routes on next JS, for example, just trying to drop my library that I created in ES build into it like I would any other package. Well, if I'm struggling with all that, then probably a lot of developers are going to, I feel like a lot of people think they're getting all those proper benefits out of the box with the s build and actually aren't. So really just do some testing. One of the tests that I do is when I make a package with it, you know, let's say I'll publish it or use relative installs or whatever. But let's say you publish a package, then I'll just spin up a brand new next JS server, for example, since it's a really popular tool. So of course, your library should work for it if it's a react library, and I'll install it. And then what I'll do is I'll import one module on one page and one module on another. And I'll see if that code actually got split between the two. So it only loads on the page that it's used. And then there's something that just did not work with a lot of configuration options from me using ES build. But if you're not doing any of that, and you're not worried about creating a library package for other people to use, or you just don't really need that much code splitting or whatever you just it's pretty lean, and I think he has built a pretty awesome tool. All right, now here's my third alternative that I think is one of the major build tools you should consider in 2023. And this one, particularly if you are creating a JavaScript library, that build tool is roll up real quick note before I dig into roll up, I should probably explain the difference between an app and the library briefly, those are the two main terms that you're going to run into. And an app is essentially what it sounds like it's like a website or an application that you're using JavaScript to create and host and you know, running the client or server side render or all those good things. But a library is different because that's something you're intending to be reused by other apps or websites or other users. Okay, those are very different concerns. Now you definitely can create apps in roll up, and people do. But for me, it's not the tool I would reach for. I think where it really shines is libraries. This is the only tool that I can consistently get maximum performance out of my libraries. I mean, all of the tree shaking code splitting goodness that you're looking for. I do a lot of design system work over the last few years. And so roll up is a really handy tool in my tool belt, because it's the only one that I can get all of the optimal performance out of of all the tools that I've tried it. It's the one that handles the the full optimal tree shaking, which isn't so hard. Most of the other ones have figured that out, but mostly the code splitting. So if you want a really solid tool to learn, because you're making a bunch of library apps, and you want them to be optimal, I really think you should look at roll up. Now be warned that roll up is much like a web pack, and that it is a beast, it takes a bit to learn, I would say it's one of the least intuitive ones to pick up and just get going. I do plan on making a roll up video in the near future, especially if there's some interest. So leave me some comments if you are into that. And if you're eagerly awaiting it, of course, you can subscribe and hit the notification bell and all that goodness if that's your thing. But there is a lot to cover with that video. And I want to make sure that I do a good job of it to kind of give you a peek into what you'd be getting into with roll up for your standard TypeScript react setup, you're just going to need to install a few packages, create a roll up config file that utilizes those packages, they cover some of these pretty well in the docs, but some of them you need to go to the individual packages to figure out. Like I said, you kind of have to piece this knowledge together by looking at general tutorials or how other packages are built. I do really wish that the docs kind of gave you more templates are more informative about that. But once you get those basic things set up, you just run your roll up command with a dash C to point to the config and you're off to the races. What's really awesome about roll up though, is that the plugin ecosystem is immense. Turns out there are a lot of challenges to tackle in this modern JS ecosystem. Even just for react, there needs to be like common JS plugins in order to take it from that and turn it into ESM so that you can have all your tree shaking code splitting goodness. There's a bunch of other stuff we won't get into it right now. That'll be in the future video. But just know there's probably a tool out there for most of your use cases. Now those are the three main build tools that I would pick at start with and use as my everyday drivers, each with its own specific type of project that it excels at. If you aren't sure what to choose, I really recommend just starting with Vite. I think you're going to continue to see it just keep growing and growing in popularity. It's really been slicing through those turbulent waters recently and emerging on top. But those build tools are not the only game in town. Those are just the ones that I use that I like and that I can recommend. Some other honorable mentions are Parcel 2, Roam, SWC, and even TurboPack, which the Vercel team is working on and is super promising replacement for Webpack coming up. In the end, just pick one. Don't", "metadata": {"title": "Don't learn Webpack in 2023: A dive into 3 alternatives", "url": "https://www.youtube.com/watch?v=RAvdPTkVpCE"}}, {"page_content": "up. In the end, just pick one. Don't worry about decision paralysis. Just get going and build things though. That's my advice to you. The competition is great and you should embrace it because while it can be a little bit overwhelming to constantly have new build tools flying here and there, the whole ecosystem is just getting better and better from all that competition. But really just try Vite out. You're probably going to love it. My final note on this video is that you might not even need to mess around or learn any of those tools. Honestly, the major app building frameworks out there like Remix, Next.js, SvelteKit, and Astro growing a lot in popularity recently. All of those things take care of a lot of the stuff for you. You probably won't even need to think about the things that you used to have to with a Webpack configuration. Again, there are times when you have a very specific customization in mind and you might need to learn a little bit of it. And so having those Webpack chops from back in the day, or if you've gone through any of my tutorials recently, those will help in those situations and you'll still have a better fundamental understanding from learning those things about how this whole ecosystem works, of course, with bundling and everything. So really the bottom line for me is just pick one of those tools that's the least amount of friction and just get going building things. All right, as usual, I'm going to wrap this up saying I hope that this information was helpful to you. And I hope that you'll let me know if there's anything I can do to make these videos even better and even more helpful. Hopefully I'll see you all in the next one.", "metadata": {"title": "Don't learn Webpack in 2023: A dive into 3 alternatives", "url": "https://www.youtube.com/watch?v=RAvdPTkVpCE"}}, {"page_content": "Hello and welcome to Swashbuckling with code. I am Jimmy Cleveland and in this episode we are going to cover JavaScript promises and async await. In JavaScript, promises are a way to achieve asynchronous results, which essentially means that they do not block the execution of code. Probably the most common example of that would be fetching data, like say from an API, and that would still allow your users to continue interacting with your app or your website. Because making an API fetch is one of the most common use cases of promises, that's where we're going to start out. We'll make a simple fetch and then we'll do something with the data, such as logging it. After that, we'll get into the foundation of writing promises using the new constructor, using promise.resolve and reject, and also going through the various then and catch statements that you can chain on to promises. After that, I'll show you how to make some nested promise queries and we'll also show how to flatten those whenever we can to keep it nice and readable and composable when we're writing our promises. Finally, we'll wrap it all up with a async await example when our promise nesting gets a little bit too unwieldy. Hopefully that gives you a good idea of what the content structure is going to be so that you can use the timestamps to jump around wherever you need be, depending on the level of knowledge you already have on promises. But with that, let's get into it. For this video, I'm going to be using a few different mediums to showcase the things that we're going to be delving into with promises because I think it's nice to have different ways of visualizing it and some of them do it better than others. For one, we're going to be using Firefox in a couple different ways. We'll be loading up an HTML document like normal that runs a script, but I'm also going to be using the console because I like the way that it represents promises in their different states, which you'll see in a moment. I'll also be using Quokka as a VS Code extension and you'll see why I kind of like that when we get to that point. I'll explain it. So we're going to start in the Firefox console here. So the first thing I'll do, of course, is bump that up for you all the way. As much as it can go, that's actually max, just so you know. And then what we're actually going to do is use this nice little icon here that shows you this multi-line editor, which I think used to be called a scratch pad. It's a really nice feature that Firefox has. Let's bring that over here since we'll use the whole real estate. And what's cool about this is it actually lets you write out code and execute it whenever you want, rather than executing one line at a time or as you like write one function. It's a little bit akin to writing it in an editor, which you'll see. Now for this first example, rather than diving into the basics of promises and their various methods, I want to start out with a very simple but common example of using promises so that you can kind of see what we're going to be building toward and you have something to base it on. So in this case, we're using the fetch function, which is native to browsers nowadays in JavaScript, but not in Node. And what we're doing is we're going to be making a fetch to this API, which is the Star Wars API, which is a nice little public API that you can hit to get some various data, and you'll see in a moment. And then we'll be doing these various things, which we'll talk about in a little more detail, but you can see that eventually we're going to console.log the response from this, and then I'll go and create a variable, and then I'll console.log that. So when we run this here, you can see what happens. It first shows the code that we created, so don't worry about that, and then these are the actual things that are running here. And you'll see that we got created after fetch call. This variable was logged first before this log happened. So for some, that won't be too much of a surprise, but for some of you it will. So why is this happening this way? Well, let's take a look at the code that we're going to be running. So why is this happening this way? That's because fetch, or promises in general, are a sort of asynchronous methodology in JavaScript, which means that rather than running synchronously, which means line by line, they go off and they do something, and then they report when they're done. Think of it that way. So normally, of course, when we run our code, each one executes one line after the other, but in this case, this goes off and does its thing, and then these are able to continue on, and that's why you get this first, and then when that response comes back, then you get it. In this case, we're just logging it, but of course, we could do various other things. There's a really great video by Philip Roberts on the event loop, if you're interested in learning a little bit more details about asynchronous JavaScript and kind of what's going on in the background and getting a better mental model in your head. I really recommend that, and I'll link that here. Another recommendation I have is by the always entertaining Jake Archibald on the event loop as well, and it's a really in-depth, detailed video about set time out and promises and all sorts of good stuff like that that I really recommend checking out if you're trying to get a good mental model on what's going on in JavaScript with asynchronous behavior. Let's actually start with the MDN docs with promise to get into, you know, how the different methods and states of understanding it. I'm not going to be, you know, thoroughly going through all this, just using it as a reference, and I highly recommend, you know, browsing through it or reading it whenever you get a chance because it definitely is really well written. So for promises, this is the most important part to start with, I think, is that there are these three states. There's this pending, fulfilled, and rejected. And so what we're going to try and do is showcase that. You'll also see that there are these general methods, and I'm actually going to start with promise.resolve just to kind of see that. So when you write promise, you can actually just call it like this and say resolve, and when you do that, you'll see I'm so I'm going to press ctrl enter here, and that will run the code. You can also click this little button if you're using Firefox and following along. And here you'll see that we have the state fulfilled with no value, right? So what if we just put a value in real quick and say value and some other stuff just so you know no reason. I refresh just to rerun it here and clear that. And here you can see that we have the same thing, but now we have this value stored in here. This is something I really like about Chrome and Firefox is how they represent promises when you run them. They show you this promise object and the state and the value of it. So there's our first state we have fulfilled, right? So that was one of them fulfilled, and that's when we just resolve it. Hopefully you'll understand that a little bit better once we start building our own promises, but that's just a fire off of resolve right away. So what if we fire the reject method? What happens then? We'll say go away, all right? I'm gonna refresh that just so we don't have any noise. When I run this, so the first thing you'll notice here is that we have this error, right? And that's always going to stand out to you first. You can actually ignore that for now. We will explain that in a moment. It's just an uncaught error. But then we get this promise object state and it's rejected. And notice that it's not value, it's reason. And the reason is go away. So we've got rejected here. We've got our fulfilled. So how do we get a pending state? Well, these are actually evaluating like instantly here. So let's try to do something like this. Well, let's use the promise constructor to demo this real quick. So I'm going to say new promise, you can call it like that. And then what it takes is a callback here that will give you a resolve and a reject method. So we're going to just accept the resolve for now. And then we'll just use a quick arrow function. And what we'll do inside here is we'll use a set timeout. And we'll just have a function in that set timeout that calls resolve so that we can pass it a value and say I waited. And then after that, of course, we will pass in milliseconds here. And let's just do like 1000. So we have a second, we're going to wait a second here, and then see what happens. So what we're doing here is we're showing that we can actually by waiting to resolve this thing, once this promise is created here, the promise as soon as it's printed out as it's run is in a pending state, which is our final state here. And that will be a little bit more normal when you're using promises. So let's say that you're making an API request, it's going to be in the pending state until that API request comes back to you with either an error or the data that you wished for, in which case it will be fulfilled or rejected. Now, you'll notice that we didn't get any sort of log or anything like that from I waited, right. And that's because all we're really doing is calling that resolve function, which is going to give us something that we can run a then method on. So let me actually store this variable real quick and say my promise equals will make this new promise. So if I just try to access my promise here, and refresh and run that, you'll see that we're still just going to get this state pending. What happens if I console dot log, my promise, okay. Same thing here, right? Just getting this promise state pending, that's time it's actually logged here. But what we can do is write my promise dot then. Now the promises is doing this sort of IOU behavior, which is saying like whenever I am ready, then I will pass you back this thing. So in this case, we'll say dot then, and what we'll get back with the then method is a some sort of response, what it's commonly referred to. And with that response, we can do whatever we want. So let's console dot log the response here, run that code. And you can see after a second, it says I waited. Now something interesting we can do here is that we can on a new line here, let's say, I want to console log my promise. Okay. So we're saying, once this dot then fires, and it should be in a fulfilled state, after we log out our waited, I waited, can't talk, run that again, and you'll see I waited, and then the state is fulfilled. So here you can see a promise going through these different states, going from pending to fulfilled once it's completed. So a promise also takes, or gives I should say, a reject method here. The callback takes it, and from here we could, after a set timeout, just call reject. So reload, I'm going to run this, and let's see what happens. Notice that we got uncaught in promise, I waited. We don't actually get this state right here. And that's because when you get a rejection, the then method actually isn't going to return it in the first callback here. This is a little bit confusing of syntax to look at, but let's see if this is the whole first argument of the code.", "metadata": {"title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}}, {"page_content": "And then the second argument is what I'm going to put is, let's say, error or something like that. And then here what I'll do is I'll console.log error in this case. And then also I'll do console.log my promise, reload, I'll run this. And here you now you can see we got the I waited value still. That was the error that was passed. But this time it says the state was rejected, and that's the reason, is I waited. So you could, you know, in this instance, do console.error here. See that? So you could kind of just put your own console error, however you want to handle it. And the point here is that rather than actually throwing an error and halting your execution, you might want to do something else. You might want to have a fallback state, you might want to send it off to your logger if you happen to have a logging service, etc, etc. The choice is up to you. I know the syntax is a little bit confusing. This is the first argument, and then this is the second argument that it takes. Now I don't commonly see people use it this way. What you can actually do instead of this, let's take this right here and cut this out, is you can chain on, and I like formatting it like this because I think it makes it a little bit easier to read. Oops, let's dial that back here, sorry. I like to chain it like this so we can actually continue to chain one method after another, you know, just like, you know, map filter reduce or anything like that. But we can do a catch block here. So in this case, I'll paste that code from before. Oh goodness, forgive me, this is very difficult. I am not normally going to be editing inside of the browser like this, you know, I'd be using my IDE, but I'll struggle through it for your sake. So here, now we have this catch block, which is really interesting. And so what this is going to do is catch whatever this error is, and then we can do whatever we want the normal way that we did, but instead of doing it in this, you know, more confusing, harder to read syntax where it takes these two functions, we can just do it in one catch. And you can see we get the same result here, right? Now we don't need this then here, just to be clear. We could just go straight to the catch. I don't know why you would ever do this. But we could. The point is that this is this really neat format that a promise when it gives you the sort of IOU back, depending on the state, it will go through these various different chains. So to take it a step further, to show you the generic kind of model here that you want to be using, what you can actually do is from this then you can return something, and that is going to be received here. So let's say I'm going to return, even though I'm logging it out, I'm going to return a response, okay? And what that will allow you to do, let's say we'll go back to this being a resolve, is chain onto it further from that. Now I'm going to not do that first just to show you that I will get the IOU response, which is this console log here, and then we're logging out the promise being fulfilled, and then we return, but it doesn't do anything after that. That's because the catch block is not going to be fired because it's not an error, right? But I could do another then. And I can name that whatever I want. I can change the name or I can keep it the same, since you know we're at the same scope level here. Goodness. And then what I'll do here is I'll console.log the response one more time, and maybe to make this a little bit more clear we'll say first then, and then we'll say second then, and then I guess let's just put this here. We'll leave that as an error because we know what it is. I'll return that and I'll run it. Oh whoops. Missed a comma. Rerun that again. Okay, first then, I really should put a colon here, make that a little more separate and easy to read. But first then, I waited. Second then, I waited, right? Now this seems pretty pointless at this point, and it should. But you can see, it's just to illustrate that you can continue to pass this down by returning from a promise. Anything that a promise returns will be thenable, or you can run then on on the next step. If I were to return an error here, let's say, or just throw an error, how about that? So throw new error. It will get first then, I waited. So this actually got hit, but then I threw an error, and the catch block caught it here. In fact, let me add catch block. It's not really a block, I guess. See that? Just to be sure, so that you know. So it's skipping this step right here, and I'm going to show that. I think it's a little easier to understand or kind of see going on in my VS code in just one second. What I want to show here is that to end it off, if we go back to the return, we can actually change our values. So we got that response, right? But there's nothing stopping us from adding on to that or changing it or, or let's, let's completely flip it up here. Let's return an object that I'm just going to make on the fly, and I'll say, you know, value is response, oops, response. Let's not make that a string. And then something I added this. Okay, so right here we have this first then right here got called. Then we'll see here that the promise fulfilled, yada yada yada, that's this log right here. But then the second then, that is right here, okay? That logged this has this object, which has something I added this, and the value I waited. So that's this original value I waited. And we don't have to return that. I mean, honestly, we could return anything we want, ignored the response, right? Last example here. Last example here. Just to show that, you know, the second then ignored the response. So you can do whatever you want in these promise chains, you can just keep returning and then and all that stuff. Let's take a look at that in a different view to kind of show how it bypasses things. So in this case, in my editor, I've got just a simple index JS here that I'm going to be writing for just a moment. But what I'll do, let me close that. So we've got full real estate here is I'm going to start Quoca on this start on current file. And if you're not familiar with Quoca, it's a very nice little extension. It essentially continuously runs the code that you write in that file and gives you this nice way to print it out. You know, seeing is probably better than being talked at. So here we go. So I'm going to write a const, and I'm going to call this success promise. And then we're going to make that equal to a new promise. And we'll do the same format as before, we'll pass it a resolve. And in this case, I don't need to get reject off of it. So I'll just ignore that. And then here, what I'll do is I'll just call resolve. And of course, you know, normally, when you're making a promise, if you're promisifying things, as it's commonly called, you could be doing all sorts of things in here, a common thing is that you set time out to cause a delay after so much time, etc, etc. But you know, let's just stick with the basics here. So we've got this resolve, and we'll say, you know, resolved value, something like that. Now, you can see on the left here, I've got these little green boxes, that's Quokka, letting me know, my code is actually running. And you'll see that in just a moment here, some differences. Okay, so next, let's make a new variable here, failure promise, that's going to equal new promise. In this case, for our callback function, I'm just going to put an underscore since I'm not using that variable. And then I'll do reject, we are going to use that. And then let's just call reject. This time, I'll do rejected value. Okay, so this is where it gets interesting. So what we'll do is we're going to call success promise. And you can see that Quokka prints out this then resolved value, which is really interesting. So what they do is they go ahead and even though you're not calling the dot then method on it, they're saying after you run it, then you'll get this, it's really neat. What's kind of interesting is if you do failure promise, they'll put a catch rejected value. So they'll say, well, this is this would only print out in the catch block, that's what you're going to get is rejected value. Let's make that rejected. So we don't miss it. So let's go back to the success promise here, we can do here is we can then chain off of this. And so let's do our value or response or whatever you want to call this, it doesn't matter. For this first level, I will say console dot log the val. And you can see that we get this resolved value, it's the actual one, it doesn't say then at this point. But I can also in Quokka just print it out by writing it there. And then I will return that value. Okay, I'm gonna write another dot then here, just going to chain it along. You know, that's weird to you, it's just the same as that, calling it afterward, but I can put it on a new line. We'll do one more here. And then what we'll say is, we'll call a val again, do the same thing, make sure what we have the val is. And then we will return. I'll set this up in one second, let's do a val one more time. And then finally, we'll do a catch block. And this catch block, we'll call it an error. And then here's where we will", "metadata": {"title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}}, {"page_content": "console.error. Now you'll notice that this little white block appears here, which is kind of interesting. This white block is saying that this code didn't run at all. And that's because we don't have any errors at this point. If we were to switch this over to failure promise, you will see that we get the rejected value and none of these ran, but this one did. This is a really nice thing about Quokka that I like, it shows things that were skipped. Let's go back to the success promise. Now check this out. What if I return from here failure promise? Isn't that interesting? I don't know why it's saying reference error. Oh, it hasn't like updated yet is why. If I save, I'll do x e. Sometimes it gets stuck like that, don't worry about that. So here you can see that this first block ran, but then I actually returned a whole promise, not just the value from that promise. Isn't that interesting? So I returned a promise that called reject or called resolve. And because I did that, it was caught in the catch block. So if I do success promise, you can see once again, this one will run, it won't run the catch. And then finally, if I return success promise again, it's not going to do the catch block, it's just going to, you know, you basically have kind of left it open to be bend on one more time, but you're not doing anything with it. But if I ever do failure promise, now all of these code lines execute. Let's go back over that briefly one more time here, what happens here. So we start with the success promise that we make a new promise, and then we just immediately call resolve. We don't do anything because it's kind of a useless promise at this point. But you know, it's for example purposes. Then we also had this failure promise. We did the same thing, but we just did reject. We start with the success promise, and then we say dot then. So when you're done resolving that promise, which in this case is instantly, well instantly in an instantly in an asynchronous way, to be clear. So then we're going to get a value, we log that value out, and coconice, and it just puts it right here for us. And then we return the success promise, and that success promise is a promise that resolves. And so since you have a promise that resolved, you can then move on to the then. And then finally we return the failure promise, which triggers this catch. And as you saw, if you put this at any point, it'll go and trigger that catch. So you can return values from the promise and keep thening on them, modify them, whatever you like as you've seen, or you can return a promise itself. And that will be really important to understand in an in an upcoming segment here where I'm going to show nested promise fetching and how you can flatten that out a little bit. Because a lot of people seem to not realize that, and they just jump straight to a single wait. So now that we've gone over the basics of writing your own promises and creating them and all that such, and how you chain them with enables, let's come back to making a fetch request, because that's I think the most practical and common example. So we're going to start our fetch. And you could use Axios. I if it kind of depends for me, fetch is nice, because it immediately runs in the browser, and you don't have to install any packages. And that's why I'm going to use it here. If I have a larger scale project, I probably use something like Axios because of the ability to set defaults and not have to set your content headers and all that good stuff, just so you know. But we'll stick with fetch here. It's nice just be able to reach for natively. And so what I'm going to do is I'm going to do https://swapi.dev API, and then you can go to people again. And in this case we'll still just do, we'll start with one. Okay, so we're going to get that fetch working. And then it's just kind of common to format it by putting it on the next line, because it makes it a little easier to read through as a synchronous sequence of steps. So we'll say we're going to get a response back, right? And that response, this is kind of an odd thing about fetch compared to like something like Axios, is that you have a bunch of different ways that you can kind of convert the data. The most common that you're going to do for like a JSON API is just call this JSON method. And so that also is going to return this value that you then want to then on. Okay, and in this case we could write response again, or we could make it like maybe a little bit more readable and say person. So we got a person back, and then here let's console.log for now person. Why do you format this way? Okay, let's run that. You saw that we got the state pending, this was just our code, and we're back where we were before where we have all this nice data for Luke Skywalker, right? Now to show a kind of a silly use case about how you could do something besides console.log, let's scroll this over here. And if I go to my inspector, what I've done is I've made this little pre tag here that has an id of result block. So let's go back to our code, and what I'll do is I'll just simply grab that. So I'll say const pre block equals, or we could do pre tag whatever, document.querySelector, and then that's an id in this case, and so I'll do pre block, oops, can't type, and I'll do a space just to make that clear. And then here instead of logging this, what I could do is say pre block dot inner text equals, and we'll do json.stringify. We'll take the person and dump that there. We'll do the standard null and then two space indents. Oh, we got an error. What was that? Probably from pre block is null. Oh, don't be silly, Jimmy. It's, what do we do that as? Result block. Result block. Apologize for that. Oh, we're all over the place. Ah. Let's refresh. So we'll run this again, and I'll just lengthen this just for a moment so you can kind of read it here. So yeah, we're going to call it once we get the data back, turn it into json. It's actually just called the json method, so we're turning it into an object here, but then we're going to set the inner HTML here. So if I run that, you can see that I'm just dumping it on the page here. And if I didn't put this like null and two, it would just be one long string all the way across. It wouldn't format it, just so you know. So really the only reason I've done this, it's not much different than logging it out, it's just to show you that, you know, you could do whatever action you want in here, and in many situations you might just dump some data, or you might, you know, have a an object up here that you're, you know, assigning that data to. You're causing some sort of side effect, I guess you could think of it as. Now let's take this one step further here, because I think that's kind of interesting, is what we get from this data. You'll see that the way this API works is that a lot of these values are sort of static, but this one is a URL in order to hit. Isn't that interesting? And that's because Homeworld has all its own data, and rather than, you know, like either, it's just a way to write an API where you can have these kind of, just like variables, like dynamic endpoints that it hits, you could obviously make your back end like go and grab all of that data, but in this case the way they've made this API is to just grab kind of the minimum of what you need, and then you can go and grab more if you need that. So let's take this line right here, and we'll cut that out just for now. So what we want to do is we say, okay, well we've got our person, we've got Luke, but I want to know his Homeworld, okay? All right, well what will we do here? We kind of just need to run another fetch. We can't really run it outside of this because we need to go get the person first, and that will give us the data that we need to get the next thing. You'll run into this situation quite often quite often when you're doing any sort of complex queries or anything like that, where you'll get, you'll do some sort of promise, and then based on the results of that, you need to take that data and do something else. So that's what we'll do next here. So I'm going to fetch, but what's interesting about this is I can just say person.homeworld, because this is the person we got back, and then we're just going to go to that Homeworld. We're going to do the same song and dance again here. Let's say we do a.then, and it's really common to do this res.json, just to make it shorter. Most people will do this with res. I'm kind of a stickler typically because response and resolve and some of those other things are similar, so I like to write out the whole word, but of course if you want to be succinct, go ahead. I prefer to be a little more declarative typically, but just to show a common pattern since you'll see it a lot. So there you go res.json, and then we'll say okay well after that, then I want to, let's say we're going to have Homeworld at that point, and then we can do the thing that we wanted to do before, which is this pre-innerblock, but we'll swap that out with Homeworld. Okay now we're getting a little bit crammed here, but I think you get the idea. So let's run that now. I'm just refreshing, and notice that now it prints out the Homeworld that Luke is from, Tatooine. So we've simply just nested these different fetches. Now I hope you can see at this point how nonsensical this could get, and if you happen to have been around in the time of callback, you know callback hell and Christmas, tear of death, and all those various terms, it's got an eerily similar vibe. You're going to keep nesting if you need to keep doing things. It might not even be API fetches, it might just be general data stuff, and it's going to get messier, messier, and messier. And let's say what, you know, the next thing you want to do is, you know, get these residents or get the first film or something like that. You know, you're going to have one more...", "metadata": {"title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}}, {"page_content": "fetch there. So what we actually can do, we learned this earlier, that you can return not only the value but a promise, and from that promise you can do a then. So what if instead of kind of nesting it like so and doing this pre-block here, we were to say return this fetch, and of course you could keep the then here. I'm personally a fan of breaking all of my thens into their own thing, and I'm going to do it that way just to show you. So here, this is the end of this sequence here. So we've got that, and so that's this then here. Oh, I missed something. Uh, we need that, that's this, whoopsie daisy. So let's get that. Yeah, that looks better. Oh, braces and parens, how you get me. So then we'll do this, and we've got that. Oh my goodness, formatting. And I'll just bring this here just to give you a little bit more real estate so you can see it. There you go. Okay, normally if you're in a normal size editor, this is closer to what it would look like, but obviously we're all zoomed in. So do you think this is going to work? Hmm, hmm, it does, because we simply learned that we can return that promise. And so rather than nesting it, you can keep this nice and flat and sort of instructional. So you can see now, because we're using fetch, Axios would be a little bit cleaner because you wouldn't have to do this extra JSON step, but regardless, you can see how if you're doing a bunch of promise stuff, you can you can read it as a sequence of steps, which is really nice. You go and you fetch the thing, then you do this, then you do this, you're going to get that data back from a promise, then you can move on and process that as JSON, and then you have the home world and you can do whatever you want. We can actually make this a little bit easier, nicer, because we we could keep this all fancy for doing simple stuff like this and use an implicit return. And then we'll just reload just to show that that still works, and then it's even a little bit cleaner. Now it's not always going to look this nice, but a lot of times it actually will if you're doing pretty simple operations that you can just return. One value just returns to the next, returns to the next. The same idea is like mapping, filter, reducing, all that good stuff that you typically learn in declarative programming and all that good stuff. So if you can, you want to be flattening your promises as much as possible. It just makes them a lot easier to read, not have to deal with the, you know, the nested Christmas tree of death nonsense. But I'll throw in a little disclaimer here. Sometimes you need to do a little bit more. In this case, we're just getting back home world, right, at the end. But what if we actually wanted Luke with his home world attached to him, okay? Right now we sort of have this function. We've got get person, person's home. And it takes an id, let's say, which is kind of funny. So then we could say, cos get person's home is equal to, fetch this thing, and then we'll turn this into an interpolated string, and then that will make it to where we can do braces here, id, and then I'll go back here and I'll make this an actual function that takes id, of course. Formatting. Okay. So now we have kind of the same thing, you know, make sure it runs. So yes, we have get person's home, and that's great. And that's how you can kind of make this general use functionality of this. But what if you just wanted get person, you know, with home? You probably wouldn't say with home, but you want to get more data for them. Well, in this case, you're kind of in a tricky situation because when you go and you fetch this home world and you get that JSON back, at this point you don't have access to person. It's in this function's scope here. So what do you do? Well, you could do something like this, where you say const person equals, let's say, you know, by default, it'll just be an empty object. Okay. And then on this step right here, we would actually have to put a brace back here and say person is equal, oh, well, we've got a scope, let's say person data to make it not confusing. Person data is equal to person at this point. And then we're going to do that fetch still, but now we have to manually return it, retrun it, classic. And then that will be here, we'll have a brace. So we'll assign person there. And then finally, when we get the home world, what we'll do is we'll say person data dot home world. So we'll replace what we had before, which was just the URL, we'll set that equal to home world. And then when we JSON string ify, we'll just do person. You think that'll work? Oh, it's not get persons home anymore. You silly goose. Get person, person, make it make sense. Oh, and I can't assign that, of course, I was thinking, you know, I have an object and I was going to mutate it. But let's just do this. Why is person not defined? Oh, the person data here. We are making a lot of mistakes. I'm sorry. There we go. Goodness. Okay. So now, this does work. We have Luke, we got his home world, we dumped all of that data, you know, we haven't gone and gotten all these things, but you can see it then moves on to all the various other data. So this is a way that you would kind of accomplish this. It's kind of, it's all right. I don't really like the whole mutating outside of this. I like the way that we had it before. But if you really do, you know, need that previous data, you're in a kind of tricky situation. There are little what I would call them little hacks, little tricks around like returning a promise that you could like make as an array of the fetch and then the person and do some different fancy stuff with that. But it's a little bit confusing to do it that way. If you need to do something like that, I would do it this way. But this does bring us into a pretty good use case, for example, for when a sink await can be pretty nice. So with what we have right now, what we could actually do is make get person an async function. So we could just say, a sink here, you're not familiar with this, just hold on. So that I'm just going to put some braces around that function here. Now, with a sink, what you can do is you can make a variable, let's say person, call it that. And we're going to await something. And you can only use this await keyword if you have a sink here. And then what will await is actually this fetch right here to come back. And we can still chain this onto it if we want. But it's a little bit kind of confusing. So let's do it like that. And then from here, we can console log what is person. Now, normally, we wouldn't be able to do this outside of then, right. But what this allows us to do is run our code sort of synchronously, to where it will do this thing. And then it'll stop here before it can do this next thing. This function itself is asynchronous, but within it, you can run everything line by line. And sometimes it's a little bit easier to reason about. Okay. So we'll do that. And for now, let's comment this part out. And let's say that that's all we do is we just call that and we won't need this either. Okay. Now, goodness. Here, you can see that we did indeed get Luke back at this point. Okay. Bring this back over here for just a moment. So we got our Luke data back. And you can see that that works pretty well. Console log normally, you know, if we were to put it outside of it wouldn't have been able to access that data, but in this case it can. And so that allows us to keep moving on with the next step in a normal synchronous manner. So now we'll say, okay, well, you know, go get me the home world. We'll say await. And that's where we'll comment this back in for just a moment. And we'll say, okay, we have this then person, blah, blah, blah, blah. We just want to do this part, right? Fetch the home world. Home world, await, fetch. Get rid of this. We will need this. You could also do each of these one by one if you wanted to, but I think that kind of creates too much noise. And then finally, on this last step, we'll have a home world. So we don't need to do this then home world. We can actually just delete this block here. We would do something like this. And so we would just say, okay, well, person, oops, we don't need person data anymore. Sorry. And we'll make that home world is just equal to the result home world here. We'll do this. And there you go. We don't need this variable anymore.", "metadata": {"title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}}, {"page_content": "Okay. So let's reload and run this. And you can see that it still works now. So we've got our Luke and we have our home world and we've built this whole person object with Luke and the home world on it. So this is kind of the value of a sink away. And some people would say that you just pretty much always should use a sink away because it's just a little bit easier to read. And there's no reason about that code. I think that that's a valuable argument. I could see that, you know, just kind of using one way all the time, depending on your environment, it's possible that you might not be able to, but it's, you know, most environments nowadays do have a sink away. And so you'll be fine with that. Sometimes if it's a really simple promise, I don't mind just writing a normal promise. Personally, it just kind of depends on the code base. But there you have it, you might find this a lot more easy. Oops, sorry, to, you know, read and reason about you go and you get the person actually should be probably called print person, right? Since we printed here, but you go get this person, you have to say sink operation, you go and fetch the person and you store it in person, you go and fetch the home world and you store it in home world. And then you just change this little property on it. Do a little mutation dance. And then you go ahead and do your side effect or whatever you're doing. Now, what happens if we wanted to keep this as a get person, but and not a print person, and we want to make a separate function, as I think you should to print person. So let's say const print person. And then in this case, for now, let's just say, Oh, well, this is just a function that maybe it takes a person. Right? We run this block right here. Well, that means that we would have to return from this person. So get person, this case, print person, that's a lot of same person. What we could do here is we could say let's call print person with the value, get person. If you don't like that, you could store it in a variable first, of course. And see how that works. Let's run that. Hmm. Object. Interesting, right? Okay, well, what happened? What if we console log person here and see what we get? We got a promise with the state of pending. If you don't believe me, I'll put person. Just to make it more clear. Look at that. And then I got fulfilled once I opened it. Isn't that funny? Watch this. This is an interesting thing that Chrome does. So when this is printed, the status is pending. But when you like, look into it's kind of like a Schrodinger's cat thing. And you look into the object, it will actually update with what the values are. This can be really confusing. Sometimes if you're looking at objects that do mutation or change them afterward, think that your thing did right or didn't, right? You get the idea. It's pretty confusing. But you can see that we still just have this promise object and we can't write that promise object. We don't have the data. So what do we do here? Because, you know, I thought that we just asynchronously got everything and returned person. This is kind of a gotcha here. Because, you know, when you wrote this async thing, like I said, this function is asynchronous. It didn't just turn JavaScript everywhere into synchronously writing. And actually, that would be really confusing if it did. It has made this, you can think of it just as returning this promise. Anything that's going to be returned from here is still going to be a promise because it needs to be treated asynchronously. Okay? So what we would just need to do is we would need to do something like person.then data, let's say. And then we'll put this block here. We're doing a dance. We don't need this line anymore, right? And then we'd have to change this to data because that's what we changed it to get back. Let's run that. Oh, it works. Cool. So even though we're using this, you know, async await thing, and a lot of times with async await, you won't even see these then statements in here. You know, it looks something like this. And people get pretty confused, understandably, that, you know, you could write everything in a sort of non-promisey way without thens and such. But what they might not realize is that, you know, in the end, you've still got to handle it with this then statement, however you're doing it. Now you might be thinking, well, can't we just async await here? Yep. Sure you could. You could say const data equals await person and get rid of this line here, get rid of this line here. Reload, rerun, and that works, right? You got this promise back. You don't need to then at this point because you just got this promise back and you're just awaiting it. I think that shows off kind of the async await syntax fairly well, I hope. So if you wanted to, you could go async await all the way. But I wanted to show you that it is just kind of obscuring it. And a lot of people jump right to async await because they're not used to doing a lot of heavy callback or promise things without really understanding the inner workings. And it can get pretty confusing, you know, like you could be totally coding in a vacuum of async await and just be writing, you know, this block right here. And maybe the package or whatever you're using is doing this type of stuff for you. Or I should go back to the like the promise.then type stuff for you. And you don't really know that you need to do that or that you can't access this out here in the root. You know, you can't go and store that variable here. You know, you can't do something like this. Let person at the root, you know, let's say we start with this object. And then here, I said person data last time, let's make that less confusing. Person data, blah, blah, blah, blah. And let's say that, you know, print person, you want it to be a bad person and use a bunch of crazy side effects stuff. Well, you could say that print person doesn't take anything. And maybe it reads. It just does this simple thing, person data. We don't need to return here. Instead, we'll just say person data equals person at this point. Right. So we've gone and we've done all our mutations in person. And then we're just going to say this is person data. Now, we obviously could have just reassigned this, but whatever. Let's rerun that. You're still going to get that object. This is what I'm getting at. Like you can't do that. You need to handle that promise that thenable in some way. And that's what a sink await is doing for you. Hopefully that kind of clears that up. I know it can be a bit confusing if you're not used to it, but I just wanted to show that that let's go back all the way here. You need to do something to this effect. I think that'll be good enough. Get that running again. Beautiful. Now, at this point, we have covered quite a bit. And I would love to show promise.all or all these other different various methods that are really cool. If you look at these methods, there's a bunch of neat ones that are kind of fun to dive into and understand that. For example, in this for a real quick example, this residence, you know, we would have to go get a bunch of different things. It's not just one fetch. And so how would we wait for all of them to complete or maybe the first one to complete or something like that? That's what those kind of methods are for. And you can return that all as a promise that comes back as an array. But that would definitely add on to the length of this video considerably. And so I'm going to call it here. And if people have requests for going over those methods, then I'll consider doing a video of that in the future. This video was a pretty tough one for me to put together, just trying to decide on what the right way to display promises and kind of think about them and how much depth I should go into async and all that stuff. So I apologize if I didn't really do as good of a succinct example. But as usual, I hope that this was a little bit informative for you and helped level you up a bit to getting a better grasp or concept. Or maybe you're just brand new to promises, kind of getting your head around the idea of them and how you would commonly use them for some basic scenarios. But if I did not do a very good job, go ahead and let me know in the comments and I will do my best to improve from that feedback. Thank you, and I hope to see you next time.", "metadata": {"title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}}, {"page_content": "Hello, and welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and today's video is going to be on the topic of semantic versioning, also known as SemVer. There are many systems that use semantic versioning, such as Ruby Sense 2.1, and it's a standard for RubyGems if you're familiar with that. But in this video, I'm going to be covering it under the lens of NPM. But if you're not familiar with Node or NPM, I still think following along will be useful because the main concepts that I cover are all the same throughout all semantic versioning systems. Now, NPM actually has a quick introduction video to semantic versioning, and I'll link that in the notification description. So if you want to check that out, feel free. What I'm trying to do is a little bit different. I'm going to go into a little bit more depth, and hopefully you'll walk away with a really sound understanding of semantic versioning. And I'm going to be doing that in what I hope is a practical example by using two major packages in the NPM repository, Inquirer and Chalk. So hopefully this will give you a real world example of encountering situations where you want to update your package and how you might troubleshoot that or how you go about doing that. So with that out of the way, let's get into semantic versioning. Now, I have some timestamps at the bottom of this video in case you want to jump ahead to the actual code segment. This first segment is going to be me talking about what semantic versioning is and why you should learn it and kind of why it came about. Then I'm going to go into some actual code projects, and we're going to show examples of installing different versions of packages, what all the different symbols and numbers mean and all that. And that'll wrap up the second part of the video. So a common question that comes up with semantic versioning is why? The shorter answer of that is without some sort of specific versioning spec in place or a system that everyone complies to when they make packages that are going to distribute and for people to install, there's just going to be chaos and unreliability. Semantic versioning gives package maintainers and creators a way to communicate what is in each change that they put out. Some high level examples of that are going to be, does this version update include a bug fix that I am safe to update to without changing my code at all, even if I don't even have the bug? Does the new update have a feature that I may or may not use, but won't affect the existing features? Or is it such a major change of the code base that previous users of the package are going to have to change their code? Otherwise, they're going to risk things breaking when they use it. These are the major points that a semantic versioning system is trying to address. Whenever you roll out a package, there's three numbers and no more, no less. The numbers are major dot minor dot patch. So a common example of that will be 7.2.0, in which seven is the major version, two is the minor version and zero is the patch version. If a new bug fix came out, the patch version is the first thing to go up because it's just a bug fix and it's just going to fix some previous existing bug that you don't have to do anything about. You just install the package and it'll fix it for you. So that would be 7.2.1 in this example. Then maybe there's a new feature that you might want to access. That would be 7.3.0, for example, for the next bump. Even if it has multiple new features, it'll still be the next number up for the second position, which is the minor one. Finally, there's the major version and that's called a breaking change when that updates. So this is the case would be 8.0.0 if any breaking change would exist in the code base. So sometimes a new feature comes along with a breaking change. And so that's where you'd have to jump from 7.3.0 to 8.0 because even though you're putting out a new feature, it breaks the code. So when you see a move from just a minor number, just to be clear, 7.2.0, for example, to 7.3.0, well, that 2 to 3 in the middle position is saying this is a new feature for you, but it doesn't have any breaking changes that we know about. You shouldn't, you can opt into the feature if you want, but you don't have to change your existing code at all to run this package. I really think that learning how semantic versioning works will make you a better coder if the concepts are foreign to you at all, because it helps you think about your code in a way that you can distribute it to users without breaking their functionality. It really kind of opens up a new way of thinking if you're new to this concept where you think, okay, I shouldn't just, you know, change whatever I want to add a new feature or to fix a bug regardless if other people are going to use this, I should really selectively think about when people use this, how's it going to affect their code? Can I do it in such a way that they can just install it and it fixes their bugs and they don't have to do anything at all? Then I should probably opt for that path. It's a sort of like least resistance here where you want to start with a bug fix. If you have a minor, okay, cool. You have a new feature that you want to show them and then kind of as a last resort, should you do a breaking change? You want to try to keep those to a minimum as much as possible because they're scary for people that are updating packages. One more quick point on this is that if you do have some new way of doing your code that normally would cause a breaking change, you can actually still make that a minor by including the old behavior and then putting a new way to handle the new feature, such as a new value in an option config object or something like that. Then you can flag that as deprecated, which means that it's not favorable to use that because we're going to be removing it in the future, but it won't break it right now. Then you can slowly migrate users away from that old behavior so you can get rid of that part in your code base. You can kind of see how thinking in semantic versions really helps you write more robust, reliable, and communicative code. To sum up all those points, semantic versioning promotes thinking about your users rather than yourself. Now, a downside to semantic versioning is that it doesn't tell you how much code has changed or even how much code you'll have to change if you're the consumer of the package updating it. There are definitely those that have drawn criticism to semantic versioning because of that, but regardless, it's still a widely adopted system and I don't know of any better ones that are being used in mainstream products currently. But I thought that you'd like to know that it's not new unanimous. There are critiques about it, of course, as with anything in software engineering. So the last point that I want to hit on before I jump into the code and show the practical examples is the special little characters that you might see. One is the caret or sort of an upward chevron, if you can call it that, and the other one is a tilled character, which is a little squiggly. Whenever you see that, the most common default is that caret character in the front of your number. So you'd see the caret 720, for example. What that's saying, and this is the default in npm, is that when you install that package, if it ever updates for any reason, whether it's through like some sort of npm update or you run npm install or you don't have a lock file or whatever, there's various ways that this can happen, it will never bump past that major version because that's a breaking change. And so that could be dangerous to your code. And that's why it's the default. So that's why you'll see that there. If you were to leave that off and you ever see a package installed with just 7.2.0, no character in front of it, that's saying this exact version, never update it. It's only going to be this one. Now, the other one that you'll see, which is a little less common is the tilt character. And what that is saying is that we're going to be a little more restrictive. Instead of updating a patch or a minor, we're only going to allow updates of patches or bug fixes. So I don't even want new features. Maybe I don't want to risk it or whatever. I only want bug fixes. That's definitely not as common, but you will see that from time to time. There's a lot of other nuances, of course, to semantic versioning as with most things, but I'm really trying to hit the major points so that you understand the big picture. And so I think it's a good time to jump into the code and hammer that point home with some practical examples. For this first example, I'm going to walk through making a quick", "metadata": {"title": "Understanding Semantic Versioning with Real World Examples", "url": "https://www.youtube.com/watch?v=1zBzkT7QCmA"}}, {"page_content": "example, I'm going to walk through making a quick project setup just so you know everything that's going on, but we're going to do it pretty quickly. So don't worry. So we're going to first do create a directory and I'm going to name it SemVerExample. We're going to cd into that example. And then we're going to do is npm init dash y. It's just to say yes to everything. Now, one thing that I want to do here is install this package called inquirer. Now inquirer is a really popular package. It is used to create CLI command prompts to where you can in the terminal give a user questions and they can answer it and then you can get feedback and act on that program. It's a really, really powerful tool and you're going to see it in action in just a moment. That's just a brief introduction. Now, normally you would install a package by just typing the name and that's good, right? But what we're going to do is we're actually use the at symbol and pick a specific version. In this case, I'm going to pick 720. So that is major for the seven, minor for the two, and patch for the zero. Now I'm going to have an example of each of these. So don't worry about that as we walk through this. Just to reiterate, that's what it is. Major, minor, patch. That's the thing that you want to ingrain in your brain. So I'm going to install that real quick and then I'll show you it in action. Now if I jump over here to my browser, I have npmjs opened up here and you can see that this is a very popular package, 21 million. And I've selected it for that reason because it's such a common package that it's a real world example that's commonly used and you'll be able to do this yourself and follow along. And I've imagined for the foreseeable future, that's not going to change. So hopefully that makes it pretty practical. Let's jump back over here and let's open our editor. Now in this, we're going to have a package JSON. And the thing about that that's interesting is even though we installed 720, you'll notice that it did that, but it put this little a caret. And what this is saying is that whenever you do an install or an update, it will never go past the major version because that's breaking changes, but it will go past the minor and patch. So if you look at package lock JSON, and this will be really similar to yarn lock, we can actually do a quick search for this package we'll do inquirer. And you'll notice that with inquirer here under node modules, if you're using a older version of NPM, it might be a little bit different format here, but this is pretty similar. So it says we have 720 installs, the actual version installed. I'll show an example where that's not the case. But for now, we'll just keep moving on with this example. You'll notice that it also has these dependencies. So it has its own dependencies, and they'll have their own dependencies. And that's how the whole thing works. So it's snapshotting each of these versions. And you'll notice that they're all using this really common default, where it's saying, Hey, I won't go above a major because that's a breaking change. But I will auto update minors and patches. So if the first time that you install this, you can see this is an exact version, actually, because it doesn't have a little character. The first time you install this, let's say that low dash it had a lower version of low dash, but there's a newer one out that is still for it'll actually update to the newer one. So package locks are kind of their own beast. And I can't really cover that in this video. It's a little bit out of the scope of this. If you really want me to, I do have an older video that I'll link in the notification that kind of covers package lock a little bit. But if you want me to recover it or refresh it and do some new stuff, just let me know in the comments if you're really interested in that. So going back to this, this is one way that we can look up our version. But we can also do a really cool command here where we can do npm ls. And that will actually list out all of our packages that we've manually installed, not their dependencies, unless you use a flag. Let me show you that real quick. If you do dash dash depth, you can do equals and you can pick the depth. So in this case, with depth of one, we'll show all of the immediate dependencies. And if we were to do depth of two, it kind of gets a little crazy and so on and so forth, dependencies of dependencies and all that. So let's go back up to the root one. Now, if you do npm ls, you can see that and it's it's going to list out the actual version that you have installed, not the one that you picked. Okay. Sometimes that's confusing to people. And why it would differ is depending on if you use the care or the tilt, which we're going to get into. But for now, you can also just really quick. So you know, there's an alias npm list, if that makes it a little bit easier. You can also do this, though, you can do npm view, which is really interesting. And if you pick a package, you can do inquire. And this is one that's like, let's say it's not even installed, I'll show you that it will list out a lot of interesting stuff about it. So you'll notice that when we do this, it says inquire 812, that's typically going to be the most current version. So we're all the way back on 720. Right now, it'll give you some keywords. And it will also like give you some information here, I don't think I should go over that right now. But the important part is that it will list out the dependencies, which is really useful and the lovely maintainers who keep this project going, of course, thank you to all of them. And then finally, it'll have a tag. And this is where at latest will come into play a little bit later on. So keep that in mind for now. So jumping back to our example, that's how you can view a package and kind of see what the latest version is and all that stuff. What I'm going to do is go into here and our project and do index.js just to create a quick little entry point. So to save some time here, I'm going to paste in some code that I've already done. And I'm going to walk you through it really briefly. But if you've never used inquire before, we're just going to import it here. And of course, this is a require syntax and not import syntax, because I'm just trying to make it simple for this current version of node. We you could do it the other way, if you want. We have an inquire, we have a prompt command that you're going to chain onto it. And essentially, what that's going to do is prompt the user for something, you're going to pass it this like array of objects of all the things to prompt them in order. And there's a different way to do it. But we're gonna stick to this one. And then the highlights are that you have the type of prompt that's going to be displayed as you have the name of it, which you're just going to use to keep track of it, the message that you'll show to the user, which you'll see in a moment. And then the choices, which can be a few things, we're going to do an array of strings. So I'm asking them to choose their character class. And then I'm going to give them this list of options. And then after that, I'm going to give them a checkbox version to choose exactly two proficiencies. Okay. And then finally, at the end, it's a promise so you can chain onto it, don't worry about this for now. And you can log out the answers and you can catch an error. Okay, if you don't quite follow all that, that's perfectly fine. You'll see an example. I just thought you might want to know kind of a little bit about what's going on. So what we'll do is we'll do node index dot j s to run the program. And you'll see that the program has a nice little prompt for that little bit of code, which is really cool. And we can kind of arrow down through this. And what I want you to pay attention to is that it's looping through all the list. And so this is pretty cool right off the bat. Well, let me get into that in a moment, actually, let's just pick the options now. So I picked Druid. And then right now, I can pick, you know, one option and press enter. And it'll wait a couple of seconds in the code. That's what I've programmed. And then it's going to say, please choose exactly two proficiencies. And so I'll do sure, I'll do two of them. I'll just show you that if I do three, it'll still won't allow that. There you go. So go back to that takes a couple", "metadata": {"title": "Understanding Semantic Versioning with Real World Examples", "url": "https://www.youtube.com/watch?v=1zBzkT7QCmA"}}, {"page_content": "go. So go back to that takes a couple seconds, and then it prints it out. It's a really, really simple program, you could do whatever you want from there. But that's not the purpose of this video. What is the purpose is semantic versioning. So remember how I mentioned that that program loops, let's run it one more time and see that. So the program loops through and if someone's not really familiar with this, it might be confusing, you might be going through and being like, wait, did that loop that I already see this one, it's sometimes it's kind of nice in some programs to for the list to just end. So we've been wanting this for a while. And then through a blog or a friend or however you figure this out, we learn that inquire has a new feature, where you can pass a special little property that makes the loop the list not loop, that was hard to say. Now let me show you that in their docs real quick. So if you go to inquire right now, this is the latest version, which is ahead of where we're at. But if you type loop, you'll see that there is this loop option. So this is current, but let's go back in time for just a moment here. If you go over to the repository, and click this. And what's cool about this is there is a releases section in GitHub. And this is up to the maintainer to, you know, keep this updated with information or whatnot. But a lot of the big projects will have something like that. So this is the current version, let's scroll down and go to the next a couple of times to go back to back in time to where we are. Pretend that we're in current time. And 720 was the latest. Here we are at 720. And then all of a sudden, let's go back one. And there's a 730 out now remember, that's a minor, the three, and they have a new loop Boolean for list types. This prevents the list from looping when reaching the top or bottom of the selection. That sounds pretty interesting. So let's upgrade to that. So if we go to our terminal, I can do npm i inquirer. And I could do at and then I'll say that example exactly. So 730 we did 720 before. Another way that you could do it just so you know, is you could go into your package JSON and you could like manually change this to a specific version. But I usually prefer to use the command line. I think it just does a little bit better job. That's up to you. You can play around with however you like. Sometimes the versions are a little bit finicky and how they work. But once you mess around with them a little bit, you'll get the gist of it. So I'm gonna install 730. And just so you know, as a quick little hint, remember how when I installed 730, it automatically did this little up caret that says it'll upgrade to whatever version, as long as it's not a breaking change, you can actually do dash dash save exact as a flag. And check this out. When I go back over to here, it did not put that. So if you really want to stick to one version, I usually don't recommend that. But there are times when you do want to do that, then that's how you would accomplish that through the command line. Let's undo that. Let's just do this. If we do NPM LS, just as kind of a habit, you could see that that's the version that was installed. So now we can go back into our code. And we can add this little flag here because we got a new feature. And we'll say list no loop. Nice. False. I don't do the same on both. False. And then what we'll do now that we've done that is let's just try to run the program and see if it worked. So if I press up, it doesn't go up, which is good before it would. But now if I press down, oh, that's interesting, isn't it? It gets to the very bottom, but it still shows the rest of the list, which I guess is okay. You know, it doesn't let them move on, but I feel like it's still a little bit confusing, right? So we'll say, all right, feature works as intended. Let's check this next one out. What happens here? Oh, this one just like keeps looping. So it didn't even work for the checkbox type. Let's pick our two, you know, close our program. So what's interesting about this is whether this is real time or not, what's kind of going on here is they have implemented this, but they have a bug in it. Okay. And this is super common. So if they have a bug and they want to fix it, but it's going to fix an existing feature, but not create a new feature, what should they do? What should be the version? Well, that's where a patch comes in, right? If we go over here to the previous step, this is going ahead in the future. We have a 731 and a 732, and you'll look at the 731 for now, and it says, fix the loop false option in the list prompt. Okay. So here's what we could do. This is where I'll show you the patch only version of installing something, which is kind of interesting. We can go over to here and install this program once again, and just install this patch just to see. Now we install the patch and then we'll run the code again and we can't go up. So that's still working fine. But when we get to the bottom of the list, look, it doesn't show the rest of the stuff. So that's an effective patch. It actually fixed it like that. And then if we come back to here, Oh no, it didn't actually work for this. You know, they only fixed it for the one thing, unfortunately. Well, let's go back to that because we did see that there was another patch after it. And it says, fix the loop false option in the checkbox prompt, which we just so happen to have that problem in. So let's bump one more time. And in fact, in this time, I'm going to do a tiny bit different just to show you a different way. If you use this tilde, a little squiggly character here, and then you say, I'll even do 7 3 0. What this is going to do, you'll see is after installed, if we do NPM LS, notice that we said, I want 7 3 0, but it did 7 3 3. And if we look in our package JSON, you'll see that that little tilde characters there. So this is a special little character. You won't see it too often, but every now and then you will. That means only update to the highest patch version. Don't update to a minor. So at this point, it's determined that of all the packages that exist right now in time for this, that are not above a minor of three and not above a major of seven, there is a 7 3 3 is the highest version. You notice it doesn't list it here. That's the thing I mentioned. That's kind of confusing to people sometimes because this is your target. This is saying, this is what I want. Roughly. I'm okay. If you give me any number here for this patch version, and that's what we got was 7 3 3. Okay. So let's run the program again, go down to the bottom. Cool. See, it starts at acrobatics. Oh, look at that. It actually fixed it. Cool. Boom, boom, boom. Wait a couple of seconds, which will matter in a moment. And there you have it. So that's an example of showing, um, we did a minor bump and what we could conclude from that if they did their job, publishing the package properly, you know, bug slip in sometimes. So that's how it goes. But with the minor bump, uh, it's just going to be a new feature. So that's, we did a minor bump so that we could get this access to this new property. Right. And then we had two patch bumps that we needed to do in order to fix these bug fixes.", "metadata": {"title": "Understanding Semantic Versioning with Real World Examples", "url": "https://www.youtube.com/watch?v=1zBzkT7QCmA"}}, {"page_content": "So going back to this, um, this is one way that we can look up our version, but we can also do a really cool command here where we can do NPM LS, and that will actually list out all of our packages that we've manually installed, not their dependencies, unless you use a flag. Let me show you that real quick. If you do dash dash depth, you can do equals and you can pick the depth. So in this case, with depth of one, we'll show all of the immediate dependencies. And if we were to do depth of two, it kind of gets a little crazy and so on and so forth, dependencies of dependencies and all that. So let's go back up to the root one. Now, if you do NPM LS, you can see that and it's going to list out the actual version that you have installed, not the one that you picked. Okay. Sometimes that's confusing to people. And why it would differ is depending on if you use the care or the tilt, which we're going to get into. But for now, um, you can also just really quick. So, you know, there's an alias NPM list. If that makes it a little bit easier, you can also do this though. You can do NPM view, which is really interesting. And if you pick a package, you can do inquirer. And this is one that's like, let's say it's not even installed. I'll show you that. Um, it will list out a lot of interesting stuff about it. So you'll notice that when we do this, it says inquire eight one two, that's typically going to be the most current version. So we're all the way back on seven, two zero right now, it'll give you some keywords. And it will also like give you some information here. I don't think I should go over that right now, but things important part is that it will list out the dependencies, which is really useful. And the lovely maintainers who keep this project going, of course, thank you to all of them. And then finally, it'll have a tag. And this is where at latest will come into play a little bit later on. So keep that in mind for now. So jumping back to our example, that's how you can view a package and kind of see what the latest version is and all that stuff. What I'm going to do is go into here and our project and do index dot j s just to create a quick little entry point. So to save some time here, I'm going to paste in some code that I've already done. And I'm going to walk you through it really briefly. But if you've never used inquire before, we're just going to import it here. And of course, this is a require syntax and not import syntax, because I'm just trying to make it simple for this current version of node, we you could do it the other way, if you want, we have an inquire, we have a prompt command that you're going to chain onto it. And essentially, what that's going to do is prompt the user for something, you're going to pass it this like array of objects of all the things to prompt them in order. And there's a different way to do it. But we're gonna stick to this one. And then the highlights are that you have the type of prompt that's going to be displayed as you have the name of it, which you're just going to use to keep track of it, the message that you'll show to the user, which you'll see in a moment. And then the choices, which can be a few things, we're going to do an array of strings. So I'm asking them to choose their character class. And then I'm going to give them this list of options. And then after that, I'm going to give them a checkbox version to choose exactly two proficiencies. Okay. And then finally, at the end, it's a promise, so you can chain onto it, don't worry about this for now. And you can log out the answers and you can catch an error. Okay, if you don't quite follow all that, that's perfectly fine. You'll see an example, I just thought you might want to know kind of a little bit about what's going on. So what we'll do is we'll do node index dot j s to run the program. And you'll see that the program has a nice little prompt for that little bit of code, which is really cool. And we can kind of arrow down through this. And what I want you to pay attention to is that it's looping through all the list. And so this is pretty cool right off the bat. Well, let me get into that in a moment, actually, let's just pick the options now. So I picked Druid. And then right now, I can pick, you know, one option and press enter. And it'll wait a couple of seconds in the code. That's what I've programmed. And then it's going to say, please choose exactly two proficiencies. And so I'll do sure I'll do two of them. I'll just show you that if I do three, it'll still won't allow that. There you go. So go back to that takes a couple seconds, and then it prints it out. It's a really, really simple program, you could do whatever you want from there. But that's not the purpose of this video. What is the purpose is semantic versioning. So remember how I mentioned that that program loops, let's run it one more time and see that. So the program loops through. And if someone's not really familiar with this, it might be confusing, you might be going through and being like, wait, did that loop? Did I already see this one? It's sometimes it's kind of nice in some programs to for the list to just end. So we've been wanting this for a while. And then through a blog or a friend or however you figure this out, we learned that inquire has a new feature where you can pass a special little property that makes the loop the list not loop. That was hard to say. Now let me show you that in their docs real quick. So if you go to inquire right now, this is the latest version, which is ahead of where we're at. But if you type loop, you'll see that there is this loop option. So this is current, but let's go back in time for just a moment here. If you go over to the repository, you can click this. And what's cool about this is there is a releases section and GitHub. And this is up to the maintainer to, you know, keep this updated with information or whatnot. But a lot of the big projects will have something like that. So this is the current version. Let's scroll down and go to the next a couple of times to go back to back in time to where we are. Pretend that we're in current time and 720 was the latest. Here we are at 720. And then all of a sudden let's go back one. And there's a 730 out now. Remember that's a minor, the three. And they have a new loop Boolean for list types. This prevents the list from looping when reaching the top or bottom of the selection. That sounds pretty interesting. So let's upgrade to that. So if we go to our terminal, I can do npm i inquirer. And I could do at, and then I'll say that example exactly. So 730, we did 720 before. Another way that you could do it just so you know, is you could go into your package JSON, and you could like manually change this to a specific version. But I usually prefer to use the command line. I think it just does a little bit better job. That's up to you. You can play around with however you like. Sometimes the versions are a little bit finicky and how they work. But once you mess around with them a little bit, you'll get the gist of it. So I'm gonna install 730. And just so you know, as a quick little hint, remember how when I installed 730, it automatically did this little up caret that says it'll upgrade to whatever version, as long as it's not a breaking change, you can actually do dash dash save exact as a flag. And check this out when I go back over to here, it did not put that. So if you really want to stick to one version, I usually don't recommend that. But there are times when you do want to do that, then that's how you would accomplish that through the command line. Let's undo that. Let's just do this. If we do npm ls, just as kind of a habit, you could see that that's the version that was installed. So now we can go back into our code. And we can add this little flag here because we got a new feature. And we'll say, list, no loop. Nice. False. I'm gonna do the same on both. False. And then what we'll do now that we've done that is let's just try to run the program and see if it worked. So if I press up, it doesn't go up, which is good before it would. But now if I press down, oh, that's interesting, isn't it? It gets to the very bottom. But it still shows the rest of the list, which I guess is", "metadata": {"title": "Understanding Semantic Versioning with Real World Examples", "url": "https://www.youtube.com/watch?v=1zBzkT7QCmA"}}, {"page_content": "the rest of the list, which I guess is okay. You know, it doesn't let them move on. But I feel like it's still a little bit confusing, right? So we'll say, all right, feature works as intended. Let's check this next one out. What happens here? Oh, this one just like keeps looping. So it didn't even work for the checkbox type. So let's pick our two, you know, close our program. So what's interesting about this is whether this is real time or not, what's kind of going on here is they have implemented this, but they have a bug in it. Okay. And this is super common. So if they have a bug and they want to fix it, but it's going to fix an existing feature, but not create a new feature, what should they do? What should be the version? Well, that's where a patch comes in, right? If we go over here to the previous step, this is going, you know, ahead in the future, we have a 731 and a 732. And you'll look at the 731 for now. It says fix the loop false option in the list prompt. Okay. So here's what we could do. This is where I'll show you the patch only version of installing something, which is kind of interesting. We can go over to here and install this program once again, and just install this patch just to see. Now we install the patch, and then we'll run the code again. And we can't go up, so that's still working fine. But when we get to the bottom of the list, look, it doesn't show the rest of the stuff. So that's an effective patch. It actually fixed it like that. And then if we come back to here, oh no, it didn't actually work for this. You know, they only fixed it for the one thing, unfortunately. Well, let's go back to that, because we did see that there was another patch after it. And it says fix the loop false option in the checkbox prompt, which we just so happen to have that problem in. So let's bump one more time. And in fact, this time I'm going to do a tiny bit different just to show you a different way. If you use this tilde, a little squiggly character here, and then you say I'll even do 730, what this is going to do, you'll see, is after it's installed, if we do npm ls, notice that we said I want 730, but it did 733. And if we look in our package json, you'll see that that little tilde character is there. So this is a special little character. You won't see it too often, but every now and then you will. That means only update to the highest patch version. Don't update to a minor. So at this point, it's determined that of all the packages that exist right now in time for this, that are not above a minor of three and not above a major of seven, there is a 733 is the highest version. You notice it doesn't list it here. That's the thing I mentioned that's kind of confusing to people sometimes, because this is your target. This is saying this is what I want, roughly. I'm okay if you give me any number here for this patch version. And that's what we got was 733. Okay, so let's run the program again. Go down to the bottom. Cool. See, it starts at acrobatics. Oh, look at that. It actually fixed it. Cool. Boom, boom, boom. Wait a couple seconds, which will matter in a moment. And there you have it. So that's an example of showing we did a minor bump and what we could conclude from that if they did their job publishing the package properly. You know, bugs slip in sometimes, so that's how it goes. But with a minor bump, it's just going to be a new feature. So we did a minor bump so that we could get this access to this new property, right? And then we had two patch bumps that we needed to do in order to fix these bug fixes. If we go back to this just one more time, and we go previous, there's going to be one more. You'll see 733 before 800. Okay, so this is the highest patch and minor version that exists. Okay, another way that you could do that without actually going to the repo, though, is you can do npm view, and you can do shorthand for this. It's V. And then you could do inquirer. And you can do versions. So view versions. And what that will do is print out all the versions. So in case you wanted to see what ones exist, you know, just through the command line, you can do that, which is pretty neat. So 733 is our latest. You can also do the same thing and do dash dash JSON. Some people prefer this because it always prints out the full list. And it's in this kind of single column list format. But I usually do this since it's a little more truncated, it just depends. Now how you actually discover these new features is sort of a Pandora's box to a degree, it really just depends. You might be subscribing to some sort of service or blogs or Twitter or whatever it is that like, you know, kind of gives you some sort of notifications of new features or whatever. You might just hear it. Or what happens commonly is you'll do some sort of package bump for some reason. And you'll notice that it bumped up a version and then you might want to go read about Oh, why did it do that? You know, what's in the new version, I don't really have a better way to keep on top of packages. So if anyone does have any suggestions, go ahead and show it in the comments, and we'll be grateful. But I just wanted to show you that like what it means the patch and the minor. And now we're going to move on to a breaking change example. So if we go into this code here, we'll notice that inquire eight doesn't give us a ton of information on what happened. But it does say that it drops support for node 10. Now this is a really common reason to be a breaking change. All right. So I'm going to show you an example real quick of upgrading to eight on an older node version to show that not working. So right now I'm using MVM, you might not be able to follow along here. If you're only installing one node version, you don't have a version manager. That's okay. You can see it through here. But if you wanted to follow along probably easiest to use a version manager like nvm or n. So right now I'm currently on 1415 one. All right. Now what I'm going to do is MVM use, and I'm going to do 8.17.0 because I have that installed. All right. Now I'm going to have to reinstall these packages at this point. And it should run fine. If I were to run this again, because I haven't upgraded just yet, just to show that. Okay, so currently all my stuff is supported. You notice that I don't get the syntax highlighting here, which is kind of interesting. So I wonder if they added that in a newer node version. Now why someone might, you know, do this right here, which is drop support for a node version, because when new features come out in node, you know, sometimes you'll keep deprecated, which means you'll keep the functionality, but you'll have to add some extra code for like background support while you upgrade. And eventually, what deprecated means is that you're going to stop supporting that at some time in the future. So if you ever see that deprecated message, that's what they're saying. They're like this, I'm going to drop support for this at some point in the future. So if you update your package, expect that you might lose that and you probably want to get ready for that sooner rather than later. Now, because node 10 would have a bunch of new stuff from the old node version, they might want to just use that stuff natively. And eventually, you know, everyone kind of needs to stay current. So that's why they might do that. Just a real quick summation. So let's update to eight. Okay, so npm i inquirer at eight.", "metadata": {"title": "Understanding Semantic Versioning with Real World Examples", "url": "https://www.youtube.com/watch?v=1zBzkT7QCmA"}}, {"page_content": "Let's actually just do latest. Okay, so you can see that tag. So you can actually do at latest. And that will do if you remember, now that install, if you do npm v, oops, npm v inquirer, why can't I type ever, you'll see this disk tag latest, this is really common way to just install whatever they have flagged as the latest version. So this will give us 812. Okay. And if we do npm ls, it'll list them all out. Oh, I wonder if an older version of node, it doesn't actually truncate those. That was kind of interesting. Well, either way, let's try to run our program. node index dot j s. And you'll notice that we immediately just get some sort of error when we try to do it. Okay, looks like they're using this catch block here. And it says unexpected token this brace. So we probably didn't have that type of functionality, we can guess from an older version of node. So what we need to do is upgrade our node. My case, I can just switch to 1415. One, right, I'll install once again. And then I'll do node index dot j s. And my program works just fine, right? Bing, Bing, Bing. Now, what's cool about that is, did you see that little loader? Wasn't that neat? So this is kind of an interesting example. I should have explained this a little bit beforehand. But I think this showcase it fine, showcases it fine. So if I pick, you know, druid, I want to be a druid. And let's say, of course, as a druid, I want to be proficient in animal handling, and acrobatics, why not. So I'm going to pick these two options. And look what happens when I press enter, you see that little loading spinner, we didn't use to have that feedback. And so this is sort of an example of at some point, let's find that. If you go back, now displays a loading spinner while asynchronously filtering over validating data. Cool. So this is an example where you want to upgrade to a major version, because there's a new functionality, we really want that loading spinner. That's awesome. But it's a breaking change, right? And so we would have to kind of figure out, all right, well, what is, you know, what's the breaking change here. So the best way to do that is to look for where the actual major bump happened. And in this case, it's going to be the first time after seven, since we're on seven something, we move that that first number up to eight. And so that's where they're going to just list any breaking changes, if they're maintaining the package properly and documenting it. Sometimes there'll be other ways that they document how to deal with a breaking change. If it's a major version, it might be in a post of theirs, if you just search it up, might be in the readme, if it's brand new. But a lot of times, if I don't find it really easily, this is where I'll look. And again, that's if you go to just the plain old repository from npm or whatever, there's a releases tab here on the right, it might be different in the future, but usually just look for releases. And then you can go find that specific release. So that's one example of a breaking change. It's a really common example, where the node version updates, but really, all you had to do was update your node, right? Node version. Let me show you one more example of a breaking change that actually forces you to change your code. Okay, so fast forward through time real quick. And I've created a quick project here, just to speed things up. That's very simple. And it's using this package chalk, a lot of you will be familiar with it. It's a console dot log printing solution that will color your logs with different awesome little colors. Okay. If you look at my package JSON, I only have that one installed. And I'm starting at 113. All right. So I'm going to show you this program. But to briefly walk through it, I have a print method that I'm using. And really, all this program is doing is you can normally do chalk dot magenta to print out a magenta text, which you'll see in a moment. And then I also have one that just prints out this prints out this like generic thing. So let's say I'm like logging a bunch of stuff, or whatever it is. And I want to be able to color things differently with chalk. What this print thing does is it uses this chalk has color method to see if the text is colored. And if it is, if it does have a color, it will just print it out the way that it is, else it'll make it green. That's it. So let's go back to the terminal here. And in this project, you'll see that in the first example, I print out purple, magenta, and then the second one I print out green. And that's exactly what I expect when I look at the code here. So I decided there was a color, keep the color. Otherwise, if I didn't give you a color, make it green. It's pointless, but it'll illustrate the point. So now let's actually go and look at the chalk npm package. Chalk. We can go to this package, we'll go to the repository for this point, go to releases, they're already all the way up to 4.1.2. So we're really behind at this point. But releases, I clicked on 4.1.2, I actually need to click release, sorry, all of them. This is a really awesome project, they document it super well. So you know, so this is I wanted to show this because not only the code version of a breaking change, but just the maintainers of this are awesome. Okay, so what we'll actually do is we'll go back to one more, sorry. And we'll find two. So here's a major change. They have this awesome gif and everything. And this is the really awesome moment where chalk introduced true color support, which is really, really fantastic. You'll see, I'll give you a quick little demo of it. But the point of it is that one, we want this new feature, we want this like tons and tons of color range and all that type of stuff. And I'll show you that in a moment. But what they do is they list breaking changes here. I love this. And so with this breaking change, you can look through and it requires no JS for so pretty common what we just experienced. But also they removed chalk dot has color. And we were using that. And that's really unfortunate for us, right? So let's show you that breaking our code real quick. So we're gonna bump this up here, we're gonna say npm I, I'm gonna install chalk. And but we're going to do that at two dot o dot o, let's say, I really could just, you know, do whatever range. In fact, let me show you this. There's one more command that you want to know. So you actually can use this little up carry Chevron here to say, how about go ahead and grab me anything as long as it's not above three for a major version when I install it. Okay, this isn't going to work for me, just so you can see, this is a common problem with ZSH and some other terminal shells, where what it's like thinking that it's some sort of matcher here. So what we're going to do is we're going to escape that character. If you ever had that problem, that's all you have to do. And that'll work. So now when we do npm ls, you'll notice that we didn't install two o o like we normally would have if we left that off, we'll actually install two for two. So we're saying, hey, I want the latest version, as long as it's not higher than two. Cool. So now let's run that program again. It breaks, right? So chalk has color is not a function. Sad. Okay, well, let's go back to the docs. So they did tell us that. So let's kind of like simulate that we're in the real world. We heard there's true color support. And we're like, yes, give me that now. And so you go and you install that and then you get this error. So what I would do is I would go and first I'd try to like search up the error real quickly. If I don't find anything fast, I would go right to the repository and look at the versions and be like, okay, so I've got like two, version two or whatever, I'm gonna immediately go to where the breaking change happened. Because that's where the break should be. Not promising it always is. But it's where it should be. And it's the fastest place to look. And then here, you know, if they're nice, they listed it out. Oh, cool. Use the has ANSI package directly instead. I love it. Okay, so I'll click that they even give us a link. How cool are they? And when you come into here, there's this package and I'll be like, all right, well, I guess it looks like I can just call this now. So let's try it. So I'm going to do npm install has ANSI. I'm going to go over to my code. And I'm going to import that. So const has ANSI equals require has ANSI. And then I'm going to switch out this chalk has color because that's the thing that's broken for just has ANSI and see if it works. This is really how I develop things. Sorry if it's disappointing to you, but that's my mood. Okay, that didn't work. Unfortunately, must use import to load an ES module. Oh, that's really unfortunate. So we're using CJS right now. And they have this as import. So it looks like their current version is actually only supporting ES modules, which leads you down in a whole nother rabbit hole. So let's see what version that we got installed for them. Let's do a real world thing here. So npm ls, we have 500. Okay, so let's go to their versions and see, okay, require nodejs 12. This package is now pure ESM. Wow, we got lucky there, right? So maybe if we go back to four, we'll be fine. Right? So let's do this. npm i has ANSI at and then I'll let it be anything for so for 00. Four and up is fine with me. npm ls. Yeah, we're good. Let's try it now. And it worked. Look at that. That was real world. That wasn't planned. But pretty cool. So you can kind of see that in action. It's like, oh, well, things are crazy. And obviously, I had a little bit of knowledge about the ES modules thing. So I kind of knew where to look. But the point is that I can look at what version that I'm at currently with this npm ls, I can be like, Oh, I've got 50. Let's see what the breaking changes and that will lead you down the you know, trail of breadcrumbs to find what your problem is. It works for me a lot of times. Sometimes it doesn't. But you know, you got to have a lot of tools in your belt to solve these kind of problems. So this fixed our problem. And that shows a breaking change that you know, we wanted a new feature. Let's actually add that new feature real quick because you know, what's the point of doing the bump? Let me show you this. So I'm going to do an extra thing here. And I'm doing some crazy stuff. But really, what I'm trying to show here is that they have this like level that they added for different levels of color support. So in this case, it's like no colors. This is 16 colors, which is what they had before this version two oh, and then this is 256 color support, which is kind of common. And this is true support true color support, which is like 16 million. It's some crazy stuff. Now you're going to see the actual difference because notice that I'm logging the exact same color in all of them. Just to kind of show this, watch this is cool. Check this out. So this is true color, right? This is the actual color if we were to like hex it and you know, take that color and put it in the other browser. That's what it would look like. But you can see that it kind of like tries to pick the nearest one that it supports when it's only 256 colors. And then when it's 16 colors, it's not really even close, unfortunately. So this is the strides that they've made just to kind of showcase that this is the new feature that we wanted. So we wanted this feature and we had to install a breaking change to get it and then it broke our code. And so we had to go and look and see, okay, at least they documented that has colors not supported anymore. How can I find that out? And they were nice enough to give us a link to that has color package or has ANSI package. That's what it is. So now you've seen a breaking change. That's a simple node version bump, which is really, really common and also a breaking change, which is a code change. Now, as you've been seeing all of this, I hope that in the back of your mind, you're kind of starting to see how to actually develop software in a cool way. Like notice how nice it was for us to know and be notified that, hey, when you want to get this feature, you're going to actually have some breaking changes. Make sure that you check and see if you have to update your code. Sometimes you won't. And a lot of times you will, but they should have some documentation around that. And so now when you're developing software throughout your career, I hope you'll think about that pattern. There are other patterns out there, of course, but this is at least a nice one that has some sort of structure that says, when you write code, when you make a change, you have to think about your users. Am I going to break their stuff? I probably shouldn't do that right away. You know, let's make this a patch if we can. Let's make this a minor if it's a new feature and not put any breaking changes. Or if we really have to, if we feel like it's just too much work for us or we want some new functionality or whatever it is, there's a lot of reasons for it, we'll make a breaking change, but at least they'll know that it's that and we should document it. We should be the cool developers that let them know, hey, if you want this new feature, just so you know, you might run in these things, we broke these things. It is a breaking change, which means that your code might have to update or you need a new node version or something like that. Really, this just helps you become a better, more robust software developer by just learning how this thing works, semantic versioning, and incorporating that in how you write code, especially if other people are using your code and consuming packages and all that. But even if you're not using packages, I think it's a still a good way to deliver code in general. You know, you can document it however you want. But the point is, you selectively always think when you make code updates that anyone's going to use, you know, what kind of changes this? Is it just a little bug fix? Is it a new feature? Or does it actually break some existing code if people use it, and we should notify them? I believe that will sum up this video. I hope that this practical example of some larger used packages that, you know, are used by tons and tons of developers every day was a useful tool in seeing exactly how they distribute their packages and how you can go about troubleshooting breaking changes when you encounter them. But maybe even more importantly, while you're here, you get the gist of semantic versioning and what those little numbers mean, and the couple little special symbols in front of them. Thanks for watching, and I hope to see you in the next one.", "metadata": {"title": "Understanding Semantic Versioning with Real World Examples", "url": "https://www.youtube.com/watch?v=1zBzkT7QCmA"}}, {"page_content": "Welcome to Swashbuckling with Code. I am Jimmy Cleveland, and today we're going to take a little tour of one of my favorite productivity apps, Notion. So Notion is a little bit difficult for me to describe exactly what it does. It's a note-taking app, but it does so much more than that. It uses a general collaboration tool, kind of an all-in-one place for your onboarding, your wikis, task management tracking, and Kanban boards, all sorts of stuff like that. It's just a really powerful tool, and the way that they've done it and designed it is just very intuitive, easy to use, low barrier to entry, and really quick just to kind of jaw ideas down and then build them up into more sophisticated, organized documents, and I really love that about it. So I've been using it for quite some time now, and it's not quite as popular as I really feel like it should be. I've seen it grow in popularity recently, and some people talking about it a little bit more, but usually when I show it to people, they've either never heard of it or maybe kind of heard it but hadn't looked at it. So I thought that I would just give you a little tour of what it's like and some of the basic functionality of it and how I use it. So as you can see, here we are. We're on the Notion home page. It's notion.so. For some reason, I always think it's notion.io, but that is not correct, and you know, I haven't seen this page in quite some time since I just have the app installed. I'm just going to take a quick browse at it. It looks pretty nice, and it looks like they show some of the functionality of it. So, you know, you might want to take a look at that. Oh, Duolingo uses this, huh? Cool. And, well, yeah, yeah, yeah. Neat. It's a long page. All their tweets from people just loving it. Yeah. So let's go back to the top, and, you know, I'll log in here and show you kind of a new account. And let's jump right over to that. So after you log in, you know, this is the dashboard that you're going to see. I'm using the web client, but they do have a app, you know, Windows, OSX, and I would imagine Linux, but I'm not positive about that. So they'll start you off with some, you know, different pages to kind of show you what to do or how you can use it, but I don't think they're the greatest intro. Personally, I looked through them, and they're just kind of like, okay. So I'm just going to show you probably starting with just creating a new page. I think that's the best place to start. So I want to make a new page here, and pages are pretty much, you know, it's like your top level note, but they can be nested. So you'll start off with this blank page, and you can put whatever title you want here. So our page, you put whatever you want here, of course, and then as soon as you press enter, you know, all of that information is going to go away. You get this nice clean look. So they tell you type slash for commands. This is what I use most of the time. So you can type slash, and you can get a whole slew of commands, but it also accepts markdown. So let's start with that. So if you do pound, space, you'll get a heading one, that nice placeholder telling you that's what you've got. And I will just type some heading, and I want to show something right here. So if I were to do pound, pound, and you know, heading a second time, this is something that is a small deal, but there's a bunch of these that all add up to a great user experience. So if I come to the beginning of this, and I type pound, pound, space, it will just auto convert it. And that's really cool. This was really sweet to me because Notion's one of the few tools that I've ever used, where it is very intuitive. It's a rare experience for me that, you know, I'm using a tool and I'm like, wouldn't it be cool if I just did this and it worked. And it does quite often this tool, the people making it just are really in tune with a good user experience for very simple, quick note taking. And it does a lot more than that, we're going to get into that. But let's just start, you know, with these basics for now. So typing regularly, you get a paragraph, you can do all the markdown stuff like star or dash, do a list, you know, if you type first item, and then you press enter, you know, you're going to get your next list, etc, etc, etc. You can press tab to indent it, another indent, etc. That's a lot of etc. And then you can move these blocks around with this little series of six dots, you drag that, and you can move like this whole item because it has nested items wherever you like. And what's really cool about that is like, let's say we've got this item, and I want to nest that here, you can see how it's got that like semi transparent blue underline and then the blue underline, that will tell you that you're nesting it there. So if you want to put it here, yeah, you get to just put it here, put it wherever you like. That's really cool. And it's a nice way to just move things around. And from there, you can take you can click it, which you know, it says drag to move or click to open menu. If you click it, it'll bring up a nice little quick menu that lets you do all sorts of things. So we can duplicate it, for example, it's really easy, we can delete it. And we can also turn it into something. This is one of the coolest functionalities that I like about it a lot is you know how I showed you you could do the pound pound to convert it. There's a bunch of different ways to do that. But this is a really nice one. If you just don't really know what your options are, you can come to here and say, Okay, well, I want this to be a code block, let's say, here you go. It's opened you up a code block, this time, it's JavaScript. So it will actually have syntax highlighting. So if you were to say const, mu equals cow, there you go. You got that. It's lovely. It's got a bunch of language support, it even has GraphQL, which a lot of the WYSIWYG type of things that I've used that have code blocks with markdown don't have that yet. So they stay pretty up to date. You got rust, PHP, Ruby, all your favorites go. It's really cool. Really, really nice. I like that. And let's say we were to take this, this code block here, and we wanted to turn it into something else, you know, we could turn it into this call out. And this is kind of an interesting thing, it gives you a little icon. So let's say you had something really important to put here, then you have like documentation, you're writing because you can use this thing. It's like a wiki. It's a collaboration tool, you can use it for yourself, you can use it for a group of people. I use it at my current work with some of my team, and we really love it. But you can do stuff like this, just little call out notes, give it your own icon. It's really nice. So that's, that's the idea of turning things into other things. There's a whole slew of them. Let me show you a few more of the things before I get into that menu. So you can do a quote. This one's kind of weird, because arrow usually gives you a quote, but this one actually gives you a toggle. So if you do that, and then you can put whatever you like here. And this is just nice if you want to be able to hide something, right. But if you want to do a quote, you got to do a slash quote. No big deal. There's probably another shortcut, but and then this will just give you some sort of quote situation, some quote situation. And while I'm in a quote, it's probably a good time to talk about the text editing. So what is this type of menu called? I don't actually know. But when you double click the text, it will come up with a familiar, you know, WYSIWYG type of thing. And you can bold, underline all the good stuff. This is a really neat feature, you can comment. And so when you go to add a comment, it's like adding a discussion for other people that are in the same thing. So you could say, let's take a look at this and then you can add someone in the comment. So I'm the only one here. So I could add myself or I could actually put a date and say, you know, this is maybe when we want to take care of it, or when we did it or whatever. And then it'll show up here on the side. And people can continue to add on to this as much as they like. And then if someone marks it resolved, it will go away. And if you mark all of them resolve, the whole comment will go away. So it's really nice, just quick way to address some situations. There's only a couple more things to show here. There's some crazy equation stuff that I never mess with. You know, I'm not a I'm not a math guru, sorry. But that's pretty cool. There's a you can change the colors to just a bunch of pre selected ones, nothing fancy, but it can be nice. It's just some some highlighting stuff like that. You get the gist. And you can add someone that's similar to the comment thing. You can just put someone's name here. Say we want to add me on this line. And then I'll get it in my notifications or whatever if I have feed turned on. And then finally, there's this little dot dot menu, which just gives you all of those that other menu if you click this thing right here. But this one is for this whole quote, and then this one might be for this text block. So that's that's the gist of how to do that. Turning into a page is kind of an interesting idea. I don't ever really use this. But I'm kind of curious now that I'm here at as a sub page, add to page getting started. So I'll add it as a sub page. And I'm guessing it's going to do the just slash page command. Can I link that? Yeah. OK. So how this works, that's kind of cool. And then you can give it an icon or something like that. So if you type slash page, this is a really nice feature of it. It will open up a new page. And we'll talk about templates in just a moment. But let's say nested page here. You press enter and start typing your gobbledygook here. And if you go to this our page, you can drill down this little menu and you'll notice that there is this like nested page here that came from our page. So we made this one and we made this one. And you can also see it in the breadcrumbs up here. So that's kind of how you do it.", "metadata": {"title": "Notion : Note-taking in just my style", "url": "https://www.youtube.com/watch?v=Xnoi_3x1u-g"}}, {"page_content": "navigate between them. It's really snappy. It's nice. You can just jump around that way. So that's a quick way to make pages. You can make it in the sidebar here, or you can just make it on the fly. And I love that functionality about it. It's really, really nice. Let's see, are there any other commands that we should talk about here? We should probably talk about embeds and such. So let's say that I want to go to Wikipedia. And I will grab a let's go to English, grab a random article here, just so you can kind of see. I don't know what this is. Let's see what this is Chinese ultralight trike. Very interesting. Okay. Copy that. And we'll drop that here. When you paste this, you'll get this nice little pop up that asks if you want to embed it or bookmark it. It depends on the kind of link it is. In this situation, I'm pretty sure Wikipedia leaks going to be the same for either. And I believe it uses a link. Open graph to pull any information and let's see if we can get something that has some images here. That looks kind of interesting. Let's, let's see what happens here. Create a bookmark. And that one's kind of crappy. Let's do like bridge. There we go. I don't know why I thought of that. Random thought in my brain. So yeah, it'll do this preview and you can see it as this nice little image in here. So you got your bridge now and you can move it around. You know, they're all blocks. That's the nature of it. And like I said, I think this uses open graph to pull in this stuff, but I don't really know for sure, to be honest. That's, that's the gist of that. And you can also move these, you can move any block to the side here and it will auto create a column. And you know, if there's too much information there, it will condense it. It's pretty neat that you can do that. And then let's say, we could get into images, but let me do this first. So what else is there in here that we want to talk about? So there's to-do lists and the to-do lists, you know, it's nothing fancy, except it's an actual to-do. So, you know, do the laundry. And then when you check it off, it actually stays checked off and all that stuff. So it's kind of stateful and that's cool. Nice little feature. So it's just kind of taking Mark down and, you know, making it a little more interactive and see bulleted lists, numbered lists, toggled lists. We went over all those, the quotes, the call out. Yeah, I think we're good on that. I don't really use these too much. There's an inline equation, which that seems interesting. More math stuff. Probably got some pretty cool stuff in here. There's tables, which I'm going to show you with a real example. Media. Yeah, it's probably a good time to do images, I would say. But then you can also see, you can embed like tweets and Google Docs and man, just so many things. It's really, really cool. So let's go grab an image real quick. Let's say I want to look up landscapes. Actually, let's go to Unsplash. And can I find just I want like a wider picture. Okay, I decided just to grab some ocean waves. That's nice. So I actually want the link here. Share. I wonder if that will download it. Let's go back to our page. Put this link in here. Okay, so that's a bookmark or an embed. So actually, we could try and embed here and see what happens. But I don't think that's what we want. Okay, that works fine. But we want the actual photo. So I'm just going to open I'm going to copy the image address and do that instead. There we go. embed image. Cool. So that way it will it will actually upload it to their servers, and it will keep a link to the original, which is pretty cool. So that's how you can drop in an image. And while we're doing that, let me show you that you can add it as cover art. So let's say we brought it up to the top here, and we kind of wanted to take full screen. Now, there's a whole nother menu here that I should show that you can do full width, we'll come back to the rest of the options in this menu. So you can kind of get there with this. But what you're actually going to want is to add a cover. So with covers, it's pretty cool, you can change them between a bunch of different types. They have some pre built images that are kind of nice. They got some like different art styles and all sorts of stuff. And then if you do, oh, there is a whole unsplash thing. That's pretty cool. Well, let's do our link first. And we'll submit that link. See if that works. There we go. That took a while. So there's that. And then we could change this cover as well. Let's use this unsplash. And I don't know how I never even saw that. There's some sort of cupcake thing here. We can do a search, we can do like ocean. And let's just click a couple of these. There you go. That's kind of cool. So yeah, we now we've got a sort of theme going, you can do an icon here, which I don't do that often. Let's see if there's like a wave. Yeah, like ocean wave here. And this, this is usually just kind of for a little bit of style, but it can be useful. So let's say like you have, you know, you've got like, some documentation or something like that. And you're like, Okay, well, let's just do you know, some sort of like bookmark or something like that. This will actually show up in your off screen here, which is kind of cool. It will be the icon of the page. And so if it's recognizable enough, this could be a nice thing. But most of the time, it's not really that useful to me. So just so that you know, you can do it, you can add comments here, which basically starts a thread at the top of this whole thing. So you know, it's it's just kind of like, let's discuss type of thing. And these are just kind of global. I also don't use this that often. I usually put comments like right on the thing, but it's there. It's just there's so many features, there's lots of features. And I don't use them all to be honest. So let's go back to the this top menu here. This is kind of cool. What you can do is let me go somewhere where there's a little more text, you can change the font style to be serif instead of a sans serif or a mono if you're doing kind of more like a code documentation thing or something like that. I like serif. But you know, take your pick. You can also make the text a little bit smaller if you want to fit some stuff. It only has these two sizes, like all you know, obviously all the headings have their own size, but it's just scaling them all down full width, which is very useful in some situations. The page lock, I don't really use that too often just to stop edits. And then yeah, you've got some typical, you know, favorites, page history, deleted. The last item here that's really interesting to me is this export. So I do use this sometimes where you can actually export to Markdown, which is super useful. Sometimes I'll write like blog posts in here, and then I'll just export it. And if it has images and stuff, it'll make links to the originals, it'll actually make the link tag for you and everything. So that's really nice. You can also do a PDF. And that's the gist of that. It'll just put out a zip file. So that's pretty much this menu in a nutshell. You know, you can play around with that as well. You can share this page, you can make it like public, if you want people to be able to see it, which is cool. It's already hosted. It's really nice. You can also invite people to collaborate. So if you have your own space, you can share certain topics with certain people. Or you could have one big group space, you do have to pay if you use over so many blocks, if you have a group of people, which is pretty standard, actually pay for my account, because I use this for everything. But, you know, for the longest time, I used it for free and got along just fine. They give you quite a few free blocks to get a really good feel for it and see if you like it enough. And it doesn't cost that much. So let me make a quick correction here. So I was looking it up, and it seems like they have unlimited blocks for, you know, the free accounts now. It's not just a certain amount, like I said, so that seems really cool. It's even better. So just wanted to clarify that. Yeah, then you can copy the link if you want to link it. And that's pretty much it. You can follow the page for updates. I don't usually do this either, but it's kind of cool that it's there. So I think that that's a pretty good intro to all of the basics of building a page. The next thing I want to show real quick is when you do make a new page, you can actually pick a template. So you can do these different various options. There's a whole table for database and calendar, and there's lots of cool things we're going to get to. The templates is really interesting because this is a good way to see some of the different types of styles that they have available. And the interesting thing about Notion is that you don't have to like start with a template to get that functionality. You can build it as you go and just insert pieces. It's got this really cool like modular component idea to it where everything is a composition of building blocks that you build up to the end goal. And what's really powerful about that is that it allows you a ton of flexibility, but it scales really well. This is my favorite thing about this tool is that it's very fast for me to jot down a note. There's no barrier to entry. Like I use Jira at my work, and Jira is great for having just tons of tracking functionality and all that stuff. But I know there are a lot of developers like myself that are very irritated with the bloat and the barrier to writing down notes quickly, especially when people have set it up in such a way that it can take a while to add a to-do.", "metadata": {"title": "Notion : Note-taking in just my style", "url": "https://www.youtube.com/watch?v=Xnoi_3x1u-g"}}, {"page_content": "To track something, you're in the middle of development and you really only have a limited amount of brain power, let's say, to write that idea down. Or whatever you're doing, it doesn't have to be development. So I really like that about Notion, is that it's just so just speedy to just jump right in, take a note down, and then if you want to embellish on that or build that up, you can really easily. And it also makes it intuitive to build up your pages because you know all the building blocks as you get used to it, and so you can kind of just keep expanding on that. I think I've said enough about that. So here's some different examples that you could start off with. So we could just say, hey, I want to start off with a blog post template, and it's just got a nice like columned layout to show you some text. Yeah, to-do list, kind of tracker, all sorts of stuff. They have a Kanban one here. I can't remember where it is. It's somewhere here. Ah, here's the kind of one. Oh, this is Monday through Friday though. Well, yeah, that's kind of the gist of that. But they do have a nice little Kanban one. So you can just pick one, use a template, and there you go. You've got a nice little thing to start with. But let me actually show you a really cool template. And if you're ever looking for ideas, what you can do is you can do search up a Notion gallery, I think. Create a gallery, template gallery. This might be it. Yeah, this looks like it. Okay. So they have this Notion template gallery on Notion. And this has all sorts of things from ones they've put together and curated, but it also has community submitted ones. And I think they have a paid one too, where, you know, people make professional ones and you can pay for it. I don't see it here. But one of the ones I really like is recipe box. I think it's this one. There's a few good ones. This is a really cool example of how custom and fancy this can get with some of the features. So I like to use this to showcase some of the functionality. You know, excellent work, Kylie. That's how I say your name. Sorry if I didn't pronounce it right. But what you can do is go to this example, and it's publicly hosted. And here it all is. Now, I can't edit this because it's a public one, but I can take a look at how it all works, right? And that's really neat. But you can just click this duplicate button. I lied to you. I can't actually edit it, but I have to send it to my own. And what it's going to do is duplicate it to my Notion. And now I have that. That is a really nice feature. So now I can just play around with it and do what I want because it's mine. So I have this recipe box. We'll change this to big woofer box, because I said so. And I want to show just some of the really awesome data structures that they have in here and all the things you can do. So first, you can see you have these columns, and they have completely different types. You've got names, which are links. You've got tags, and you can see it's got a little icon and what it is, which you can just slap in whatever your custom tags are. A link here, because it's got a little icon to click to go off to it. And a Boolean little checkbox here. And that's really nice. So every one of these is its own page. This is that kind of component idea. You click it, you open it up, but you can also do this and just go to the actual page and see it that way. So there's a couple different ways to do this. You just hit back and you're back where you were. It's got really good state tracking. So these tags, you can click in here and this this person's built all of these tags out, you can just type a new one, like we already had woofers, right? So you can create woofer. There you go. And you've got that you can add any ones that you want. And that will come in when it comes to filtering, but it's also for visual candy. You've got your link, you've got the Boolean tried or not tried and the created on. Now if you add a property, that's for this whole table. So all of the items will share that property. So you're not just adding it for this. This is a collection of items just so you know. And you know, here's this crazy recipe. Goodness, what is this? 100? Oh, it's 101 things. I thought it was 101 steps. Okay, simple 10 minute meals. That makes sense. So that's each one is a page, you can see that they they can take on their own, you know, cover background, this little Apple icon to give it a little bit of flavor. You know, that's cute. And a checklist instructions. Yeah, really neat. Now, the coolest thing about the way that they do the table data, in my opinion, is that you can click and have different views. So you can say, Okay, I want to view by category, check this out. So it's taken all the images. Let's see if we open this one if it'll show it. So this is the cover image, and they've set it up, it's a custom setting that you can change it how you like, you can either show the first content that shows up at the top of this thing, or the cover image. And now you have this nice little board, if you want to visually see everything. And it has very nice like search functionality. So if I'm looking for I'm in the mood for cheese here, you can, you know, sort by all of the cheese dishes. You know, no one has as many friends and all that. So then, well, let's take a look at this view real quick. So before we jump off to the other ones, you can see that there is also like tags are shown in this format. And you can change that by going to properties and clicking on and off. So like, I don't want to show the name, I want a more condensed view, you can just click that on, it's just showing you all of the properties for that one. If you want the created on date, if you want a little checkmark to say, Hey, have we tried it or not? That's really, really neat. Yeah, I really like that. This is your your card size. So if you want to make them a little bit smaller, you want to make them a little bit larger, you know, it's up to you can do whatever you want. The fit image is kind of interesting. You know, just like constraints and all that stuff. And the nutty there and then this is how you pick your preview. So you can do the content, which see it'll show like the cooking information. That's the first one. So if there's an image there, it will show up. Or you can do the cover, which is a little more ideal here. You can group things by tags, obviously. The filter here is really nice. So we can add a filter. And I don't know about filter group, but the filter itself, these are really cool, because they're dependent on the type of value that they are. So for name, you can say does the name contain cheese, for example, does not don't we have a shorter one than that salad. That's interesting. should work. What did I do wrong? Name is is. Let's try this first. So let's say we want to want this name right here. So I'll grab this name, just to show it. This is going to be done. But is the name is exactly this? Okay, well, there you go. And you can see there's duplicates here, you got to scroll horizontally, if it gets crazy, which isn't the most ideal solution. But I don't know how else you would tackle this. Honestly, it's okay with if you've got a trackpad. But so because this thing shares two different categories, easy and salad, it shows up in two places, since we're sorting by category, in case that was confusing. So we should also be able to take just the word salad and say, contains. There we go. I don't know why that wasn't working earlier. So if it contains it, does it has a case sensitive here? Looks like it is. So that kind of sucks. I wonder if you can do I bet you can do regular expression, but I'm not sure how. Never tried that, actually. Usually, like I said, this, this app is pretty intuitive with all that type of functionality. But this is one of those situations where I don't actually know how that works. So that's name, it gives you a bunch of like string matches, you can also do like, let's say, let's try to do so this is the Boolean. So you can just say tried or not tried, right? I want to filter by everything that has been one or the other. Yeah, really cool. So let's remove that. And you can sort that's usually more useful for the table format. So I think that that shows enough of that. And then if you want to add, you just click new here, and you can just create a new one. And so I can name this my new meal. And then you click it, and it's got you know, all of the attributes for you to fill out and you can just put wherever you want, you get this blank slate that's got the format that you want. So yeah, I think that showcases that pretty well. See, haven't tried. So you can make your own cut. So you have like, you have this view by category. And that's a special view type. So if you add a view, you can see you can pick a table, a board, a calendar, that's kind of cool. It's got a whole calendar list and a gallery. So you can create that type. And then within that type, then you can set up your custom filters. Let's say like I want only I want a table, but I want things that I have not tried. And there you go. You've got it. It's even got like column aggregation, you can see the count right here, you can tell it to like calculate based off of different values, it depends on what it is. Yeah, it's crazy. What's this do? 16 early estate. Oh, that's cool. Yeah.\n\nSo much stuff. Wow. Yeah, and then favorites. Pretty neat, pretty neat stuff. I think that shows off tables pretty well. The functionality of it. I'll just give you kind of a real life example. So at my at my work, we had this interesting idea to try it out with like a bug board. And it was pretty cool because you could put tags for like, what type of if it was like critical, or if it was for a particular website that we're maintaining, or one of our code bases or something like that, we have all these different tags for that. And that's really nice. You have all sorts of custom fields like point of contact and all that stuff, pretty much like Jira, but you can get it in this nice visual card format. This is what I loved about it is that like, I have the tickets, but because I can have images, if we would encourage people to take screenshots, if it was something you could visually show, or paste a code block if it was like a server error, and that will show up here as a thumbnail. So you can see like the screenshot of it being a bug. And what's really great about that is you're not going to know exactly what that bug is when you first see it. But if it's a list that you look at it a bunch, it's really cool to like come back and get that like visual quick recognition so much faster than just looking at a bunch of text tickets with names. You can say, Oh, yeah, yeah, yeah, I forgot that, you know, our accordion was bugged and, and being silly. And you know, there's a picture of it. And just reminded me, yeah, I gotta go fix that. So that's great. I really love it. For that. There's, it's just, it's just really flexible. You know, can't say that enough. Let me show you the search functionality. I think that's a cool thing to show. So let's say we added this page. This is another thing I do. I have a errors commonly encountered, or I don't remember what I call it. But I have this page. And then within it, I have some sub pages. And let's say I've got like a node js one or something like that. And so in this case, I can just do a single backtick and say, you know, like type error, the thing was undefined. And that will close it. And then you can do it just as like a, you know, typical markdown code block. You can also do triple backticks to quickly get to that other one. Let's say we'll change this to bash. And we'll say there was a catastrophic error. And you know, some unhelpful node error as you are wanting to get. So here's that. And once you've got, you know, a list of things, and actually, let me let me do one more thing. So I usually do something like this, I'll say this is the error I encountered. Why can I not type right now? Because I'm recording, for some reason, my brain shuts off. And this is the solution. And then the solution could just be like, you know, when you use XYZ service, don't forget that. 200 responses can be errors and check the error object. Because you know, the world's crazy like that. So let's say you get in this scenario, and you just come to your notion, you know, it's, it's just a general thing that everyone shares. And by the way, you can see people typing at the same time, which is really cool, just like a, you know, Google Doc or something like that. But you go to quick find. And then let's say I were to look up, oh, you know, I got this error, and I swear, I've seen this before, we've encountered this before, I've got a vague memory of it, I'm having deja vu. Well, you just come to the search here. And let's say, you know, I just search for type error. And give it a second. And there you go. It found it told me the page that it's in, I click that, and it'll take me right to that item and highlight it. Isn't that cool? So if you're ever to type catastrophic, or whatever, it'll search within this, each of those pages. Now, I know that's not like a super new novel feature, but it's awesome to have in a tool like this. So we have this big list of like common errors, and people can come there and check and every now and then it's extremely huge time saver. And so that's a really nice functionality of it as well. You know, I really could spend just forever talking about this tool and all the crazy things that it allows you to do. But I think that that gives you a pretty good picture of some of the the core building blocks and just the intuitive ease of use, in my opinion. It's not just a note taking tool, if you don't want it to be now, that's primarily what I use it for. But you can do all sorts of stuff with that. You know, I see some companies doing, you know, cool ticket Kanban stuff or calendar stuff, or what's great for it, but it's not. It's not just a tool. It's a tool that I use for actually is like, onboarding, you know, documentation wiki, where you write all the stuff for your project and and how to train and you can have all sorts of embedded links and just great. So I encourage you to try it out. You know, give it a whirl and see if you like it. I think it's a fantastic product. And it's just it's one of those, you know, once in a decade tools that has really just made my life a lot more efficient. And I could cut out a lot of those other tools that each of them did something really well. But I wanted to centralize that all into one thing. And this gets me really close there. You know, I still use Asana a little bit for my personal, like ticket board stuff. And I think that's a really cool tool. But outside of that notions, my primary go to so fantastic work for the developers that have been working on it. And I really look forward to all the future cool innovations that they come up with. And hopefully, when you give it a try, you will find just as much enjoyment as I have with it.", "metadata": {"title": "Notion : Note-taking in just my style", "url": "https://www.youtube.com/watch?v=Xnoi_3x1u-g"}}, {"page_content": "Welcome to Swashbuckling with Code. I am Jimmy Cleveland, and we are about to make a full Webpack project. Now what do I mean when I say a full Webpack project? Well, let me briefly go over what we're going to cover. So we'll be using Webpack 5, and I'll show you some of its new features. We'll be using Babel transpiling for modern JavaScript. We'll be doing React with JSX, production and development builds, source maps, hot module reloading, CSS, and outputting that CSS from a JavaScript import to an actual file, SAS, PostCSS with auto-prefixing newer CSS features, BrowsersListConfig for customizing cross-browser support, outputting images as separate files or inlined into our JavaScript bundle for faster loading of SVGs or icons or any small images. We'll be generating the output HTML file from a simple custom template, and then we'll set up automatic cleaning of our output directory for a more realistic deployment setup. Then we'll quickly deploy and host our project on Netlify with automatic production builds every time we push to the main branch. And finally, we'll add React Fast Refresh, which is a really awesome new hot reloading tool that's maintained by the React team. Now a quick disclaimer, this video is covering what I think is the most common type of Webpack project, which is like a single-page app project, and I won't be covering exporting packages, though the end product of this will be extendable to a multi-page app or exporting your own packages or anything like that. And as you can see, there's a lot of content to cover in this video. I've spent a lot of time on this, trying to find the right balance between moving quickly enough to get through all the material in a reasonable amount of time, but also explaining things as we go. So I hope I did a good job of that, but you can let me know if you have any constructive feedback. Like I said, there's a lot of material to cover in this, so I'm going to be moving through it fairly quickly, but I will be explaining things as I go. But if it's not in as quite as much detail as you would like, I have other videos on this topic that delve into specific areas that I go into a lot more detail of. So check those in the description or in a notification that I'm going to put here. One last note is that I'm not going to be going over routing for single-page apps in this video. That's because a lot of projects don't need or use it, or when they do, there's a lot of different preferences and flavors that people like, and it adds a lot of complexity to it, so I decided it was out of the scope of this video. So now that you know what this video is going to cover, let us begin. Let's start by creating our project. So let's use Mkdir in my case, and I'm going to make this webpack project. I'm going to immediately cd into that project, of course. And then what I'm always going to do is I'm going to init right away. And I think it's a good habit to use Git in general, even if you don't want to host it somewhere, just because you get that history, it's easier to undo stuff and not worry about losing data and all that good stuff. So then what I'm going to do next is I'm going to host it on GitHub right away. So I'll go over to my browser, and this is my alternate account just for making these video repos, nothing crazy. And then I'm going to make a new repository. I'm going to name this webpack config. And I don't really want to do anything else but just create it. And what you can actually do here, this has always worked for me. You might have to type these commands individually, but you can just click this and copy it. And if you go back to your terminal and paste, mine will prompt me, just letting me know it's going to run some commands. And because each of those line breaks will count as the enter key, essentially, it's going to run all of them, and I just have to press the last one. And there you go. Now we've got it all pushed up. So if I reload here, I guess I didn't really need to init there, but, you know, whatever. So then the next thing we're going to want is we're going to install or we're going to actually let's do an init first, npm init-y, just to say yes to everything. And we might as well just install over here webpack, webpack-cli, and webpack-dev-server. These are the first things we're going to need. So then I'm going to open in code. So right off, what we're going to see here is Git is saying that it has too many files to track. And that's because we're tracking node modules and we don't want to do that. So right away, we might as well make a git ignore file, and in there we'll type node modules, and that you'll see this stop tracking it. And then here, this sometimes doesn't update for me recently, I don't know why, but you can just click refresh, and then now we'll just be tracking the git ignore, package lock JSON, et cetera. So I'm going to go over to package JSON, and I'm going to clean this up a little bit. I actually don't care about any of this stuff right here. If I get rid of name, version, description, main, it actually says that a couple of these are required in the npm docs, but that's mostly for packages, and I haven't really had any problems with them. I'm actually going to delete this as well. I don't really care about hosting my repository since that's, you know, for a package. Keywords, author, license, bugs, home page, don't need any of that. Now some people might think I'm crazy here, but I don't really have any need for this type of stuff, and if I do end up needing it as I go, then I'll find out. And so I think it's a good way to learn is just to kind of, you know, trim everything you can and see what actually is there so you don't just like sit in there kind of a bundle of anxiety of like I guess I need all these things. And rant, so I think we might as well just start off by adding some scripts here. So the first script that I'm going to need is start, and my start is going to be webpack serve. This is the new way to do webpack dev server if you are familiar with the old one. Now I want to do a watch because I always find this useful. This is when I want to watch my files for saves so they get updated, but I don't want to necessarily serve it. I might just be running it locally. So I always do a webpack dash watch here. And then finally, most important to me is that we're going to need a build command, and that's just simply webpack. Name these whatever you like, of course. If we come over here and do npm install, we get a few warnings. You don't have to worry about this FS events. This is just a, you know, packages that are needed for Mac that other operating systems can't use. It's really annoying that we can't get rid of that. These are the ones we're worried about, though. This webpack project, no description, no repository, no license. Well, that's because actually what we want is to set this to private and then set that to true. And the reason is because this is not going to be a package, and we don't want to accidentally publish this. This is the whole purpose of this is to be, you know, a project website in the end. And then if we come back over here and run install, those warnings will go away. We'll just be left with these ones that I try to look up, and I don't think you can get rid of it. So it is what it is. And I think the logical place next is to create a new file here, and we want to create it in source index.js because that is the default place that webpack is going to look without any configuration. So we'll create that, and then I'm going to actually set up a little object for my demo. I'm going to make an Elven shield recipe. And then for that, I'm going to say leather strips. That's two. Let's do iron ingot is one. Find moonstone is four. And then console.log, there's nothing special about this. It's just for example. We're going to log it. And then what we want to do is see if our npm run build command actually works. It does. We get a warning. You don't need to worry about that. It's just letting us know that it's going to default to production, which means it's going to minify and mangle it and all that good stuff for the end user. We will fix that in a moment. But for now, what I can actually do to make sure that it worked is I can go into dist and look for main.js, and look, there it is. It runs. And go back over to the editor here, and you'll see that dist has a main.js, and it's this one line format. So that's where it's going to output it by default with no configuration. Pretty cool. But we will want to ignore that folder. Now, the reason that we want to ignore dist before we commit next is because this is going to be our kind of like clean slate output. It should be repeatable every time. And so when we actually host this on the server, we don't want to host all these files. We don't want to pull them down from GitHub already built. We want it to build them fresh every single time. And so that is the reason that we're going to ignore the dist for now. And I think it's time to commit. So we've got our git ignore. We've got package lock JSON. I don't really ever look at that too much sometimes. And then we just take a glance over and say, okay, yeah, this all makes sense, the things we added. And you have that. Perfect. So I'm just going to say initial webpack setup and commit that. And then you can just click this usually. Is that going to let me? You can also do your standard terminal git push, you know, I'll be going back and forth. So I usually commit pretty frequently. I'm going to spare you all this time. And I'm only going to commit during major sections. But I think that it's a good habit to be in just to commit more frequently. It's easier to roll back. That's my two cents. So let's actually make this a an actual Web page here by creating a new file index dot HTML. And this is going to be blown out every time. And we're going to deal with that later. By that I mean, you know, every time we build on the server or somewhere else, you know, this isn't tracked. So we're going to have to start over and index HTML is not going to be tracked. So don't worry about that for now. We're going to come in here. I'm just going to use the good old Emmet shorthand. It's really nice.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "And then here, what we want to do, let's actually make an H1 just so we can actually see it. Webpack, we, I don't care. And then script, we're going to do a source type. And this is just going to point to main JS. So now we have our template. And what we can do, there's a couple ways we can open this and look at it. So we can right click for me and do reveal in Explorer, however you want to go find that folder and open it up. And then when it opens up here, I can just click this little Chrome and see it right here. And if I inspect, we should see our object printed out. Now, if I go over to my terminal, I should also be able to run my Webpack dev server. So that's going to start that up. And, you know, it's all built and beautiful. And then we just want to take this right here. That's going to start our local server there. We can go take a look at that. Now, what it's going to first do is it's going to show us just the whole directory is what it's pointing at. If we click on dist, that index HTML is the root point for dist. So it's going to open that automatically. And that'll work the same. OK, we open this up and install or go to console. We'll just see this object. But live reloading actually isn't working yet. We need to have a Webpack config to enable that. So jumping back to our code, let's make a Webpack.config.js. And that's what Webpack is going to look for automatically. And from here, this is standard. You're going to do module.exports for node. And then I'm going to set the mode to development for now just so that we can actually look at the code. And it's not all minified and harder to read. And then the thing that we actually are here for is dev server. So this dev server property, whenever you're using Webpack dev server, you can set this to content base. And you just give it a relative path to that folder where all your stuff is. And then when we restart that server, npm start, we go back to our browser. And this one shouldn't work because it's a subfolder here. But we should go to local host 8080, and we'll be able to see that. You can ignore this dev tools thing for now. That typically goes away. But this live reloading is enabled now. So let's see. Is that true? Well, in order to test that out, what I'm going to do is I'm going to add actually just to be clear, notice that it's just logging out this one object that we've made. So I'm going to go to our index.js, and I'm going to make a new object. This one's going to be called elven gauntlets recipe. And we are going to use the spread syntax for the next part that I'm going to demo. So we'll take this off of elven shield. We'll clone that. And then I'm going to add, like, leather to it, just raw leather. So it's going to add this property. And then I'm actually going to alter refined moonstone to be four. There's four of those. And then we'll just copy this, and then I'll change this to elven gauntlets recipe. So we'll log both of them. Now, if I go back over here, I should see this automatically logged out both of them. So it reloaded and logged them both out. So I can just manually reload, and it'll do that. Cool, right? Now, we want to look at our output real quick. This is kind of interesting. If I go to my main.js, it won't actually have any of that new stuff. That's because Webpack Dev Server is injecting that. It's not actually building it into the disk folder, just so you know and you don't get confused, because I've been in that situation. If I do npm run build, now that we've set it to development, come back, and we'll see that it's output like this. Just temporarily to fix this, it's a little bit harder to read here. So what you can do is you can go to, you can set dev tool to false. We're going to get rid of that in a moment, but for now, we'll do that. I'm going to rerun build, come back over to our main.js, and you can see now that it's updated to look pretty normal in the output, and you can see the spread syntax here and all that. So that leads us to the next feature that we're going to want to add, which is fable. So we have this syntax that's being straight up output, and we actually want that to be transpiled automatically to whatever Babel goes and looks at. Can I use reports and what browser percentages have what support, and determines that automatically, and we'll customize it a little bit after that. I have a video on this, so I'm not going to delve into that too much. It's the build basic webpack video, which I'll link in the notification and all that stuff, but I cover that a little bit more there if you don't really know what Babel's for, but we need to cover a lot of material here, so I'm going to move on. So in order to add that, let's go to our terminal. We're going to add, these are all going to be dev dependencies, we're going to do babel loader, since that's webpack's way of figuring out how to digest certain syntax, and then we're going to do add babel core, and add babel slash preset env, so core, so that we obviously have all the core functionality, and preset env, that's because those are going to be our standard defaults for last two browsers, 1% usage, or I don't know what their defaults are, but somewhere around there. Now, what we need to do to get this to work is first, I think we should update our webpack config. So if we just go to webpack config, what we can do here is say, we're going to now have a module property. This module property is going to have a rules property. This is pretty normal, you get used to this, it's the regular flow for setting up all your rules, and then here, you're going to do a test, and this is going to be a regular expression test, I think. Oh, whoops, we want an object here. Don't be silly, Jimmy. So these rules are going to be a series of objects, you can think of it that way. This first test is going to be a regular expression. We're going to just look for JS, okay? And we'll put the dollar sign there just to be a little more secure to say it ends in.js. Any file that ends in.js, we want to run against that. We're going to have to exclude node modules because Babel transpilation is actually pretty expensive, and we don't want to run it on a bunch of stuff that has no need to be run against for us. So that will make it slower if we didn't do that. And then use, finally, we want to say, oh, well, how are you going to handle this? Well, I want you to use this loader, and it is Babel loader. Oops. So without any extra options, Babel loader is going to automatically look for one of the default naming conventions for a Babel config file, so let's make that. Now, usually I do Babel RC just because that's what I'm used to, but in some cases you're going to want a config.js, and that's what I recommend for this one. So babel.config.js is another one we can use, and then I'll make it a JavaScript config. So with that, we'll need to do module.exports as usual, and then here this is going to have a presets array here, and then we'll just use at babel slash presetenv. That's our preset that we're going to use, and that's it. So now what we can do is if we do npm run build, we should see, going back to our main.js, we're going to have some extra stuff here that's interesting. Notice that this spread has been replaced by this object spread method, and that's where it's defined, so it's actually gone and made some little bit backwards compatibility support for some of the browsers that don't quite have it yet. It's still not as widely supported as we would like. So now we know our Babel's working. Now if we go back over to our terminal and start our server back up, and go back to our browser here, let's reload that real quick, and what I want to show is that if you were to look at any of this in the main.js, you're going to see the final output code as you would expect. It's all the finally transpiled code. What you can actually do, and it's really easy and awesome, is we can go back to our webpack config. I'm going to wipe all these out for just a moment. Let's go back to our webpack config, and here we can change this devtool false to source map. Now I should need to restart the server from that, but I always like to check just in case someone's made some cool advancements, it looks like it. So let's go back, shut down, restart, npm start, go back to our server, and then you'll notice now that warning's gone away finally, but also notice that it's index.js line 14. Let's go take a look at that, and you'll notice that it's our pre-transpiled code. It's our source code, so it's that easy to set up source maps nowadays in webpack. It's amazing. I love it. Now at this point, I don't want to keep switching back and forth constantly between whether we're development or production when we want to see the final build, so what I'm going to do is go to my package.json, and I'm going to say that my build command is going to set the node env equal to production. And then what I can do in webpack is I'm going to say let mode equal development. Down here, we'll set this to mode, whatever we end up with, and then we can do an if condition. We can check process.env, and we can say if that node env, sorry, environment variable, is equal to production, then we want to set mode. Oops, I'm not in an object. We want to set mode equal to production.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "Pretty straightforward there. Now, this might be a little bit weird to you. I could have used a turn area. There's a lot of other ways that we can make that cleaner. But this will make a little bit more sense, I think, toward the end of the video. I'm kind of setting it up in that direction. So just bear with me on that one. We'll start with this. So by default, we'll have development mode. But if it happens to have this flag, however you want to set it, you can set it in an env file or in Windows it's a little bit different. But either way, you set that environment variable to production. You can just look that up how you can do that. And it's pretty common. Now, if we come into here, we say npm run build, we should see that our main.js is all mangled and minified and beautiful. So it's nice and compressed. Fantastic. And then what I'm going to do is add one more script real quick. I'm going to say, I like to always have this around as a build dev script. And then that will just simply run webpack without passing it just like our old one did. And then let's try it out. Got to make sure it works. Build dev. So that'll switch us between that. So then I can just run this, you know, when I actually want to see my normal output here. But then on the server, it'll run build. I think this is a good point to commit our code and do a real quick review. So we've got this babel config.js. And that makes sense. We know we added that package lock, you know, it's just our packages. But what packages did we add? Well, we added the script. We added our Babel core, Babel preset env and Babel loader just as a refresher here. This is why I like to go through VS codes, diffing of the git. I just think that it's a nice habit to get into to make sure that you didn't leave any accidental console.logs or any problems like that. And to also kind of remember what you did. So then don't worry about that. I always get that. Webpack config. We added the whole thing, right? Yeah, we needed all of this. And then finally, we added the spread. Cool. So we'll say add Babel to project. Okay. And next, I think it's time to add some CSS support. So let's start by adding our styles by having a styles folder is what I'm going to do. It's not necessary. I just like to do that. And then here, I'm going to do index.css. We'll start with a basic CSS file. Now that CSS file is going to be pretty simple. We just want to see some results, right? So we'll say let's set the margin to zero. Could have done m0 there. Let's say our background color to I'm going to do peach puff today. And then our color, I'm just going to set that to 222 globally. Now, in our index.js, we actually want to import this. So we'll say import, and we can just say dot slash styles slash index.css. And then let's try to run it and see what happens. So let's just try to just run build, boom, blows up, right? That's expected. That's because you may need an appropriate loader to handle this file type, of course. So what we're going to do is install those. We're going to do CSS loader. And then we're going to use mini CSS extract plugin. And you can use style loader as an alternative. The real difference is that the style loader is going to inject it, the styles into your JavaScript bundle, whereas the mini CSS extract plugin is actually going to create resources or a final one single CSS file for that. Now, which one do you use in which situation? It kind of depends. And sometimes I don't really know which is the best practice, to be honest. But at scale, it seems a little more normal to just have the files, because the request is a little leaner than downloading this gigantic JavaScript bundle that has CSS put into it. But sometimes you'll use style loader, if you're doing like critical CSS, so you might use them in combination. You know, you check for one, all of your critical CSS at the top, it's like, you know, your basic CSS and fonts and all that stuff. And then everything that can be loaded, you know, below the fold, to use an old term, that can be loaded in with the mini extract CSS plugin. So let's set that up. So here, if we go into webpack config, what we're going to do is need to import this. And so the convention is just to call it mini CSS extract plugin. And that's going to be equal to this should all be complete for us. So we've got that now. And I'm just going to yank that name. Yank that name. And then we'll go down to there's a couple spots here. The first one, I think it's a little quicker as we'll use plugins. And in the plugins, what you want to do is use the new command. I hate when I do that. When I use a new command, and you're going to call this constructor. And then up here, we're going to make an additional rule. Okay. Now this rule itself is going to be a looking for the CSS file. So we're going to test against it just like before. This will be case insensitive, we might as well. We want to do a escape the dot CSS. That's all we need for now, isn't it? Yeah, we just need this for the first part. And then what we're going to do is we're going to set up our loader again. But what we can do is we can just set up this array chain here and say I want this mini CSS extract plugin dot loader. That's the thing that we need off of that. And then CSS loader after it. Now in webpack, everything reads kind of right to left and arrays. So what's going to happen here is when it finds a CSS file, it's going to use the CSS loader to process it. And that's going to be piped into this, which is going to spit it out into our dist folder. Let's see if that actually works. So npm run build. Boom. And in our dist, we now have a main CSS file. You can see that it's got the source mapping already built in, because we just have that one source map setting to true. So that's already done for us. Awesome. Now what we will need to do is link it into our HTML for now. So I'll just do a link CSS. Can you not do that? That's kind of dumb. You have to type that. And then this is actually going to be main dot CSS. And that should be it. Now what we can do is start our server and then check both of them. So we'll start, we will go to this one, reload, and we have our nice peach puff background. Perfect. And then if we go back over to our webpack, this is the one that's just from the file just to show that this is the built one. And this is the served one. And they're both working just to be doubly sure. Right. Now it's pretty sweet about this now that we have the server open. Let's show this. This might actually be tricky for me to show without having them split. So I'm going to split them in half here. There we go. And we don't really want that all the way over there. This should be fine. It's a little bit big of text, but bear with me for a moment. So if we go into our index CSS file here, now let's say that we change, you know, whatever, actually, you know, let's do this. Let's change the font size to 26 pixels. So we're going to just enlarge in the base body of everything. And it should get a bunch bigger. Now you'll notice is that is live reloading, which is pretty cool. We would really want to pay attention to is the fact that over here on the side, these two logs that gets reloaded. All right. So let's do that one more time. So we save that. And you can see that they get refreshed. You can also look up here. But with when it's so fast and lean, it's hard to actually see it. Sometimes you'll see that little flash on that reload. Yeah. So that is live reloading working. But what we really want that's awesome is hot reloading. And to get that very easy now. So all you need to do is go to your dev server. And you want to say hot. It's true. Now you might be used to package JSON. When you run this, like webpack dash dev dash server, the old way, or this way, you could do dash dash hot flag here, which I believe you can still do. But it will automatically do that. And it will also automatically load the hot module plugin in the plugin chain if you just set this slip streamline this to be a lot nicer now. So you just add true. Let's actually make sure that that works. Why don't we, I think we will need to restart. Let's actually make sure one more time. Yeah, so we'll need to restart our server. And then from here, we want to reload this one just to make sure and then add that property again. And look at that. So you can see that it's just dumping more logs. And how can we, you know, make sure that that's actually what's happening, because it's happening pretty fast. Well, check this out. Let's say that you were testing this out. I know this is really squished. Sorry, bear with me. Let's say that you were testing this out. And you wanted this like really long title on mobile or something like that. And you want to see like how many times it wrapped or whatever. This isn't a great example. But notice that I've edited the HTML here. So if I reloaded, it would just go away, right? But if I add this to it, notice it kept the whole title. And if I undo it, we'll do the same thing. So this is one of the reasons why hot reloading is really nice. Because now watch, I'll reload, and it's gone. So it wasn't a live reload, it was a hot reload, a module replacement. And you can also see that in the console. If you want to see that it's working, it'll say.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "hot module replacement enabled. Now, why this is really useful, getting back to that. If it isn't immediately obvious, a lot of times it will, it'll be a little bit faster, of course. That's the first benefit, just faster. But also, when you're making changes, especially later when we add some React and you're changing like state, or maybe you're editing the DOM, you're switching some things around or messing with stuff, being able to, you know, live inject those CSS styles to not have to like replicate your current app state can be really, really efficient and speed up your process a lot. So yeah, isn't that awesome? Just one little property now, and you got hot reloading. And this will also make a difference, I should actually note, as the project scales. One thing I forgot, as it gets bigger and bigger and bigger, the reloading process will be slower, whereas injection will be much, much faster. And that's where you're really going to see it. So on to SCSS. So in order to have a CSS, now, I'm going to go back to this format for a moment. In order to have that, we are going to need some new loaders, of course, but let's just change over to an SCSS file to start. Okay, what we'll actually do is we're just going to set up some scaffolding for like a normal way that you do SAS. So I'm going to make a global dot SCSS file. And that is where we're going to copy over. Oh, no, you got rid of my other one index SCSS. So we're gonna yank all this over here, put that in global. And then what we'll do is we'll use the at use directive, and we will bring in global. Okay, if you're used to import in SAS, it's not really recommended anymore. I think it's because it sets global variables. But the new way and we're using Dart SAS, so we can use this. The new way to do it is the at use variable, which will like locally scope it, you'll see a little bit more of that in a moment. So then what I'm going to do next is I'm going to make a variables file. And I think most of the time, you'd probably want to be using CSS variables nowadays. But I will actually create a SAS variable just to make sure that it's working. And you might have some sort of use case for it still. I don't know. But typically, I would lean toward CSS variables nowadays. But let's make that peach buff. Right? That was our RPG one. And that's all we're going to have for now. Actually, you know what, let's actually do. Let's do both. So we'll do route, just to add a global one here. So we can just see that both are working. And then I have to do two, I don't really recommend using both. But like I said, maybe you've got some use case that makes sense. That's our variables file. So in my index, CSS, we don't actually need to import the variables here, like you might be used to, we're actually going to go over to global. And then in global, we're going to use the use directive. And we're going to say bring in variables need to put a semicolon here, of course. And then you can just change this over to variables dot, and you actually use the variables like methods from there, you are going to use the dollar sign, which is kind of weird. Pretty interesting, huh? And then here, we're using a CSS variable. And so we're going to just do dash dash text, because that's what we set there. Let's try to run it. Let's see what happens here. So we'll do npm run build. And that's not going to work because there's no index CSS file, right? I forgot actually to go here and change this to SCSS. Silly goose Jimmy. And from there, we'll run build again, we're gonna get another error. This one is the famous loader problem. Okay. So in order to get that working, we'll just go back to webpack config. And really, what we could do is just add this s here. And if we wanted support for both, we could just do a question mark here. And that'll mean like it might have an S it might not. Now, go back and run build here. It'll build. But we didn't actually add the loader, right? sass loader and all that. So if we go and look at the output, notice that it's just it just basically took whatever was there and output it didn't actually run it like it like it should. So in order to get that working, all we need to do is add the we're going to add sass and sass loader. And this is Dart sass that we'll be using. There's a node sass package as well. And this one's a little thing. It's a little faster, but also more up to date. Let's go back over to this. And now we'll add sass loader. And that should get us where we need to be. Okay, let's see. Did it actually build? Cool. Yep. And it's all minified, which is interesting before our CSS wasn't. And yeah, you can see it's outputting the color just straight up, which is interesting about the variable doesn't do the name. And then this still stayed a CSS variable. So that seems to be working. Now we might as well just add post CSS while we're at it. So we'll just do post CSS and PMI dash D, and then post CSS, we're going to do preset ENV, which is kind of like Babel preset ENV, but for post CSS, just most modern browser stuff, and then post CSS loader in order to actually utilize it. Now, we will need one extra thing here. We're going to want a post CSS config. So we'll make that file, the post CSS, post CSS dot config dot j s, I always forget that one. This is very similar to Babel should be familiar. We're gonna do plugins. And this is going to be post CSS preset ENV. Now, let's get rid of all these. Now let's go to webpack. We want to do is that our post CSS loader. And we're actually going to add that before the SAS loader. And this is actually really cool. This is something that a viewer from a previous video actually mentioned, because in that video, I'd mistakenly put them in this order, thinking that it didn't really matter because I tested out and I didn't notice anything. And that's just what I like to do. So they actually went and did a little bit of testing a little bit of research there. And they noticed that not only would it kind of break some slash slash comments, but the big thing was that it would take your vendor prefixes, and it would put them into your source maps, which you wouldn't want, you'd want to see the original code. So that's pretty cool. Thank you, Martin, for going discovering that. I really love to see that people in the channel helping each other out, and also helping me to grow as well. It's really fantastic. And now I'm more knowledgeable because of it. So awesome. Now let's run build again. See what we get. Now we'll go to our main CSS. And this is actually going to be pretty subtle. So I'm going to format this. But you'll see here that there's this this one extra line here, the color being output before this is actually the fallback that post CSS is adding. In order to see it do a little bit more, let's actually add some more code to our actual global. We're going to want to do this is some CSS for later. I'm going to add for main tag, I'm going to do display flex, then I'm going to do flex direction, column, and align items. Can I do a I see? Yeah, that's cool. And then here, I'll do button. And this is just going to be FC 1.5. REM, something like that. Mom, that fun size, and then go back over, run our build again. And we're going to take a look at that actually should be doing dev, huh? npm run, build dev. And go to our main CSS. And you'll see that it's not doing anything quite yet. And that's because flexbox is very well supported in most browsers nowadays, which is really cool. What we're going to do is add a browsers list RC to support a little bit wider range of browsers. And that's actually pretty easy. Now, the reason why you do this is, I recommend sticking with the default, if you don't really know any better, you don't really even need this browsers list. But what this can be good for is let's say that you know that your website's demographic is a little bit skewed differently. And you have a little bit more traffic in some older browsers than most people do, then you can opt into this stuff. So what I'm gonna do is last two versions, this is just kind of the general syntax. Each line is kind of a rule is a rule, it's not kind of this is going to I'm going to target 0.5%. I think the default is one. And then I'm going to do IE 10. I'm very sorry for anyone that's doing that. It's just for demonstration purposes. I actually wanted to run build dev, such a habit. Let's go back to main CSS one more time on Whoa, look at all this stuff. Yeah, so these are vendor prefixes. So these this is the way that Flexbox was supported a little bit further back, as far back as it can support it, it's not going to guarantee that you're going to get in every browser, it's just going to, you know, you have to test that out, unfortunately, but you could look it up and can I use which is a great resource. So if you actually if you're not familiar with that, I might as well briefly go there. Do that. And then we'll do can I use go there. Really awesome. And then let's say you wanted to look for Flexbox, you can come here. And this is the important kind of stat to hover over is this is like global support from all the traffic that they look at, like all browsers, it's very well supported right now. And you can see that IE 10 has some like partial support with the prefix. So that can be a good detection for us to say, oh, the dash ms prefix is what supports it. But six or nine won't, unfortunately. So", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "if we go back to our CSS, you'll see we have this dash ms flex box. And sometimes they behave a little bit differently. So you still have to do a little bit of testing. Sorry, that's just the world that it is. But you know that it's working. And you can use can I use to see which browsers support which. And that also works for JavaScript as well. And that's actually what these use under the hood. There's a package that serves up all those all that data. And that's what browsers listed and the Babel preset and V and post CSS. That's what they're all using under the hood as far as I know. So now just like that, you've got some good backwards compatible support. So you can use modern features and still support them in the old way. Like I said, still have to do a little testing. And if it wasn't clear, this browsers list, both Babel and post CSS are both reading from that. So they they'll they'll use this as this kind of global standard to say, what are your targets, there's other ways to set this up. But I think this is the nicest for me just to be able to quickly see what this project supports. Now, unfortunately, as a right now, there is a bug in, I believe it's in webpack, dev server or webpack five, I'm not sure, actually, but it's caused in the modern versions, by a browsers list RC being set there, and then not being sent over properly to your production and starter build. So let me show that just so that you can see that. And in case you want to check if you actually have it, because maybe in the future, they'll have solved it. And you won't have to worry about this. But for now, I'm going to give you a fix. So if we do npm start, all I need to do is go over to my browser, we don't need this anymore, or reload this server. And then what I'm going to do is try to do some of my webpack live reloading here. So let's say I go to, we should actually be able to do this just from well, let's make it easy. So I'll just say like, FC 100. Right? Just do a big old change. Now when I do this, and I come back over here, you can see that it didn't do anything, unfortunately. So I'll change that again, maybe let's do something, you know, different here. Maybe let's say, let's change this to purple. Why not? Nothing, unfortunately, what if I reload? It's there. So this is the bug that it creates. And it's really unfortunate, but I'll show you a quick fix. So what you can do is you can go to your webpack config, stop. And then you can, you have this mode set to development, let's do a target. And this target is going to be default to web. Now this is the default already, just so you know. But the reason I'm going to do it that way is because then I can come right here and I can say target is equal to target. And then what we're going to do is say if you are in production, I want you to actually target the browsers list. That's the setting. And what that's going to do is going to make it to where when you're running the the dev server, it's properly set to web. But when you build, it'll still use the browsers list and output everything correctly if it's in production. Okay, so let's make sure that's working. First, let's check our live reloading. Come back here, we've got this peach puff right? And you can see live reloading enabled there. Is it true though? Hmm, I don't know. Let's find out. So I will just change this here to purple again. It's probably the most obvious, right? And then it auto reloaded. Pretty cool. Just flip it back. There you go. So it is clearly working. And that's awesome. But what we should also check just to be diligent, is that we're going to be able to see the live reloading. Okay, so if we run npm run build, that will be production. Right? And so that means that if we check our main CSS at this point, we should see this big, long minified version. And we should see all our vendor prefixes. That's the important part because browsers list was the one causing it and we do see them. So what if we do npm run build dev just to be extra sure. And it looks like we're still seeing them. Now, like I said, that is a temporary fix right now. And hopefully they will have that solved soon. So make sure that you that issue actually exists for you before you apply that. But hopefully it will be fixed soon. All right. Now, in order to wrap up the CSS section, it's hard to say, I am going to make sure that I do my due diligence here and commit these files real quick as a quick refresher here. So let's go over to browsers list RC. Yes, we did add that. We don't worry about our package JSON. And then here, that was the lock sorry, CSS loader. And then the mini extract plugin. Yeah, we've done a bunch of stuff. Post CSS, post CSS loader. Looking good. All right, add that. We added a post CSS config, so that it would look for that preset env. We then updated our webpack to have the mini CSS extract plugin, setting our target web for the fix and all that good stuff. And then we set up our rule for SCSS. And then from that point on, and actually, you know what, I'll make one little modification here while we're at it. If you want a more universal like test scenario, this one's fine. There's nothing wrong with it. But we can actually do is let's go back to where we just had CSS. And then you can do an interesting little fix here. Or you can say, well, what I want to say is let's let's wrap that this will kind of set up some options. And then I could say it's either going to be SCSS or just CSS. And you can take that a step further, which is pretty crazy. And say at this point has to be an S or an A. Okay. And then that will make it to where it now says it's got to start with S and then the next character could be an A or C. And then, then it'll be either that or a C and then SS. So this is supporting SAS, SCSS, or CSS. So if you want a kind of global solution, just you know, because it's easy, and you can use it every single time, then you can go ahead and use that. All right, sorry, let's finish up. And that puts our rule there. We've got CSS loader, post CSS loader and SAS loader. Remember that you want your SAS loader to be at the very bottom, which is the first thing that's going to enter, and then it'll add your prefixes to your CSS, and then finally output it into a file. And then down here, you got to have that plugin. And we got hot true, we've got our hot reloading, lots of fun stuff. We imported it into our JavaScript file. And if that wasn't clear, that was because we need Webpack to actually see it to process it. And this is our entry point. So that's why we do that. And finally, we set up our global CSS files. I'm not too worried about reviewing those too much. We know what we did. And we're using that at use directive. Cool. So let's say add CSS, SAS, post CSS, hot reloading, all sorts of good stuff, and a browser list. We should probably add that as well. If you're actually being diligent about your commits, you can do a big old message. But I think that's fine for now. All right, now it's time to get some React and JSX working in our project. But first, I would highly recommend you take a standing break, or a quick water break, get some hydration going on. Just a few minutes, you know, stretch your legs out. And it's just a good habit and then come back refreshed and ready to set that up. All right, start off now, we're going to do npm i react and react dom, one too many spaces there. Now, this is actually not going to be a dev dependency, because it's going to need those packages in your final output. I actually don't think it really matters in Webpack world in the situation. But standard convention here is that these libraries will actually be used with the code that the client downloads. So they should be in production, just so that it's clear to everyone. Next, in order to transpile a JSX here, we're going to do at fable, and then slash preset react. Yeah, so we already have preset ENV, we're going to add preset react now to get that working. And so let's head on over to our fable file here. All these things open, just close all go to fable. What we would normally do is we would just add it here and say at fable slash preset react. And that will work. However, we're going to do something cool and new and fun. So in order to do that, we are going to put this extra array around here a little bit weird. Extra array around that, and then that will stay the same. But we're going to add an object that's a that's in the config option here. And then we're going to do runtime. And this is going to be automatic. So what is this? Well, since react 17 plus, and they've been part they partnered with Babel on this, the team that does it does the tool set, there is a way now to actually opt in to not having to import a react whenever you're just using JSX in a file, which is really cool. And under the hood, it actually is supposed to make it a little bit more efficient as well. And so the only time that you'll need to import react is when you need methods or state or anything like that from the react library. You'll see what I mean. But just so that you know why the settings there, it's pretty cool. Now let's modify our index JS. So what I'm going to do is I'm going to add to the index JS want to import. And then I'm going to import react. And then I'm going to import react.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "And I'm going to do a D structure here. We're going to do render from react dom. So we will need to import that. And then right here underneath this, I will say I'm going to call render. And just to test it out, I'm going to put an H1 here. And we're going to say, oh, hi, from react. And then here, the next part is going to be document.getById. You can just do that as a shorthand. If you type it right. And then so when you get element by ID, you can do query selector as well. This is just pretty normal. And that will make it to where we attach react to our dom. But in order to make that work, we actually need it there. And so we need this. We need an element with root or whatever we want to call it. Roots the convention. Come back here, that document.getElementByRoot will attach this H1 to it. And then that should work. So let's try to run it. So I'm just going to do start. And then go back over to our server. Oh, hi, React. Yeah, got it working. Pretty cool. Notice that we didn't need React in that file. But you'll see that in the next file that we're about to make as well, if you don't believe me. So next, let's actually make a component here. Let's come over here. We're going to add a new file on the side here. And in source, I'm going to make a new folder. And I'm going to call that components. That's a pretty standard convention. You can do it however you like. Don't worry about having to adhere to whatever. If you've got a preference, you can. But if you don't know what you're really doing or you're not opinionated, this is pretty normal until you scale to a certain size. So in the components, we're going to make an app.jsx, which is also pretty common. And I'm also going to make a, well, here, a recipes.jsx for our recipes. And that's so that I can come over here and I can take all of this code, steal that, go over to recipes, just put that in there for now. We're going to do more with it in a second. And then also, let's go to here. And I want to take this CSS and then put that in app. I guess it could stay in the other place, but this is fine. And then what we'll do is we're going to import app from.slash components slash app. Cool. Notice that I made that with a app and recipes.jsx extension. You don't have to do that. You can do.jsx. It's just, if you want to, it's a common convention. I think in TypeScript, you have to. It's TSX in that case, but either way, you don't have to, but notice I'm also not putting.jsx here, right? I just want to import it as a regular JavaScript file. That's going to matter in a moment. So then let's actually make that a React file. So in order to do that, what we'll do is we're just going to start with app and get that working. I have a shorthand here for my snippet library, snippet good, if you're checking it out. I need to actually update it for React for that latest stuff that I just showed, the not needing it, but either way, we'll make an app here. And then this app, we might as well just, you know, I'm going to set it up as the way it should be here. So I'm going to change this to be a fragment, and then I'm going to set section, and I'm going to set the class name. This is just some scaffolding for a moment later. We're going to set this to hero. That's our section. And then I'm going to do main here. And then in that main, I'm going to have another section. And h1, this is where we'll do, oh, you know, oh, hi, React. And then that's it for now. Then we'll go back to index.js, and then here we will see, actually, no, we don't want that tag either. We want app. We're just going to load app. What can I type? Let's see if that runs. Did it fail? Module not found, cannot resolve components app. Let's just make sure that it wasn't just the server flipping. And you'll see that it failed. Can't resolve this file. Why? That's because it's looking for a.js automatically. So all we need to do to fix that situation, you could just type the.jsx if you want to, and that'll work. But what we can also do is come on down and say, okay, let's add a resolve property. And that resolve property has a bunch of different other properties it can have, but you can do extensions. And for extensions, we still want to support js, and we want to support.jsx. Okay? And now when we do this, this will make it, what this is doing is saying, whenever you import something, you don't have to have that extension. It will automatically infer it. And you can throw more on there if you want. This is just what I usually do, just those two. So let's run build again. And see that it works. No, it does not, because we don't have our loader set up, but at least it saw the file this time. Okay? So same thing, we got to the jsx, see that fragment there? It's saying, I don't know how to handle that. Okay. Well, I'll show you Webpack. I will show you. So all you have to do actually now is come up to here because our Babel is already set up to handle React or jsx in this case. And so all we need to do is add an x here, and we can just do a question mark like before and say, it may or may not have an x. Now let's do run build again. Oh yes, ha ha. Index SCSS. So we moved it to app, which means that we now need to go up a directory because we're in components right now. So we need to go up from components and into styles. Sorry about that. And there we go. Awesome. So let's just do npm start. Now, since we've got that all configured, we'll get our live server loading, make sure this is still running. And then notice we have the centered thing because I created that CSS for the main section here, and it's just centering that oh, hi React. So that's working right. But next I want to set up our recipes. And this is important for a little demonstration I'm going to do. I'm going to show you how to do that. So in app, we can import. We actually don't need to import React. That was the thing that I was going to show you, right? Will that work or will that not? Reload. Still working, right? Pretty cool. We don't need that because we're only using JSX, right? That's the key thing here. And you'll see in a moment when we do need that. And that's why I'm going to set up recipes. One reason I'm going to set up recipes. So recipes, okay. We can do the same thing here. I'll just do, you know, rfe. And then I'll say recipes for me. So you're going to have, we will not need React, but what we will actually need, I'm just going to use this. We will from React need use state, okay? And in this situation, the example that I'm going to set up real quick, I'll probably just speed forward through this to save you the time of watching it. So we're just setting up some state here and I'm going to set up a couple of buttons to swap between the two different objects that we have and then just list out all the properties. And really the purpose for this is to just show the persistence of state when we get into some hot module we're loading and stuff later on in the video. And that should be good. And then in app, want to import that. So we will say recipes from.slash recipes. And then we'll just load that right here underneath. So recipes. Oops. Ooh, okay. And here we go. Those are big. Okay, so now we click this and we click this and you can go between the two states. If you reload, you'll see that this one loads this object and this one loads this one. So our React and our use state is working for compiling JSX. And as I said before, you do not need to import React whenever you aren't using state. And that's pretty cool. And it should be a little bit more efficient as well. Now I almost forgot. Let's actually add these files and do our quick review of what we've done. So we've updated our Babel to have this runtime automatic here. And that's with the reset React, of course. Let's go to, stop that. Let's go to package.json and we'll see that app Babel preset React was added as well as the React and React DOM dependencies. We go over to our webpack config. We can see that the JSX test has been added. We just added this X character to look for those files instead of just JavaScript. And we've also added the extensions for JS and JSX. So that's cool. Now for our index JS, I'm gonna review that. We brought in our React DOM so we could render it. And now we're importing app. And just so you know, some people, you know, like to put index.js, not JSX here, even if they're using the JSX syntax because it's not quite a component necessarily. I've seen it different ways. I don't think it really matters too much. For this one, it's just demonstration purposes that you can do both right now, but you know, do it how you like. Moving on, the app, pretty straightforward and it includes recipes. We added that component. And then recipes, this is our stateful component, just so we can showcase, you know, when you do need to bring in React. You'll need to bring it in if you wanna use useState. Okay? Now for this commit message, I'm just going to say add React.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "Something like that. Do whatever you like. Push that up, since we haven't pushed in a little while. So that'll wrap up that section. And the next thing that's going to be really common in our app that we're going to want to support is images. Now if you'll recall, I made this section with a class name of hero before, intending to be a sort of hero section with a background image. And so this is about the time that I normally would want to bring in some images. So I'm going to actually copy some over just to save us some time here. I've got this folder that just has a bunch of images. And you can see it's a various different extensions, because we're going to make sure that we cover some different ones and not just one type. And then what I'm going to do is I'm going to make a whole new file here. And I'm going to make it hero.scss. And then what we'll do with that is we'll target that hero class, and we're going to have a background. And you can just use this, which is really cool when you're using Webpack Project, just like a relative import for where you are. So in this case, let's say we're going to go into images, and then we're going to do the SWC banner. And that's going to set the background. So if this isn't already obvious, a kind of cool note that I like to point out here is that, you know, we're able to import this like, you know, sanely from a relative path, because we're working with our source code. But eventually that's going to be output in this distribution folder. And those might all be flat, or they might have different locations. The main point is that everything's going to be different on the other side, and Webpack's taking care of that for you in the final output, which you'll see in just a moment. So now that I have this set, let's do some basic CSS as well, just to make it look a little bit better. So I'm going to go bgz, make that actually cover, background size cover, and then can I do bgp? I don't even know. Oh yeah, you can, but we'll do center, min, height. And for this min height, I'm just going to do 300 pixels. And then finally we'll do a width of 100%. I really wish that w100, whoops, w100, like, didn't do pixels, but I get it. Oh, and let's not forget that we need to import this. So we'll say at use, hero, and that should be good. Now let's run this, and we should see an error, since we haven't set up anything for it yet. It's a pretty weird error. It's right here, it's module parse error, module parse failed, unexpected character, and this cute little question mark diamond. And it's also letting us know that it needs an appropriate loader. Again, I wish that it could tell us a little bit more information about the type, but it doesn't, unfortunately. So it's just the way it is, and maybe it's really challenging. Now, how you would solve this in the past was that you would use a file loader or a URL loader. Those are the two plugins that I've always reached for before. But in Webpack 5, it's pretty cool. There's actually a built-in way to do this without any extra packages to be installed, and I'll show you that right now. So what we can do is add a new rule to our rules list here. And this rule, we're going to do a test for it, just like normal, and we'll make that case insensitive, because we might as well. And then this test is going to be just like our other ones, but this time we're looking for file extensions, right, for images. So png, you can do jpg or whatever you're specifically doing. You can also just do this, so that, like, optionally it has the jpeg or just jpg. Then we're going to do gif or jif or whatever you like to say, and then svg. And then here, we're just going to say it ends in one of these. So we're looking for all these types of extensions, so we can kind of do a good catch-all for all those. And next, normally we would put a loader here, but actually all we have to do is say type, and then I'm going to show you the first one here is the asset resource. Okay, so notice that at this point, this is what our dist folder looks like, and I'm going to flip over here, npm run build again. So we get one more error here, and if we come up here, we'll see that this automatic public path is not supported in browser, and you need to look up one for this mini-css extract plugin is where it's happening. This is a pretty good gotcha. I got stuck on this the first time I did it for quite a bit. Let me show you how to get around this. So what you need to do is this mini-extract plugin, you can pass these in as a string or just a series of arguments like an array list, but you can also pass in objects for each one. So I can move that up here, and then what this will be is this is going to say this is the loader, and for this loader we have some options, and that's why we need to do it in an object. And for the options we just need to put public path quote there, get rid of that line, and that's all we need. There was a point in time when I knew what this did, this public path here, but I was messing around with it the other day to try and refresh my memory, and I can't for the life of me remember exactly what it's for, but I know it's required at this step. So if anyone has any super cool knowledge about that that you want to drop in the comments, I'm sure everyone would appreciate it. I definitely would. I'd like to level up myself. So that should be all that we need. Let's run build. Oh, looks like I must have typed something wrong. Probably. Options. Oh, yeah, we got a typo. Sorry. Happens though. NPM run build again. And there we go. So now if we go back to our folder, we will see that there is this image sitting out here. Now it has renamed it with this little hash, that's normal, but it will be the exact same size as the original. I don't know if I can show you that. It might be kind of hard to see, but this 226 KB here, if we go to our images and we look at this banner, it's also that same size. So it hasn't changed it at all. There's no compression or anything going on at this point. Yeah, so now we have that in our dist folder. And if we were to let's go back over to our server. If we go to our server and oh, well, I didn't start our server today. Well, we can just look at the built one. And here you go. There's this little image and it's using the background position cover. It's pretty cool. And if you inspect it, you will see that the URL now points correctly to where this file is on my system. And that's that's the gist of it. Now, the other way that you'll commonly use images in Webpack is just to the standard import. Actually, I meant for this to be up here. So let me move that for just a quick second. And then what I'm going to do here is just say import. And then we can name this whatever we want. So I'll just name it Sword from and I'm going to go look up one directory into images. It's still a relative path here. And I don't know why I don't get auto completion on this one. It's kind of weird because you do in the CSS. I'm not sure if that's just a configuration thing, but we can go over to here in images and just say, OK, we want the SWC Sword PNG. So we'll use a PNG for this one. SWC Sword.png. And then this is just actually going to be a regular image tag. So we'll go image. Change that source to JavaScript and say it's here and then all will be sword. And then I'm actually going to give it a width just like to cap it out here. And I think that this will be about 250 pixels. So just to quickly go back over this, this is importing this as a path for a console log. This it will actually be the path to that file currently. And so that's what's going to happen when we run this. And let me I'm going to build for this just so you can see the assets each time rather than running Webpack Dev Server. So I'll build this again. And there's no extra configuration needed. We already have it set up. The only one we needed was that extra CSS property. But if you go up to the top here, you'll now see these two images. You'll see this sword that I just output and then this background. And if we go to look at it in the browser, you'll see the image is now loaded there and it's going to be the same. It's just going to be a file path that it finds. OK, so what's another type of image that we commonly want to bring in here would be a SVG. So let's make sure that that works. So from dot slash images with this exact same thing. But this time, this one's just called sword.svg. And here we will copy this. Sword SVG. Everything else can be remain the same. We're going to run that build again. Let's go make sure our assets are there. And here we can see this SVG output. And it's also all hashed and beautiful. And then if we reload, we'll have two copies of these images. One's an SVG and one's a PNG. And actually, let's take a look at that. There you can see that path. And now I'm just going to set up one more quick demo. And that is going to be here in the global. So in the global, what I'm going to do is I'm going to target all ULs and I'm going to make the list style image set to a URL. And then that's going to be my tiny little image here. That's this dot dot slash images slash. And then there's that 32 by 32. And this, the purpose of this will be revealed in just a moment. So let's go and build real fast and then we will be done.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "We'll go over to our browser and we'll reload this. And then when I drop this down, you'll see these cute little sword bullets that I've made just to show that. Now, why I'm doing that, like I said, you'll see in a moment, but coming back to this. If you would want to actually put these, you can see how we have all these like files right here in the root. Let's say that you want to put those for cleanup purposes into an image directory, just to be a little more organized, I should say. What you can do is you can add the output path or the output property here. And then just for that output property, you can do asset module file name, and then do images here. And then what they want is, this is just something I copied off of the docs. I know the hash and the extension, it's just those brackets are saying like that goes here. So we're gonna, anything that, any asset that comes out, just notice right here, these assets are gonna go into this folder images here. And then this last one that they always have is query. And I'm not sure what that is for, but they always have it on the docs, so I put it in. Now, if we pop over here and do npm run build, we will, wait till that finishes, come back here. And you'll see now there's this image directory that has all the images in it. Now, of course, you'll notice that all these old ones are here. And so what we'll have to do is delete all of those. And that is less than ideal, and we're gonna fix that in just a moment. But for now, we have all of our images in this folder, and it's a good opportunity to show you another type of thing that you can do, which is set this to inline. So asset resource is going to output all of these things. Asset inline is going to actually inline it into our JavaScript. So I will delete this directory just so you can see that. And then when I come and run npm build one more time, you'll notice that we get this warning. And it says in asset size limit, exceeds the recommended size limit, 244 KB, and can impact web performance. That's very nice for them to tell us that. Now, let's actually see, are things still working? Yes, they are. You know, we have all of our images, but look at when you hover over them, go away. It's just like big old crazy string, and you can see it says data image, PNG base 64. And what that means is that it has actually been inlined into our JavaScript bundle file. So if we go back here, we don't have any images in our dist, but if we were to look in main JS, and then let's just say we do a search for base 64, let's say, and here you can see this data image, PNG base 64, data image SVG base 64. So it's actually taken and made them all this base 64 encoded text output, and put them all into the JavaScript bundle. Now, that is not good to do for what we are doing for this purposes, because those are rather large resources, and that's gonna make our initial bundle very large and time consuming to download. But this can be really useful if you only have really, really small images, and that's because there won't be any additional requests required to hit the server for any of those assets, and it won't have to wait to kind of parse them out as it hits them in the DOM, they can just be loaded right off the bat. So maybe if you have like a bunch of little small icons that you wanna load in the header really quickly, that's a good time to do something like that. So that's the gist of asset inline, but there's a really cool little generic property that you can do that's just asset. And how this works is Webpack is gonna automatically determine based on a default max size, which is 8KB according to the docs, whether it should be inlined or whether it should be in the image directory. So let's try that out real quick. NPM run build. Okay, come back here. Notice as we have an images directory now, and we only have these two images in here. So we have this banner, and then we have this picture. Now the SVG and those cute little sword icons that I made, those are smaller than 8KB. Let me show that those work. Let's reload. Yep, there they are. And if you look at this one, it's base64 encoded for this. And if you look at this one, it's just a regular file path, okay? And if we go to the bullets, let me show that in the URL. Oops. Here, we can see that it is this base64 encoded drawing it from the JavaScript bundle. And so these can load really quickly if we needed them to, and the rest of them can just be resources in the final scheme of things. So I'm actually not sure what the most optimal way is to do this. My assumption would be just to leave it on asset as a default or go asset slash resource. But I think sticking to asset is probably your best bet. That's what I would initially recommend, but it probably depends on your use case and what you're doing. So if you're starting out, either asset or asset slash resources is probably the best default way to go. Let me show you one extra little thing that you can do that's kind of cool. So you can say parser, add this little key, and then do data URL condition. And then what you can do is max size 30 times 1024. Now why I'm doing this is where our normal max size is 8KB, but I want it to be 30. And that's 1024 bytes times 30. It's just a little easier and that's what they do in the docs. I think it makes sense to mentally math. And from here, I actually have made some of these just around that size, just to show that point. So if I npm run build, actually, you know what? We are gonna need to delete this first. Aren't we? So let's delete this. And what we should see is that only one of the images, the big old banner image should be in the final output. Let's see if that's right. Yes, it is just this banner. So now we've taken that PNG sword that used to be there. And because I've raised the max cap, you can now inline that. You probably don't wanna be dabbling in that unless it's like a small size adjustment or you just happen to know that. That's what you want, but that option is there. And I just wanna show that. So I'm gonna take that out and we'll go back with the default. Now, of course, you could split these tests up if you wanna handle different things in different ways. You might wanna break out your SVGs into their own and just make those all inline. There's a lot of customization that you can do, of course, in Webpack. That's the whole beauty of it. And also the double-edge sword, where it can get really complicated. And I also wanted to mention that I did do a test I did not add support in this for inline SVGs. We only have the image format to an inline SVG is where it actually writes the SVG code into the HTML, which gives you a lot more power if you're trying to like change an SVG with CSS. But that option is available to you. I'm not gonna cover it in this video as it's gonna add a little bit too much time to it. But just know that that's out there in case you wanna dabble in that. But for a lot of people's purposes, the SVGs just loaded in as the image are gonna be fine because you're still gonna get all that vector quality but then you can just treat it like a normal image with resizing and all that. So that wraps up this image portion for now and it suits our needs, but I'm getting pretty sick of deleting this images folder and individual images over and over again as I'm fiddling with the config and such. So what we could do is we could go into our package.json and make a little clean script. And let's say, let's make this clean. And then what we'll do is we'll RM, maybe say we do a dash RF and we do dist, something simple like that. The problem with this right now though, is that it will delete our HTML file and that's not tracked and we aren't generating that. It's the only thing we're not. And so that's the next thing that we're gonna tackle so that we can get sort of a purity situation where every time we wipe dist and we build it from scratch. And that's gonna make it to where it's a lot more realistic for setting up on our server. So let's make a quick commit just to review all that stuff. And yep, we added this little clean command that we aren't using, but we'll keep it around just for the fun of it. We learned about making a custom asset module file name directory here so that you could put all of your stuff in images. We obviously learned about the asset type and catching all of those. And then we had to fix for importing our images through CSS, we had to fix this with a little options config of public path. And so that's all for that file. And then of course we added our images here. Not too much to see there. We added all of these images. Now we didn't actually test an import of a GIF. We should have done that just to show that that works. And then for our global CSS, we added this little style just to be able to use that in our hero. Well, we added this new thing and then we imported that in the index. That looks good to me. So I'll say add image support to webpack. Pop over here, get push origin main. And now we're ready to generate out our HTML files from a template. Okay, so what we're gonna need now is we're gonna do npm i dash d and we're going to want to install HTML webpack plugin, very common plugin in this world. And then what we'll need to do is go to our HTML file.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "Go over to our code. And in our webpack config JS, we're going to want to import that first. So we'll say const. And then that we'll just call that HTML webpack plugin, pretty standard here. And then we're going to acquire that. And that's HTML webpack plugin. And then we'll go down to plugins here. I don't know why I went back up there. And we need to add that to this plugins array. So we'll say new HTML webpack plugin, call that. And I'm not going to pass any options just yet. So I'll show you how that works in general. But what we will need to do is we're going to take this index HTML, we're going to drag it on down just into source and move that. Okay. And that's going to put that here and make it tracked now, just so that we can save that. And then when we go over to here, we can actually be crazy and run npm run clean that script we just made. And that's going to remove our dist folder, which is kind of scary. Now it's gone. But if we run npm build, all these things will be generated out, you'll notice that there is this breaking change error, we're going to fix that in a moment. But let's just start with this and show the dist folder has been created. It's got images and look, it has an index HTML. Now if we format that actually look at it, it's cool that it's been minified and all that. But you'll see that it has automatically added main CSS here. And main JS here, you might notice that it's missing our little root ID tag that JavaScript or that JavaScript that react is attaching to. And that's okay, we're going to fix that in just a moment. But this is pretty sweet for it to automatically detect that we're going to have a main CSS and a main JS and just put those right into it. Cool. Now also notice that it says webpack app. And I believe our said webpack project. So that's different as well. It's just the default. So I'm gonna close that for a second. And then what you can do here is you can add an object when you call this. And you can set template to a template. And this just takes a relative path. And it's going to go to index dot HTML for us. So we're going to point it at that file we just copied over because that has our div with an ID of root, that's really the only thing we need. But we might add other stuff in here as we move on. So this is our template that we're building it from. So let's try that again. And what we'll do just to test it out here is we're going to delete this for now. We're also going to have what we'll do it with our script, we're going to have a way to do that in an automated fashion in a moment. But for now, let's just do npm run clean. And then npm run build. Let's go take a look at that file. As soon as that finishes. And see what happens. So now our index HTML, or added again, is it's got duplicates. So it does have our ID root. But you can see that it's injecting these things for us. But then we have them to start with. So all we need to do, I just want to show you that that's kind of how that works. All you need to do is just remove these, it's going to take care of any of our dependencies like that for us, which is pretty sweet. Okay. And then that takes care of that. And then the the error that we were running into before this breaking change thing, hopefully, in the future soon, this will also be solved. But there's a temporary problem where HTML webpack plugin is producing this error that you can fix by doing I dash D. And then when we install HTML webpack plugin, you can do at next. And that's going to do like the latest beta version. So we'll see as soon as this finishes, it's going to do beta mines 500 beta six, in case you end up following along. So I showed it in this order, because I don't think you should install it with the next flag. Unless you actually have this this breaking change thing, you can just stick with stable because by the time you watch this, it might already be fixed. I'm not sure. But from there, let's just try it one more time. This is hopefully the last time we'll have to delete this bucko. And then we will NPM run build, I guess I could have used my clean script. I keep forgetting that we just made that. And there we go. And that error is gone. Awesome. Now, we could solve this next problem of cleaning automatically instead of having to do it manually by going into here and saying, Okay, well, when you run this, you could do NPM run clean and and but then you'd want to do that on pretty much all of these and also with the web pack like serve doing it, it's only going to run it on the first time we want to kind of do it on every time. So there's actually a really cool plugin that will take care of this for us instead of us doing it that way, called clean web pack plugin. So we're going to add that clean, a pack plugin. Now only to update our web pack config for that as well. So we're going to bring this in. And this one's actually going to be destructed from it. So it's clean web pack plugin. Oops. And that is going to be brought in from the web pack plugin. Now same song and dance here, this should be getting kind of familiar to you. This is how you handle a lot of plugins here is we're going to do new now I think this has to be at the top. I've always seen it put at the top in most situations. I haven't actually played around with I should sometimes see if moving it around makes a difference but I just recommend putting it at the top for now. And so we just need to add that on to this the top of our array. And then now when we run npm run build, you'll see that we get this little bit of a warning here that says clean web pack plugin options output path not defined the plugin is disabled. So unfortunately right now, with this plugin, what you need to do yet another thing that may be fixed is you need to add a path property to your output. Now normally you don't have to do that. A lot of people do anyways. And that's why it's still around web pack five was the first one where you didn't have to do this, I believe. But for this plugin, they haven't updated it quite yet to that state. So maybe hopefully soon. But what you can do is you're going to do path dot resolve here. And like I said, you don't have to do this normally. If it's the default path. But if it you will commonly use this if you want to change your output path. So if you want to change it to not be dist, and you want it to be public, you know, you could just do that here. Now let me break this down real quick for you while we're here. Actually, you know what, let me get this working first. And then I'll do that. So I'll say const path equals require path. Now if you're not familiar with this, this is just comes with node, you can just require it, you don't have to install it. But let's see if this works. Oh, did I do? Whoopsie. That was supposed to be a string dist. Whoopsie daisy. Sorry. Okay. And we don't seem to be getting the warning that it's disabled anymore. And we can look and see that our stuff was output. Fantastic. So now, you know, let's actually let's make sure. So to be certain, let's add some gibberish file dot txt, right. And then this will be right here. And then if our plugin is working, right, and I run npm run build, it should remove that because it removes the whole folder, and then build out all our code into there. And you can see that file is gone. So pretty confident that it's working there, right? Okay, so this is a pretty common point of confusion. It was for me for so long, and I still even forget the gist of it every now and then. So I want to go over just really quickly this whole path required dur name thing, because it's kind of weird, right, that like, we can use relative paths all over. But for some reason, we just start doing it right here. Let me actually show you, you know, the best way to learn is just to break it. So let me actually show you what if I were just to say, Well, yeah, go put it in dist. Will webpack care? Yeah, it actually says, initialize using configuration object that doesn't matches. And we can look at dist is not an absolute path. That's a pretty good error, actually. So it is telling us that it wants an absolute path. Now, if you run node, just regular old node right in the terminal here, what happens if you type path dot resolve, and you call that, you'll see that it automatically resolves to where we currently are an absolute path. And then if I were to backspace and just put dist from there, you'll see that it resolves the absolute path dist. So that's what path dot resolve is doing. Now kind of a gotcha here, though, is that if you were to CD up one directory, and then we're going to do node again, and path dot resolve. See how it's telling us that it's going to be only up to this point. So what path dot resolve does is it's wherever you're running that script from, you can also use CD dash space dash here to go to the last folder you're in just a little trick there. So path dot resolve is going to give you an absolute path. Well, what is der name therefore, well, der name is the directory of which the file that you're running this command from that where that directory is. So that's just going to give you the directory, but then path dot resolve.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "Resolve is going to give you the absolute path to that directory. So that's why you need these two combined in this situation, because during only as far as I understand, only exists when you're running a script. So essentially what we've put all this together for this nice little path thing. This is a really common pattern and node. You're going to see it all the time is that we just want to know what's the absolute path to the directory that this web pack configures so we can build everything from there. Oh, another thing to know, actually, is that this path resolve way is also going to work universally across different operating systems as well, which is useful for that purpose. So I'm out of my depth to really explain much more than that. That's just what I know about it. But hopefully that gives you a little bit of insight, a little bit of clue into it. And in case you didn't really know that or it's a little bit of a refresher for you. I need one every now and then. Now, let's seal the deal here by going in and adding these last files here. So in our package, Jason, all we had to do is add this HTML web pack plugin and clean web pack plugin. And then for our config, we obviously brought in path. We brought in the HTML web pack plugin and the clean web pack plugin. We had to set up an output path in order to use that. And then down here, we added it to our our plugins array. And we have that template. And then we should also obviously be tracking the index HTML template that we're using now. So there's that. And we will say. Add. Web pack, clean and HTML plugins. Push that up. And now we are in a very good position with the addition of these recent plugins and the fact that we have this set up to where our dist is wiped every time and then rebuilt and everything from it comes from our source. We can now host this. OK, it's finally time to deploy this on a server, which is pretty exciting. So there are a plethora of ways to host this, but we're going to use Netlify because it's going to be really fast and it's so awesome that it's just the clear choice for me, honestly. So let's go over here to the browser again. So let's head on over to Netlify. And you search that in Google and get there, and it's going to ask you to log in. And if you don't already have an account, you can make one with GitHub. I think that's the best way to do it, or it'll just ask you to log in if you already have one. And so here we go. This is how it works. And if you're not familiar with Netlify, just a real brief introduction. It's really popular for hosting for the JAMstack. Or any sort of like static files. And since we're using a pretty simple React single page app, this works great for us. So new site from Git. You can go to GitHub and it will usually add a little GitHub plugin for you. You can say configure in the Netlify. If it doesn't show it here, let's see if we see Webpack project. We don't. That's because I'm not sharing all of them. You can choose to share all repos or select ones, which is pretty cool. So if I come down to here and I say Webpack. Oh yeah, mine's config, right? So we're going to add that to the available ones. Save that. And now my Webpack config, I click that. And what's really cool is it is going to know the branch to deploy from. Now that's going to be whatever branch, like typically you're going to spawn off from your main or your master or whatever. And then this npm run build it detected as the build command. Isn't that really sweet? And then the publish directory is dist. It just did all that for us. So now we just click deploy site. It's pretty amazing. And what's really sweet about this is that it adds continuous integration for us, which is really awesome. And what I mean in particular about that is that every time that we push to master, it's going to auto deploy a new version of the site. So what it'll do is it'll build it. If it has any errors, it won't host it. So it won't break your current site if it have you push up an error. But if it's a successful build, it'll spin down your old one after it replaces it with a new one, which is really, really awesome. Now let's go to that build and run build. Post build command. Now if I build complete, cool. And then that'll show right here, published. So this is your URL. Now you can obviously buy a domain and set up all your stuff and SSL certificates and all that. We're not going to do that in this one. We're going to make this pretty quick, but look at that. We're hosted now. So does it work? Yes, it does. You got your cute little JavaScript clicks. I need to get rid of these images so that it actually fits on the page. And then let's go see if, you know, our script's running. Yes, you can see our objects here. It's really cool. This is just a favicon. We don't have a favicon. Classic 404. All right. So there we have it. And we're hosted. That was really easy and really cool. All right. So we've made it all this way. We have our site hosted and I have one last thing to share with you. I've left it to the end because currently it's in an experimental phase for Webpack. But that is for React Fast Refresh. So React Fast Refresh is the new hot reloading thing for React that is really, really cool. It's going to be supported by the React team. Dan Abramov has been working on it for quite some time, doing a lot of cool integrations with it. It was originally developed for React Native and it's just kind of coming around to the web as support grows for it. But for now, there's an experimental package we could use that works pretty well so far. So if you're not interested in seeing that setup, then you can call it good here and that's fine. But if you are interested or curious at all, you should stick around because I'm going to show you why it's pretty cool. And there's a little gotcha that I ran into setting it up for Webpack 5 that I'm going to show how to get around. So to show this, first I want to show what are we solving with this? Well, in our project, if we say npm start, we start that up and we're going to go back to our local host server. We have this setup and actually to make this a little more clear, I'm going to get rid of these images temporarily. And I'm going to get rid of these two just so that you can see that on screen. All right, and then I'll go over to the console so you can see what's actually happening here. So it says hot module replacement enabled as we showed before, and we know that's working for our CSS. And if we click the different state positions here, well, what happens if we were to change the text here? And I think I should probably do a side-by-side for this. I think it's going to be the easiest. Oh, man, so crushed. This is going to be tough. Okay. If we let's say that we click the state and we want to see that state here staying there, and then we want to change some text. How are you? Why did I type real stuff there? I don't know. Instead of gibberish. Notice how we saw some stuff loading and then it hard refreshed the page and we lost our state, and that's why. Let's do that again. So watch when I save this file, you can see this little guy respin, and then this whole log will reload once again. So live reloading is working, but we don't actually have hot module replacement working. But I do want to show just to be clear before I move on that if we click this state right here and we say change, oh, I don't know, the global FC to 20, what did I do, 26 before? Save that. Yeah, that still works, and it still keeps the state. So our Sass, any of our CSS hot reloading is still currently working. It's just our JavaScript that isn't working right now, our React in particular. So there's already a hot reloading for React that you can currently use, but this is essentially the new cool thing that the React team's been working on. They've mentioned that there's been some bugs and issues and even TypeScript support issues with the current hot reloading plugins and stuff like that, and that's because it wasn't actually maintained by the React team. And so this is what they're working on now, and like I already said, it's in React Native supported, but the support in the browser so far is kind of limited depending on your bundler system. But someone's been awesome enough to work on an experimental plugin for it, and so that's what we're going to throw into the mix right now. So in order to install that, this one I am going to copy over because I'm never going to type this correctly. So if following along, you might want to search React Refresh Webpack plugin to go find it or the name, or you could just obviously type it in 3Ms here. But we're going to install that, which is a person who has been kind enough to set this up for Webpack and getting that going, and then React Refresh, which is actually from the React team here. So we're going to install those two packages. Now what we're going to do is we're going to go over to our code, and we're going to need to edit our Babel file first. So all you need to do is go to plugins, and then you're going to do React Refresh slash Babel. And then you'll also want to go to your Webpack config, and then you're going to want to bring that in, just like the other plugins. So in this case, we'll do React Refresh Webpack plugin. It's a mouthful to type. And then we're going to require, and that's this P, what was it, at PM. Such a long name. There we go. And then scroll down here.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "To our plugins. And we're going to throw that into the mix. So I don't know if it matters exactly what position that you put it in here. Actually, I'm going to put it here at the bottom. Oops, React Refresh Webpack plugin. Save that. And let's try and run it. NPM run. And actually this would be NPM start, right? Because we're trying to get hot module reloading. Okay. This is where I got got for a little bit. I'm going to show it, just so you can see. Let's reload the server here. So it says hot module replacement enabled and live reloading enabled. So let's see if that's actually true. For now, let's just go to our app JSX. And here, let's try the same thing. I'm going to just click something to get some state onto the page. And then I'm going to type some gibberish and save. And look at that. It didn't actually change our title at all. It said that it hot reloaded here, and it didn't refresh the page, but it actually didn't update anything either. I'll do it again, just so you can see. It doesn't really update anything. Blah, blah, blah. That's really unfortunate. I almost gave up on this one. But after a little bit of spelunking, I was able to come up with a solve for this, thanks to trusty GitHub issues and the lovely people there. So the solve is actually pretty silly. What it is, is that they were not counting on the fact that Webpack 5, you don't have to put an entry point anymore if you want to use the default. So unfortunately, we will need to add that now, and we'll say the entry point is source.index.js. So you can use a relative path for this one. Why? I actually don't know. Output seems to be the only one that really requires an absolute path. So let's try that again. npm start. Restart that server. And let's see what we get. Go back to app. So hard on this squished view. Reload this just to make sure that you've got the current one. Click some things and then let's see. Cross our fingers. Yeah! Look at that. So now, when I change things, different HTML or text or whatever, I can even, I'll go into the, let's say, recipes one. And I can go down here and I can change this to whatever. And you can see this button change, but we keep the state. So that's really cool. So that's all it took. That will be the fix. It's a pretty easy fix, thank goodness. I mean, you know, it doesn't feel very satisfying considering the hours that I spent trying to look it up, but you know, there it is for you. I don't know if it was actually hours. It felt like an eternity. But yeah, now we've got that working. Now let me show you how cool this thing is. So the first thing that I think is super fancy here, I'm going to get rid of this just so that you can see it a little bit better, is what if you have an error when you save? What's going to happen is it's going to tell you exactly where that error is happening, and then if you just go and fix it and save, you get your app back. Now, if you didn't notice that, this is pretty crazy. Your state is still there. Let me refresh so you can see that. So I'm just going to, like, you know, make some sort of syntax error. I'm going to save. It tells me where it's at. I'm going to re-save. Here we are. Now I'm going to click this button so we have all four of the bullet points. And you know, let's just, I don't know, what's something that we can delete? It doesn't really matter. We'll just delete that. Okay. Re-save that. And we're still keeping our state. That is awesome. Now this also supports React hooks, which is worth mentioning because with hot reloading, the old plugin, you had to do additional work to get that support. And this just comes out of the box, which is fantastic. And obviously you're seeing that right now, but I just wanted to point that out. Now, in order to show a cool concept and to illustrate this a little bit better, I'm going to create one more component. And we're going to name this whatever.jsx. We don't really care. And in this component, I'm just going to copy-paste some code to just make this really fast. I'll paste this, save that, and then I guess in my app, I'm going to import that. So I'll say import. Actually, let's see if it'll auto-import for us. TypeScript always does, but sometimes it's iffy otherwise. So let's say we now want to call this whatever. It looks like it's going to do it for us. Amazing. So now we've got whatever loaded. And look at that. It loaded the new component. It just kept the state and everything. It's so cool. And so why this is really useful is you know, imagine that you're like filling out a form that you've built that's a controlled form or anything else like that. And you're trying to test different stuff out, but you want to keep it in the same state. Maybe it takes like several steps to get to a particular state, and then you want to make a change and see that. That's where this is really going to pay off. But let me show you something that's really important. So in this whatever, I have a state and set state as well. And all I'm doing is just making it to where when you click the button, it says button clicked. It's very dumb. It's pointless. But the purpose is to show that just to show you again, you already know that if I change this the state is going to stay the same. We already know that. That's cool. But what if I like remove some stuff from the DOM here? Ooh, what happened there? Well, we lost all our state. That's because the parent has to re-render. And when the parent has to re-render, all its children are going to re-render. Unless you're setting them up in a different way. But let's not get into that. So in this case, what I want to show is that if we go to, let's say whatever here, I'm going to click this button, I'm going to click this button, and then I'm going to delete the h1. And notice that it did do that. Actually, you know it's a better example. Let's do this. So with this button clicked, I'm going to delete the button. And now notice the state kept it saying button clicked even though I deleted that button. So it kept the state for itself and it also didn't re-render this other component because they're sibling components. And I'll do the same thing for recipes. We've got our state up here, and then if I go down here, and let's just say I wipe out these buttons or whatnot, I'll still have all of these bullets here, and I'll still have this state here. And that's really cool. So these two are siblings, they're not affecting each other. And that's just showing some of the power of fast refresh. So again, this is really awesome. I'm so excited for this. It's fantastic. I want to show you one more feature real quick of this that I learned while I was doing this. So you can add this pragma to the top here that says refresh, at refresh, reset. So this comment in this style with an at here is known as a pragma. We're not going to get into that but this is a way to add a little custom functionality to just this file. So what's going to happen here is now when I click this and I change some text and save, notice that it wiped the state, even though it normally wouldn't. So why that is, is this little command here is like, maybe we're a little bit too hot module reloady for you, and you really do want to wipe state every single change. Well you can just add that little pragma or that directive at the top there, and that'll change that. Now that I wiped it out, just to show you again, you know, I've changed the state and I add something here, and the state stays the same but this thing uploaded for it. So you actually have this option to opt in to kind of force a reload on a file by file basis. Yeah, they've thought of everything. So that concludes a quick little demo of React Refresh. It's very exciting, and I'm glad to have it working in Webpack 5. There's just one last step that we need to do in order to keep this production ready. And I'm going to show you that right now. So if I do npm run build, I'm actually going to get into an error. Unfortunately. And it says, React Refresh Babel Transform should only be enabled in development environment. So I just wanted to get that working to show you that, but now what we need to do, and I'm going to make this full screen to make this a little bit easier to read again. Whew, it's a breathing room there. We need to change our Babel config and our Webpack config to only enable this when we're in development. And the easiest way that I found to do that is I, this is why we used a Babel config in the first place, actually, for stuff like this. I'm going to set plugins. I'm going to make it equal to an empty array. And then here what we'll do is we will set this, let's cut that out real quick, to just plugins. And then what we want to do is do a check and say if process.env .nodeenv is not equal to production, so if we're in development, we're going to do plugins.push and then we'll do react refresh Babel. So this will say, you know, by default it's an empty array, but if we aren't in production, then we'll add this to it. You might have a better way. Feel free to leave it in the comments if you thought of something smarter, but this works for me. Now, Webpack config, we need to do a check.", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "We're going to do kind of the same thing here. And because we've already set up this if statement this way, it's actually not going to be too big of a deal. So what we're going to do is we're going to say const plugins equals, but a little bit different on this one. We're going to go down here to this plugins array, and we're going to cut this whole thing, move it to the top here. So we're going to start with all of the plugins here that we have by default. What we can do is we can come down here and say else, because here we're checking if node environment is production, and we don't want that there. But we could say plugins.push if it's not production. I want to push, and then we'll just snip this little line out here. And I guess we don't want the comma, but I'll get rid of it later, I guess. Cut that there. There you go. And then what we need to do now is go down to plugins and say plugins, plugins, plugins, something. Go back up. How come you're not formatting? This comma? Yes. It's always something. Okay. All right, there you go. You've got your build working. The build's working, and then let's also make sure that we still have fast refresh because we don't want to lose that. So we'll go back to here, bring up our browser, and then let's say we're back to this world again. So then we go to app, and let's just make sure that with this, man, wait, let's reload. Let's just make sure. And then go to here. There we go. Okay. So that sums that up. I'm just going to really quickly recap over this one. Well, let's do it this way. We'll finalize this whole thing here, right? So we started here with this babel config. We needed to set the setup that we just did so that we can kind of dynamically add the plugins. We know what's going on there. And then in our package.json, we've added these two packages. Yes, we know that. We have our webpack config. And this is where I'll kind of just really briefly go back over this again in case anyone misses this. So what we're doing is we're moving the plugins up to the top, and we're saying these are going to be our default plugins that we're going to have no matter what. And then if we're in production, we don't do anything but then else, which means we're in anything other than productions, probably going to be development, then we're going to push this onto the stack for just development so that doesn't break the build in production. And we needed to add this entry point for react refresh to work, because it wasn't auto looking for that it wasn't inferring the default from webpack config. And then finally, we just call those plugins down here. So move on to this, we just made a new component for demo purposes. Nothing really too much crazy to see there. And yeah, we can throw that in there. Why not? And then we'll say add react, refresh for development. Fast refresh, whatever you want to call it. Now this is where it's pretty cool. And that's why I wanted to take you through this last step. So when I get push origin, oops, main, let's go back to the browser here and see what happens. Get over there. I'm going to refresh. I don't know if this auto loads, maybe it does eventually. And you'll see that we already have a production build building because we pushed up and that's part of that continuous integration that we got from setting up with Netlify. So if we were to refresh this when this is done, you know, it'll change with our new content changes. And that's really sweet. See this is already done. Yeah, so fast. It's amazing. So reload here and boom, we've got our new stuff. All right. Ooh, I almost forgot a little gotcha here. I've got one last thing that we need to take care of for our react, refresh setup. And that's that when you run NPM run build dev, you're going to get an error here. And I got stuck on this error for a bit as well. But it's really just because when I for this little fix that I've made, it says process env node env equal to production. So where are we in the production environment? And that's when we're going to set that but else so in any other situation, we're going to do react refresh webpack plugin, but we actually only want that when we're doing the webpack dev server and live reloading. So it's going to try to look for the webpack plugin down here. This is what I've deduced that it comes from is that now in the newer webpack when you just set hot to true it automatically loads in the webpack hot reloading plugin, which it didn't used to do. And this is relying on that and it's not finding it. So all we need to do here, I just have a quick silly little fix here. What I did, you can do this however you like, but on my build debt or my webpack serve, actually, I want to set this another environment variable and you can make anyone up you want. And I'm just going to set it to true it could be any property that you could check for or whatever. And then when I come back here to webpack config, instead of doing this else, we can just do another if so let's put that on a new line. And we'll say if process dot env dot and then we'll do serve is equals equal and you can name that whatever you want. And then let's just set that well actually you know what since it since it's anything if we want to set to anything, let's just say is that set at all. And if it is, then we will go ahead and push this reactor fresh webpack plugin on there. Let's see if that works for us. Okay, and that looks like it's all working. We'll just really fast check our main js output. And there we go. We have it all here and building in the dev environment. And then if we do npm run build, you know, we always want to check our other ones just to make sure that we didn't mess with them at all. That's going to work as well. It's going to be all minified and all that good stuff. And then finally, if we do npm start. Oh, and can I click this control click now? Nice. Okay, well, that's new in Windows Terminal. I've been wanting that for so long. All right, sweet. Well, now we can see it loading our state. So working fine. And to make a quick check. And then we'll just go into app jsx here. And then I'll just change the text here and make sure that it live reloaded or hot reloaded, sorry, without changing the state or anything like that. So everything's still looking good. And that's all there was to that. Now, that might not be the most elegant way to deal with this problem. But it works for me right now. And we're in this kind of experimental mode that you might not even be in with this plugin. Hopefully it'll be a little more polished in the near future. But for now, I just wanted to show that because I had to do a little bit of troubleshooting to figure that out. And hopefully you can skip that whole phase and this will just work for you. So that is going to wrap up this whole video. And I know that was a lot of stuff. But hopefully, you've got a good concept of how to put all of these really important pieces together to create a whole webpack project. And the whole purpose for me is that at this point, I know that I probably didn't cover every little flavor and every little plugin that anyone could want, I can't really do that. But it's at a pretty good spot right now where it's extendable. You've gotten the gist of like what it's like to continually add loaders and plugins and all of the new cool webpack five, fable seven features and all that good stuff. Plus, we got the latest react refresh working. And so now it should be in a really good spot as a starter project or whatever for you to extend it to whatever your needs might be. So yeah, if you stuck it out all the way through this, congratulations. That's a ton of distilled information to take in. But hopefully you're a lot wiser for it and ready to move on with your own webpack projects. So thanks for watching, and I hope to see you in the next video. Bye. That's probably pretty bright for you isn't it baby?", "metadata": {"title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}}, {"page_content": "So TypeScript has continued to increase in popularity and more and more companies are adding it to their tech stack, they're using it for their enterprise apps, they're converting old apps to it or using it for brand new apps. But there's one type of problem that TypeScript's not really equipped to solve right now and that's runtime type checking. Particularly when we're fetching resources from an API or something like that and we have to type check them, we really just have to tell TypeScript like this is what we expect them to be, but what they come back could be completely different and there's no way to do that until runtime. This is a problem that Zod is trying to solve which is a runtime type checking library and there's other ones around like IOTS that have been around for a bit but Zod is getting increasingly popular. You might have heard of TRPC, that's actually how I was introduced to it. It uses Zod under the hood. And what I realized that I wished I had known going back is that I would have learned Zod first and seen what it was doing and that I could add it to my project all by itself and get a lot of awesome benefits. And now as I'm using Zod more and more and more I thought I'd throw a little video together as an introduction to it, some of the properties of what its promises are, what it can immediately deliver for you, and some of the cool little helper utilities that it has. So if that interests you, let's start coding. So we're going to start off with a project that I've already created here to save some time. This will be up on GitHub and the link will be in the description. But all it is is it's a really simple just starter npm init with some TypeScript and the TypeScript init made so that we have our TS config going. You're probably familiar with this if you do any TypeScript type stuff. We do have Zod added, we're not using it just yet, but we will. And we have node daemon with TS node added so that we can watch our files for saves and stuff like that, and it'll automatically rerun. So we can use the start script here to start that daemon up. And here we have an output here. So all we have is this TSX or this TS file. And let me get rid of this and hide the sidebar so you can have some real estate here. So what's happening is we have an async function. And that's probably the one thing to note here on this project that might be a little weird for you is there's this experimental warning, fetch API is experimental. That's because I'm on node 18 right now. You might be further in the future, or depending on when you're doing this, but you don't have to use the native fetch. If you're worried about that, or if you're having issues, you can just use node fetch or isomorphic fetch or any, you know, Axios or whatever fetch library you want on node because it's not going to matter. It's all the same for what we're doing. In this instance, I'm just using the native one. So with async function, fetch person, we're just awaiting a fetch, and we're capturing it in a results variable. And we're fetching the Star Wars API, which is a sort of like open source dev API for kind of testing out different JSON queries and API responses. So from that, then we're going to call our function in the same line here, and then on it and we're going to get this person back and we're going to log it out. And that's what we're seeing here over on the side as a results there. So we don't have any types or anything like that yet. And that's on purpose because I want to show what the problem is and what Zod is solving or one of the things that it's solving. So the problem right now is we have this person and it's an any type. So I'm not really getting any TypeScript goodness. If I try to access name on this, that will work. But that's just because it happens to be there. If I did wolf on it, it's going to tell me that's just fine and that it exists or whatever. Okay. So what I want to do is I want to be able to go up here and let's add a type real quick. So I'm going to do an interface person. And on that, I'm going to say it has a name that's a string. And I'm going to use height here. And I'm going to say it's a number even though it's not. Let's just like make a little problem for us in the future so that we can showcase it in this demo. And then I'm also going to go a step further. I'm going to say lightsaber colors is a string array. So that's definitely that whole properties not on there. So the problem with this right now is that even if I type it like this, these properties are kind of a lie. And I'm going to show that real quick by saying, well, let's step down here and say there are multiple ways that you could type a fetch response. But really, a fetch is going to come back as any and you kind of I like to think of it this way, you're kind of lying to TypeScript, because you have to tell it I, hey, you know, let's for example, this results, hey, this is going to come back as a person, that's what you need to do. That's one way to do this. And when you're doing that, it's not really guaranteed that that's going to happen. You don't know even if you built the API yourself, you've done version updates. So the code itself is in a state where it doesn't know what the response types are or anything like that. You just have to tell it like, hey, I know what I'm doing. This is what's going to come back. So we'll just type based on that. If you work with TypeScript a lot, you're comfortable with it, you do API type stuff, you're going to be familiar with this. Other languages have runtime ways to solve this. But for now, this is what we have. And it can work fine, you just have to update it. But it can really as in a scaled project, it can kind of get annoying. And you can get some really nasty bugs that can be tricky to track down sometimes. So we could do it that way. We could also do, we could cast it as a person here, if we want to, typically, you want to avoid casting with as if you can avoid it other ways. But in this case, it's all the same thing. I'm going to do it the way that I like to do it. So we can move forward. I like to do promise person here. I know some other people do too. And really, it doesn't matter in this instance, it's just because, at least I don't think it does. It's because when I look at this function, I can tell what the return type is really quickly. So if I, you know, I'm perusing through the code, that's the only reason I like it that way. If we go to the fetch person here, we'll notice that it returns a promise person. And it would say that no matter what we did it, it would infer it because TypeScript is pretty smart there. So now I can do person dot name, right? And it's actually going to autocomplete for me, it's going to tell me all the properties that I have. But notice that it tells me I have lightsaber colors here. Okay, well, you know, what is that type? Oh, it's a string array. So I should be able to get zero on that, right? Your app crashed. Why? Because you tried to read a property on undefined, but TypeScript couldn't help you couldn't tell you that that doesn't exist because you lied to it, you told it that it existed. So this is where Zod comes into play. This is pretty cool. What we're gonna do is we're gonna just import Zod. We're gonna import Z from Zod, I'll let that complete itself. And then I'm going to get rid of this type for a moment. I'll just comment it out so you can see it for reference. And then what we're going to do is we're actually gonna make a regular variable with Zod. So we'll call this person, I'm gonna name it uppercase as well, you could do lowercase, some people like it either way, you'll see why in a moment. And then I'm going to do z dot object here. So when I call z dot object, it uses this sort of builder pattern in Zod, where you say, okay, you can kind of chain these methods on to each other, you'd probably familiar with this like map filter, reduce all that type of stuff. So we have a name, and we want to call it z dot name. Oops, not name, z dot string, please apology me. And so this is essentially how you're typing, you're saying this, I have an object with this shape. And it might be familiar to you if you do react prop types as well, things like that. I can say height is the z dot number here. All right.", "metadata": {"title": "Catch Type Errors at Runtime with Zod: An Intro to this JavaScript Library", "url": "https://www.youtube.com/watch?v=evX18f-n4AI"}}, {"page_content": "height is the z dot number here. All right. And then let's say lightsaber colors. What we would do here is we do z dot array. And that's an array of what what's an array of z dot strings. See, it's kind of interesting, you pass it into this thing. Now we're almost there. But we just have a we have a variable. Now we don't have a type. So you might think you do type of but the way that you actually want to do this is you want to use Zod's inference type. So now we're going to say type person equals z dot and it has an infer method here. And then you do type of and this is person here, this variable, that might be a little confusing to you because it's uppercase person, you could do lowercase here if you want, it doesn't really matter. So now I have this type person. And then we are almost there. But we actually need to still parse it because notice that we didn't add Zod as a development dependency, this actually is in our dependencies, it's going to be part of our code. So we need at runtime for this to run and check the types and how we're going to do that is we say const, I'm just gonna name it parsed results. However you want to do it, you take the type, which is person here, and then you have this parse function. And then you're going to pass it in something to parse. And then you have that and then what I'm going to do is I'm going to return that parsed results. Okay. And then what I'll do here, well, let's just run this first. So let's see what happens. So when I run that, I still get an app crash, right? But notice that I get this nice little bit of syntax here, where if we kind of go all the way up, try to keep this higher so that I'm not blocking it, you'll notice that we get this Zod error and you can read it up here or down here, it actually is going to try and hone you in on right here, Zod intro index.ts, actually right here, index.ts 21. So this is where the error is occurring, line 21. But the main thing that I usually use just to kind of glance at it is you can see it has these two issues. And it says, expected a number and received a string. And then it also expected an array here and it received undefined. So essentially at runtime here, you're getting instead of it actually getting the point where it would randomly try to access this part in your code, which could be, you know, deeply nested somewhere in your logic, you're getting it right at runtime. Even if you don't use anything, let's actually show that that probably be better as a representation, huh? So we'll just console log person again here. And when I rerun this, let's give it a second here. There we go. I'm still going to get this. So even though we haven't illegally used this object, we're going to get an error while we're developing right away. And that's really the value here to me. This is the main thing that I think Zod is solving. This is the main thing I'm interested in for and I think many other people. So let's fix this real quick. And so we can kind of see it running normally and get some of the cool helpers and stuff like that. So I'll get rid of that old type. And then what I'm gonna do is I'm gonna get rid of this property because we know this doesn't really exist. But let's just hone in on this for a minute. This is pretty interesting. If we run this again, what's going to happen here is we're only going to have this one error issue now that it expected a number and it received a string. And this expected number received string here. So all I need to do is actually tell it that it's a string, because that's actually what it is. And then now we're going to be fine. And you probably can't see this, I'm kind of blocking it. But now we're just logging out this object here. Okay, let me hide myself real quick, just so you can see. Now there's this object here that's being printed out, because I can't make the terminal go down any further. And that's kind of interesting. So what's happening here is that if I console log right here, I'm going to say fetch results, and then I have just results here. So this is the original results we got from the fetch. And then right after it, I'm going to console.log, I'm just going to put some stuff here, Zod results, we'll say Zod parsed. And this is parsed results. And I'm already making an error because I'm a noob. Okay, so I'm just logging those two things out. And what I'm trying to show here is that when I when I log out the actual fetch results, it's the whole thing. But when I log out the Zod parsed results, it's just the things that we told it it would have, which is pretty cool. So it's actually paring down all this information and saying, look, you're only going to get what you expect out of this type, which is another nice little thing that kind of cleans that up, you don't have a bunch of dangling properties that you have access to that you don't know that you have access to, you can have to be explicit here, which I personally really like. Now, we can still use these properties, the way we expect here. So we can we can get auto completion and everything like that. But let's show a couple more features before we call it here on what what else Zod brings to the table besides this, you know, base functionality, which is really, really cool. But there's some other cool helpers that it has. So if I do person dot height, and we log this out, we're gonna see here that we get this, it's this color, because it's a string, we get this 172, we get Luke Skywalker for the name here. So let's actually grab a couple other properties real quick off of this. So I can show some of the cool helpers that you can get here. So first off, you can add these little chains onto this. And there's a little min helper here. So I could say, Hey, I want the name to be minimum between one, why'd you do that? One and then the max would be 100 characters here. It's not going to show anything right away when I do this. But if I were to pare this down to two, you'll see we get this too big error, this is pretty cool. So we're actually constraining even more than TypeScript right here, we're saying, hey, this string came in, and I only want it to be two characters here. This is what I expect. You know, that's what I've prepared my app to work with, for whatever reason. And you get a nice little message here. That's pretty cool. So we'll return that back, let's just leave that one. And if you look at some of our other data, we have like a homeworld, right? So let's say we want the homeworld, we can do z dot string. And we can do dot and it's a URL, they actually have a URL helper that will check this, this is pretty cool. So when I let's just put a URL on the height as an example to show what would happen if it was the wrong thing back. And here we'll get this validation error, invalid URL for that. Okay. So let's pair that back right here, we'll leave that. So it has a bunch of cool little helpers like that. It's got an email helper, it's got a UUID helper, you see this min and max, and there's a bunch of other stuff, we're just going to cover a couple real quick. So let's do one more like more complex type here, we could do the films. And we know that we can do z dot array, right? And then what we could do is z dot string. And then we can still keep chaining onto that and say each of those is a URL here. So that's going to pass but what if we did email here? All right, let's change this real quick. So now when I do email, it's going to give me a bunch of invalid emails, I can actually pass an object into this particular validation, there's a bunch of things I could pass, but I'm only going to show you the message at heart, I'm talking there, I can do this message here. And I can say something like, films must be an array of valid URLs. Okay, do a little bit of massaging reformatting here. So here we get this cool little message films must be an array of valid URLs. If I change that back to URL, like I expected it to be, there we go. Everything's working great. So you can actually build on the messages yourself, which is really cool and like kind of check this data in a bunch of different ways. So we had taken a step back there, we had films, we said that's an z dot array is odd array of strings that are of the URL type with this message if it fails, let me show you one more", "metadata": {"title": "Catch Type Errors at Runtime with Zod: An Intro to this JavaScript Library", "url": "https://www.youtube.com/watch?v=evX18f-n4AI"}}, {"page_content": "if it fails, let me show you one more thing that gets really powerful here. This is really interesting. So if you want to go above and beyond just checking, you can actually transform the data to remember how I mentioned that 172 is just kind of this random number for height. Well, that's centimeters here. But I want the users to know that. So I can actually do transform on this height here. And I'm going to when I transform, I get a callback of the value. So let's just take Val, and then let's make a string interpolation of Val with centimeters tacked onto it like so. And then you'll see that's what we get back in our output here. 172 centimeters, which is pretty cool. And I can really do anything I want here. I could actually take this value. This is pretty nutty. And I could say number Val on this thing. So we could cast this to a number here. And what's going to be pretty nutty about this is notice that it changed its syntax highlighting down here. If I hover over this person type, notice the heights now a number is just automatically inferred that from the type that came back here. And now when we go to access this, I can say height dot to fixed, and that's actually going to auto complete and work correctly. There's another way to do this. Just so you know, you don't have to do transform if you're actually doing type coercion. They've added this in some recent version camera when but you can do z.coerce. Number, notice, I don't have to put the type I can just say, hey, whatever it is, if it's coercible to a number, go ahead and do that. And you can course to all the primitives. So you can see from that, that's as far as I'm going to go on this. But you can see that thought actually has a lot of powerful things you can do here. And what I like about this pattern is that you sort of have this source of truth pattern here where you, you kind of define above and beyond what the type is, you know what the constraints are of it, whether it's a URL, a min, a max, if you do this min and max on a number, it's going to change the error to say, oh, it has to be between this number range instead of this many characters. It's a really nice, friendly API to use. And when you come back and you look at the code, you can get a sense of what that data is being returned. And I really like that. So I've only got to use Zod so far in some of my little fun side projects, but I'm really looking forward to adding it to some enterprise apps that I work on that I want to see how it can pay out. I really do believe that this is going to be a really popular library coming up to pair with TypeScript so that you can catch bugs and errors early, right away, as soon as like the API changes or as soon as you try to use it in a specific way that you shouldn't be. As usual, I hope the way that I've covered this content has been helpful for you. You can go in the comments and let me know if not, or if you'd liked it. That's awesome. I'd love to hear that. But the way that I like to teach is kind of to take a more, a little bit more thorough step-by-step process of kind of digging into some of the initial properties. Like we obviously could have gotten a lot more depth here and I know it's an intro, but I'd rather actually go through and show you some of the patterns that I find very promising and that I've spent a little bit of time with and that hopefully capture kind of the spirit of why you should be intrigued about this and maybe why the TypeScript community in general has a growing interest in this project. If this was helpful for you, I'd appreciate it if you give a like and subscribe, and I hope that I will see you in the next one. Take care.", "metadata": {"title": "Catch Type Errors at Runtime with Zod: An Intro to this JavaScript Library", "url": "https://www.youtube.com/watch?v=evX18f-n4AI"}}, {"page_content": "Welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and I'm pretty hyped for today. I'm going to be showing Chromatic from the Storybook group, and I'm going to be setting that up from scratch from a like brand new Create React App project just so you can see what setting that up looks like, and I did make some mistakes along the way, just letting you know, and I left those in. I tried to chop them up for the sake of time so that you could still see them, but you know, you weren't there for the whole slog of me troubleshooting things because, you know, coding in reality is really clean, and I think people can learn from it, so I leave those things in just so that you know. Oh, and I will have timestamps, so be sure to use those if you want to skip the troubleshooting and just get to the interesting parts. Now, if you're not familiar with what Chromatic is, it is a visual regression test suite, which, if you're not familiar with that term either, it's essentially a way to have, if you have a user interface, let's say you have a component library or something like that, in Storybook probably, and you will, whenever you push those changes up, it will take screenshots of each of your components or each little unit in your UI library, and it will do a diff or comparison between those, and it will let you know when things change, maybe the layout shifted or the colors changed or anything like that. So it's pretty cool to kind of alert you in an automated way so you can skip some of the manual user testing where people, you know, make mistakes and miss things and bugs get into, you know, real production deploys. So that's what it does. It's a huge time saver, and it's a fantastic suite. I'm really impressed with the polish of the user interface and the setup, and I think the rest of it will speak for itself. So let's just get to it. All right, so I have started with a Create React app, a brand new app. You can use your framework of choice for this. It's just pretty common with a Storybook. And then what we're gonna do is we're just gonna spin up a Storybook 6 real quick, and if you go to install, they'll tell you that you can use this MPX SB init. So MPX SB init. What that's gonna do is it's going to detect your framework or project choice, and it's going to set it up for that specific one, which is really cool. They support a lot of the major frameworks at this point, so they've been doing a great job with that. All right, well, it's finished now, and you can see it'll allow you to run Yarn Storybook, and we might as well, just to see if it works there. And then from this point on, what we need to do is go over to Chromatic, since we have our Storybook that should pop up any moment here, and on their home page, there's a Get Started Now button. And that was funny. It jumped me over to my Storybook. So here's the Storybook, just so you can see real quick. And this is what it starts out with. It just has\u2014the thing you'll want to notice is that it has a button component, and that has a primary, secondary, large, etc. And there's a lot of cool stuff in Storybook 6, but I'm not going to go over in this video. This is specifically for Chromatic. But the also thing that you'll want to notice is there's a header component that's using those buttons, depending on if you're logged in and logged out. That will come into play in a moment. So let's jump back over to the Chromatic experience. I've only done this a couple times, so bear with me. Once on GitHub, once on Bitbucket. I have to say the Bitbucket experience was not nearly as good as GitHub, though it was fine once I got it set up. It's just there's too many reloads that are required to see updates, and GitHub's really good about those live updates, which you'll see in a moment. So we're going to say, okay, we want to set up a project from GitHub, right? So that means that what we need to do is hop over to GitHub, create this new project that we just did. So we'll do a new repo here, and we'll just call it Storybook Chromatic. And we don't need anything since it's for demo purposes. I'll create that repository. And then what you can do is you can actually just, depending on your terminal, copy paste these things. Actually, we have not edited this yet, have we? So we probably need all of them. So let's go back to the terminal. What is this crazy nonsense? I've never seen this before. All right, that's very interesting. So git add everything, git commit dash m, and then we'll say initial commit with Storybook. You'll see the commands right here. So set the branch domain, add the remote, and then push it up. Oh, yes, I need to configure my permissions. One sec. Okay, that should work. I have a different SSH key for this one. I forgot about that. All right, now it's pushed up. And then that will allow us to go back over to here and say, choose from GitHub. And from this point on, we should be able to pick one of these repos. Now, this is kind of interesting because it doesn't show my repo, probably because when I clicked it, I didn't have it, but you should be able to just refresh, go back into this. Maybe not. Let's see. Let's try and just search it in. Usually that pops up there. But let's make sure that I did it right. Odd. Okay. No big deal. So in this project, it auto set up with yarn for me. So I'm going to switch it over to yarn, which is cool of them to do that. And they're going to want you to add this to your project. So we'll do that real fast. And while that's going on, it's adding chromatic. We want to publish to Storybook. That's done. We'll paste into here. And they're giving us our project token here. I'm going to remove this project anyway, so I don't care about sharing it there if it is like a secret thing. Let's see if this goes through. Let's hope. You'll notice that it's building Storybook right here, which is cool. That's just to like test to make sure it runs. But then it's going to publish your Storybook. So this is actually a really cool thing about chromatic is that it also hosts your Storybook. And the important part is that it versions it so that each time you make changes, you can see whatever your live one is versus the changes that are in flight. And when people are reviewing it, you might want to show like a demo version to someone. And that's really awesome that they just give you that kind of like the Netlify experience. So no chromatic script found. Yes, I would love for you to add that to me. And that's just going to make, let me show you that, package.json, this chromatic script, which is going to add our token right there. Okay, so that's done. So we should be able to go back to the browser here. And notice that the step has been updated. And it's showing us that we have three components, eight stories, etc, etc. And this is the commit. So catch a UI change. So what this is going to tell us is that like we can change something about one of our Storybook stories. And we can then see the change as soon as we push it up with this chromatic script. So let's jump over to stories. Let's go to button maybe. And then I'm going to add to button. Woof, just a big long woof for no reason. And we will need to commit that I imagine you might be able to just push it up, but I'll commit it. And then let's take a look at what's changed here. So we have a log from building, I guess. What if we want to ignore that or push that up. And then our package JSON changed, our yarn lock change and our button change. So I'm fine with all those. That's fine. And we'll say update button to have bug. Why not? And then git push origin. Well, I guess we can just do it on main this time. We'll do another pull request after. OK, so now we'll run yarn chromatic and push that up. It's going to automatically use the token since that's in there. And then we should be able to just jump over to here and wait for this to be updated. Unless we have an error, of course. You can see that it detected the change, which is really awesome. I wonder why that was wiggling. Is that saying that that one specifically changed? Maybe just trying to show you that you can click it. Yeah, so we have eight changes, which is pretty cool. So we'll look at the button. And this is your first example of this visual regression here. Highlighted in green is the change. And there's some pretty cool features here where you can turn the diff on and off if you just want to see how it looks. And then you can also this is fun. You can turn the strobe on. And I'm guessing this is in case you have a hard time noticing just the green because it's like a small change or something like that. But, you know, it could also be because you have a fun feature and you want to party. But then you have the focus diff. I don't know if that's as useful, but I'm sure it has some use. And then we'll just say, yeah, we were cool with that change. This is interesting. They're typing as me just to show like, hey, you can have a conversation here. And, you know, once you've resolved the issue, you can mark it as resolved, which you'll see a little bit more once we get to the real thing. This is just a tutorial here. Yep. Sounds great. This this is kind of important here. So as far as I remember, this didn't used to be free for all the for the beginning plan. I think they were all paid plans. I'm not sure about that. But what's cool about it regardless is that you get your storybook publishes for free on their CDN. You also get 5000 free snapshots here. And that's kind of important is that you'd probably that would be fine, I think, for most people, especially just to try it out. So it's awesome to let them do that. And then there are enterprise plans. If you want to have a lot more and more cross browser support and all that. So now let's go to the components. They're letting you know that you can invite team members to this space in particular. We're good for now. Go away. And then publish. We don't need that either. Not just yet.", "metadata": {"title": "Visual Regression Testing with Storybook's Chromatic", "url": "https://www.youtube.com/watch?v=jz-vpFBilhs"}}, {"page_content": "Okay. So let's take a look at this before we add it into pipeline build stuff. So we can see that we've already accepted this change, right? And then here's me as the reviewer. So what I can do is I can either batch, accept all of the changes, or I can just review them individually. And this is really neat. So we have kind of the same UI as before. We're showing the before and after of the button. And this one is the secondary button. That's why it's not blue here. So it's going through each button that was affected by it. And we'll say that we just accept this one. And then just so you can see real quick, there's another feature here that's on this view that I really like. It's called one up. And the one up is really interesting. It's a strange term for it, but you kind of figure it out quickly and notice that it's laying it right here. And if you switch, you can switch between them and it might help to just do like turn the diff off and the switch between them. So this is like, you know, you can lay two UIs on top of each other to see like how much did it shift? Because it might be hard to notice the shift when you're doing side by side. So you could usually probably stick to this and be fine, but that's a really neat feature. And it also shows the code diff, which is cool with the highlight. Just a real fantastic UI. Honestly, it's so exciting. Okay, so let's keep going. So we'll say, yeah, we accept that. We accept that. And this is an interesting point. Now we're getting to the header and the header is showing that it has changed as well. Now this is in particular what makes this tool interesting to me. So I have a pretty large scale project going on with the design system, component library, all the stuff like all the cool kids are doing. And it can be really hard to notice when you've changed a small atomic component or like an alignment or something like that. And it kind of cascading to other components. So sometimes it's difficult to catch little subtle changes like that, or even big ones. It's just a lot of stuff to check. So this is kind of showing you that this component is used in other components, and it affected them. So you need to know that. That is awesome. So we'll accept this time we're going to accept all of them. It's just going through each one. Except cool. So now we've accepted all of them. And we have this, you know, build passing, you can go to each of your builds here, build one and build two. So you can actually go you know, back in time, you can look at the git commit, which is really neat. And then you can also go to the actual build itself and see all the individual components. So it's going to show us that every time, which is awesome. So let's go back to how to go back to the dashboard. Is it here? No, back in the project. Oh, you go to the build, of course, silly me. So now that we're in this build, that is cool and all. But what's makes it really interesting to me is the continuous integration setup. So if you click this right here, finish setup by configuring to publish storybook automatically. They will take you to your continuous integration. If you're not familiar with that, it's essentially just like tools within your whatever your repository of choices typically, it could be outside of that as well. But if you've ever heard of Travis or GitHub actions or Bitbucket pipelines, it's that type of stuff. And it's allowing you to run tests, every commit, essentially, or builds or anything like that, or every pull request you get to choose. So this is really awesome, because it helps you when when people push up code changes to just automate the manual steps that are just ripe with human error. So let's set that up. So you can see it's really neat. So here we want to go down to probably GitHub actions. And I'm not sure if I actually need this script here. So I'll change it. I feel like this script actually doesn't work. Let me actually get the code. I'll get the whole line. Because this chromatic project token, I don't know how this would pick up the environment variable because you'd have to actually declare it in the step. I was messing around with this before and I had a hard time in a Bitbucket. I had to actually set it up differently. But I'll add it just in case. So let's go back over to our code, because it might need it in the pipeline, however, they've set it up. So that the whole thing. So we're going to replace this script right here now. And what's what's different about this is now we can't just run chromatic like locally, unless we set up like an ENV and point it to that. But we won't worry about that for now. So then you're to come down to GitHub actions. And they have a workflow setup for you. But they also have a GitHub repo that has some of the action information. So you can scroll down here. And yeah, same type of stuff. I think one of them shows you something different. I had to go back and forth between them for a little bit to figure out their particular actions. But let's just copy this whole thing. And you can see they wanted to put it in git.github slash workflows directory under chromatic YML. So whenever you're doing GitHub actions, that's pretty typical. You'll say new, we can do a file. And we'll say dot GitHub slash workflow slash chromatic dot yml. So what that did is make these two folders and then this file. All right. So then we could leave this on push, we might want to swap to pull request only. But maybe let's try and just leave it on push for now since that's their default. Typically, I would do that just on pull request. Okay, so we'll just push up this change. So add GitHub, whoops, GitHub action for chromatic. Boom. Now you'll notice in particular that we need this project token here. Okay. And this is just your GitHub token that should come along for the ride already. But we do need to set this part up right here. So I'm gonna copy this string. So I'm gonna need it in a moment. And let's push up. That's interesting that it said this failed. Oh, it probably failed because yeah, exit zero on changes. If it fails the actual like there are changes to detected visual regressions, then you can consider it a fail in the script or not. It's up to you. So git push origin main for now. And then what we want to do is hop over to our GitHub. Where is that goodness. And in our project, you can go to settings. And this is just GitHub actions at this point, not specific to chromatic. But then you can add a new repository secret. This is where we paste the name of it. And then what we're going to want is our project token, I could just do a history check. But here we go. This is it. Okay. Hope that's it. Paste that right here. And then that's just going to be available now as like a secret token to GitHub whenever it's running actions. Okay. So I think we've got all that set up. Let's go back to chromatic and see if they have anything extra they want us to do. So here's the setup for that. You'll need to configure secrets and a new browsing window navigate to GitHub repository. Yeah, they're okay. That's cool. They're telling you how to set up your secret. Let's actually just make a PR and see if it works. Let's try that. So what I'm going to do is I'll go back to button. And then I will delete this change here. Okay. And then what I'll do is I'll check out a new branch. And we'll call, you know, remove button text bug or something like that. Whatever. Let's look at the diff. Okay, add that. And we'll call it remove button text bug. Now we'll push that up to this branch. And it's actually supposed to run on pushes. I'm curious if it will, but I've only ever seen it run on pull requests. So I kind of wonder what's up with that. Let's see if it's done anything here. I don't see anything. Okay, let's go back over to GitHub. Right here. And if we go to our code, you know, GitHub is awesome. And it'll be like, Hey, you have a branch that has, you know, push some stuff up. Do you want to make a pull request? We Yes, I do. And we'll create that pull request. And we'll see if our action fires crossed fingers. The first time that you do this, this is pretty common for it to just kind of show up as nothing, you might want to check out the actions tab and see if it's running. Doesn't seem like it is we might need to set up the app for it. Let me troubleshoot this real fast. Visual Test enabled collaborators, GitHub repository. It's possible that it already had the app added under applications here authorized. Oh, yeah. I wonder if I needed to remove this for the demo purpose, because I already had this from testing it out once. Now this is just authorized in general. First, I'll cross reference their GitHub one and see if that's different than mine. Let's actually do this and grab the code here. And let's look at our actions file. You know, nothing can ever go smooth, especially when you're live demoing, runs yarn, deploy to chromatic with that looks right. Well, let me just try and change this to pull request. And we'll do just do it on the same branch we're already on it should update automatically pull request. Go back to our pull request here. That's been updated. I don't see any action.", "metadata": {"title": "Visual Regression Testing with Storybook's Chromatic", "url": "https://www.youtube.com/watch?v=jz-vpFBilhs"}}, {"page_content": "It's firing. Ooh, I wonder, is it possible that my name is wrong? workflows.github slash workflows. Did I do workflow? Dang it. I should have copied it. Oh, that's funny. Okay, we want to rename that to workflows. And I switched it to pull request. So hopefully that still works fine. Goodness. All right. Hopefully, that's it. Yeah, delete and update. Go back to our pull request. I guess maybe I could just try and merge this. Let's try this again. So we now have an action, we should be able to go to main. Hold down. Test branch. Since we don't care about the name, particularly right now. Let's go back to button. And we'll text before it just to see. And that's actually going to run into it. But whatever. Add a bug. Yep, here's a new PR. Let's create that PR. Please work. No. Oh, there we go. I guess I just had to merge it. That one time I thought it would automatically update the pipeline without merging it into main. So that's kind of weird. So here's add a bug. You can see our action finally working chromatic deployment. And let's go back to that. And you'll see this is probably just because this is the first time this has ever run. Okay, now we're finally deploying. And you can see that it has. Let's see build storybook output dir. Okay, so it's not showing. Oh, yeah, here's project token. So it is actually grabbed it and it just shows the end of it. So that's cool. Let's go back into the PR here. And we can actually see what's really neat here is that it has this like tests that it's running that's pending. And what it's going to do is see pending a changes must be accepted as baseline. So there you go. So this is really neat. If you were to click this, it'll take you to the individual pipeline. But this right here, one, if you click this, it'll take you to a deployed storybook for this version. So if you want to send that out, like in the middle of it, this is the actual one with the changes that you've made that hasn't been merged into, you know, your main branch or anything yet, or your main storybook. That's so cool. Okay, now go back to here and then UI tests. So if we click this, you can actually make this like a blocking action. At least you can on Bitbucket. I'm pretty positive you can on actions for GitHub. But you can make this blocking to where like, you can't merge this until this has been accepted if you want to. So now, this is really neat, because you let's say you added like your designers or something like that, or project manager or whatever to this project in particular on Chromatic, you don't have to worry about them, you know, messing with repos, or even having access to a GitHub account or Bitbucket or whatever you're using your GitLab. And you could just have them just on this part of it just on the review step. And just add that to your continuous integration pipeline. So I think that's really cool. So now you can see here that we have this build, right? But if we go over to PRs, they'll say install Chromatic on GitHub. Okay. Which I should have already had, but let's see. Okay, that's this one, approve. And then now that we have this set up, it'll actually have another step. See that UI review. So we'll have another step here for just the pull request in particular. There we go. Okay. So now that this has been pushed up, review the UI change set in each pull request. Now these nice little GIFs here. It's really nice. I mean, this is just such a polished UI. I'll do that I'm good since I've seen it before. So here they have a link, if they want to just view it on GitHub, and they want to like see if the changes just in case it's other developers or whoever, could be anyone. And then you can assign reviewers just like regular PRs or assign yourself, it automatically has me as a participant here. And then here, they'll give you a quick little, like scene of Oh, here is the visual change. And so now if you look at components, they just have each of those. And then you can go to change sets. And you can just scroll through and see all the different changes here that have happened in this pull request. Isn't that cool? So now, you know, you go to activity. And let's say we want to look at each of these things. You can just say, Okay, I approve this PR. Now you might be thinking, Okay, well, what if I want to like individually deal with these issues? Well, they have a couple different avenues for that. So in the we're in the PR tab, you can leave a comment on something. So you can say, Yeah, I don't know about this looks funky. And then comment. And so now this discussion will have started. And you know, if I add someone else, of course, let's say they reply and go, it should be funky. Good, sir. Okay, cool. And you notice there was a reply and resolve there, or you might not have, but I wanted to show you if you go back to activity. This is the activity for the whole thing. Let's add one more, actually. So let's go to change that. Let's go down here. Yeah, look in spish. Comment, boom, go back up here to activity. And you'll see that we have these, it'll tell you for the story that there's like a conversation going on here, you can just view the change. Or you could just resolve it right here. So you can just say, Okay, or you could just resolve it right here. And so that's what's really neat is like, you know, you can just say, I'm closing this or whatever, you know, and let them know, like, yeah, this looks good, or wait for them, you know, to approve it. Maybe this is your designer saying, maybe you want to adjust this thing. And we'll say, Okay, well, can we just like push this up for now? We'll do another push. And they'll be like, Yeah, cool. So now you could say reply, resolve, beautiful. And then you could resolve each of these things individually. And that's cool, because then you can still see the conversation that's happened. I love this UI, it's fantastic. You know, it's really hard to cram all this information into a sensible UI. You know, I wouldn't say it's perfect, there's, it took me a little bit to learn. But you know, it's, I think it's pretty dang good, personally. So I expect to learn a little bit on every new tool. And I think they've done a fantastic job there. So now you can see that this has been unreviewed for the build, but also the PR. So now we'll say, Yep, we're good. I approve this PR. So that's step one, just the PR itself, go back to here. And you'll see there's a little checkmark here automatically, I didn't have to reload or anything like that, letting me know, okay, whoops, this one, UI review. So the storybook has been published, we have a UI review. And now we're just pending on the UI tests. So now I go there to the build. This is the only part that I think could probably use some improvement here. It's not super intuitive going from like the PRs to this build to knowing to go to build three, they've done a decent job, I figured it out, you know, and that says something, but it'd be kind of cool if you knew there was, I don't know, some sort of like more global set of things still required, maybe a little more prominence. Maybe that's just me. Okay, now we're in the usual business here, where we go through and we approve each of these things. So what I'm actually going to do here is say, you could do it from here, you can just do a check, if you want to, like, for whatever reason, you probably should look at it, but whatever. Isn't this cool? Like it's showing you like how many were accepted, how many weren't. And what's neat about this is you could be like, nah, I don't think so on this, this small one in particular, I don't like it looks fine on the rest. And then let's just say, you know, the rest of these are good. But notice, did you see that right there? It's all flashing. Isn't that cool? So now this has one change denied. And of course, if you're the developer, you could click on it and just go right to it and see, oh, well, why was this denied? That's weird. So I don't know if you can have a conversation on this level or only on the PR level. I mean, that would be cool. Let me see if there's anything like that. What's this? Undenied. Okay, that's neat. I guess maybe that would be nice if the individual things could have a comment. Maybe I'm just missing it. But either way, you can see it on the pull request, so I think that's fine. So then let's see, they could go and change their code in their GitHub. Oops, I got too many things open. Oh, that's right. We were here. So now they could go back and we could just make another change and be like, all right, well, things were messed up. You know, we don't like the way that that behaves. We'll just change that. We're on the same branch at this point, test branch. We'll edit, we'll say, fix the bug or whatever. And push that up. Oops, test branch. Origin, how did that happen? I can just do test branch, can't I? Because I said it already. Nope. Weird. Go back to here and then these should run again. I think it will auto reload here. Yeah, okay. I wasn't sure if I had to reload for the initial one. Okay. So now this deployment's in process. I'll fast forward here real quick for you.\n\nOkay. Now they finally popped up here. So yeah, this is pending, pending. So that's where we need to open this again. And this time we'll just approve it. And I'm curious if it actually, it does seem to keep the old log maybe? Interesting. Is this part of the same build because it hasn't been approved yet? I wonder if that's why. That's awesome that it has this like history here. Okay. So let's say, yeah, we, oh, the PR has already been approved. So it's really just this part that failed. That's all making sense. Okay. So this time we're going to batch except all, because I know they're good, but I'll just take a look just so you can see. Yeah. Fixed. Lovely. I mean, I just want to just go again because that part's fun. Cool. Okay. I've had my fill. So go back to this and these have all been accepted. And at this point, our PR can be accepted and we will merge it. Boom. Merged and closed. And then if we go to our PR's tab, we'll see that they are not open and there is a closed one now. What is this? Helps you collaborate UI engineering, PMs, publish UI components and track commit activity each pull request to make visual. Is this what I've already done? I think this is what I've already done. I just haven't seen the screen yet. Yeah. Cool. All right. Close that. All right. I think that sums this up pretty well. The last thing I just wanted to point out, just a real quick peek here is that you'll notice that they do have cross browsers that you can add. I believe these are only on the paid plans, but I haven't tried it out yet, but it was included in them. So I figured that was the case. And then also you can see that they also have these links to your storybook. So you obviously get that hosted, like we talked about before, your little chromatic library, but they have Slack notifications and Slack notifications and integrations and all that stuff too, or just generic webhooks. So they've got some pretty cool stuff going on. And for this team, like the storybook team in general, I don't know what group of engineers from storybook are working on this one or for it's, you know, other groups or whatever, but typically storybook advances really fast. They have lots of great new innovations all the time. And they usually do a pretty good job of also like making that update as painless as they possibly can, because they are innovating quite a bit. So you can see that a lot of cool things are coming. And I think that that's a pretty good overview overall of this entire system. And I'm really impressed so far. I really like it. I can't wait to try it out on my own project at work and on my personal projects as well. I'm going to be just testing it out and playing around. I'll let you know if I have any like interesting updates from it or anything like that. But there you go. Hopefully that was pretty cool and inspired you to check out Chromatic.", "metadata": {"title": "Visual Regression Testing with Storybook's Chromatic", "url": "https://www.youtube.com/watch?v=jz-vpFBilhs"}}, {"page_content": "Hey everyone, welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and today we're going to be setting up Next.js' preview mode using Contentful's preview API. Now I know this video might seem a little bit long to some of you for setting up a preview mode, and that's fine. There are already examples like the Next.js documentation and some other things to just quickly figure it out yourself if you wish for that, but I'm really trying to go step by step through this and walk you through what it is, how it works, and kind of explain some troubles I've had with other systems and stuff like that along the way. I personally think that's really valuable and it's stuff that I would want to know, so that's why I'm taking the time to make this video. But I want to be considerate of your time, so I'm also going to have timestamps if you want to jump around to specific things that you might need. And I'll also have the repo hosted, which I'll have a link to in the description for the code at the end of it if you just want to glance at how my config is and figure it out yourself. So before we get into the code, let me give you a brief little summary of why something like this even exists, this preview mode. One challenge that I and many others have faced when working with statically generated content is that preview can be a little bit more challenging. Many traditional CMSs, like WordPress and such, have their own preview mode built in. But when you're using a headless CMS or a headless pattern, like if you're using a headless WordPress, and then you're doing statically generated content, that actually becomes a little bit more difficult of a challenge to give them a responsive preview mode. So each build system, such as Gatsby, has invented their own way to alleviate these pains through some really awesome engineering things to kind of speed up the process and make it more fluid. But today I'm going to go over Next.js because I believe that they have one of the most elegant solutions, if not the most elegant solution, for this that I think is very simple and very effective. Hopefully by the end of this, you'll have a pretty good mental model of how that all works, all the problems and the solves in general, and how Next.js preview works so that you can customize your own project to your particular needs. Okay, picking up where we left off last time, if you haven't watched those videos, they're going to be in the description and in the playlist here. It's the whole Contentful plus Next.js playlist that I'm doing right now. But for a quick recap, or for those who don't want to go back and watch that and just want to see preview in action here, what we've got here is we have Contentful being hit, which I'll go to that Contentful space later when we need it. But for now, we are getting a very simple model with a few fields. We're hitting that client, and we are using getStaticPaths to generate out all the different routes for every single slug that we find for a product review, and then getStaticProps here to generate out each individual page by fetching that one by ID or slug or whatever you want to call it. So now let's get into the preview functionality. And to start there, we want to understand how this API structure works really briefly. So there's this folder that it starts with whenever you make a Next.js project. It's this API folder, and they start out with this hello. So let's see how that behaves. You can see in the syntax here, it might look a little bit Express-like to you, and that is what Next.js also refers to it as. They have an API. It's not a one-to-one, but it is very similar to Express with this rec and res, request and response objects. So you can do res.status, set a 200 status, return some JSON. Let's see that in action real quick. So coming back over to here, I'm going to start up my server. I'm now on a preview branch. That's the branch we'll be on in the repo if you want to follow along or just compare your code or whatever if you have issues. So when we do that, we'll go back to the browser, and we'll hit this route here, and you can see it loading fine. But let's go to slash API slash hello, and then we get this response here, right? So that's pretty simple. So in order to initiate preview mode, you can go to the docs here. I'll link this in the description, but you could just search Next.js preview in Google or wherever, and they have some really nice documentation that kind of walks you through setting it up. I'm going to distill a little bit of this. They have some really good examples here for each database, but I found them to be pretty involved. When you're kind of first starting, there's a lot of like abstraction and stuff like that, which is good pattern wise, but might be a little difficult to just get right into it. So that's what I'm going to kind of do is keep it simple. But walking down here, you'll see that they recommend making a sort of route that has this code right here. Okay, so that's what we're going to do. Essentially, we're going to come back to our code, we're going to make a new file, and anything you make in this API one is going to use this format. It's going to use this little express-like server. It's pretty cool. We're going to name it preview.js. And so whatever you export here needs to be the default export. It's a common thing to call the function a handler. You could call it whatever you like. And then here, you're going to get a rec and a res back. Call those whatever you like as well. And let's just start by console logging that out when we hit that route. Let's just do response. Okay, we'll go back to our browser. Hit here and instead of slash hello, we'll do slash preview. And it's going to hang because we didn't end the response at all. But that should be enough to at least go to our server and see this giant thing dumped out. Okay, I'm not gonna scroll all the way through that and put you through that misery. But API resolved without sending a response to API preview. So they give you a little hint there, you kind of need to resolve that somehow. And in particular here, conveniently, right at the bottom, there's this set preview data that's on the response thing and among some other things. You can see dot end, which we're going to use as well. So let's do that. All we need to do here is do res dot set preview data. And that takes an object and a lot of the times you'll just leave this empty. This is just to flag on preview mode with a cookie that I'll show you. But you could do something like my key, my Val, you know, pass a key value and I'll show you where you get that later. For now, we'll just do res dot end. Go over to the browser, re hit this preview. And you'll notice that why did it did actually hit it? Or did my refresh not work? I don't think it worked. We'll do slash preview, press enter. And there you go, we should get this white screen because we ended it. But notice that we have this cookie over here and it's there's a lot of zoom going on here. So it might be hard to see. But in particular, what's interesting is this next preview data is going to pop up here and it's this hash. So you know, for security reasons, they aren't putting anything on there. But this cookie is something that is going to be unique every time that the server runs, which is pretty cool. And so that will start over every single time. So it'll have to be reflagged. But what that does is it's going to make it to where when we go to, let's say, product product one, we'll still have this cookie on our machine here. And we will until we essentially restart the server in this case. Or if it were production, you know, we'd have to clear it ourselves or whatever when it expires. Let's go back to our code real quick and see something interesting. If we go into this slug where we're processing all of our products in particular, and we have some methods running, if we were to log out this context object, let's see what we get. So we'll do console dot log. And we'll just do, let's see, context. I don't know why I bothered to type that up. Okay, so we'll hit this again real quick to get that log triggered. And then we come back down here. And you'll see we get this context when we hit and notice that it says preview true preview data, my key, my val. So this is how you would get those properties that you want to send yourself. And you could do anything with those you want. There's lots of options there. We won't need it for the rest of this video. So I'm going to kill it in a", "metadata": {"title": "Next.js + Contentful Preview Mode setup walkthrough", "url": "https://www.youtube.com/watch?v=HNDpkYJEjw4"}}, {"page_content": "video. So I'm going to kill it in a moment. But just so you know, if you want to kind of like send some data along and react to that, that's a cool way to do that for preview mode only. So we really care that the preview mode is true. First of all, that's one thing that we want to react to. Now I want to show you something interesting that happens here. There's some pretty cool stuff that's happening that might not be obvious at first. If we do npm run build, sorry, that'll build real quick here. And then we'll do npm start. So we're using like an actual production build here. What we want to see is anytime we hit this, I'm going to refresh this page. And we come back into here, you'll notice that no nothing was logged here like that the server wasn't hit. There isn't that log of the context object that we just saw. So I'm just going to refresh it a couple times. Nothing happens. Go back to the terminal. Nothing happens. But what happens if we go to notice we didn't have our cookie anymore because we restarted the server. So if I go to API slash preview, I'm now going to get that cookie. Okay. And when I go back to product now, let's see if it does it again. When I reload, you'll see that this context was logged out this time. That's kind of interesting, huh? It might be particularly interesting, particularly can't speak, because this get static props is not it's supposed to be static. It's not supposed to run. You know, it's not get server side props. So it's like, okay, well, how's it doing that? Well, what's cool about next JS is they've realized a pretty simple solution to this whole preview problem is that when you are trying to make drafts in your content editor, you're not like the end client, you know, the user, the typical person that's going to be using your website, you're the person like editing it. And so you don't need to do a full rebuild of all the pages every single time and, and try to go through the problems. If you've ever experienced a static site generation and preview mode, you probably know what I'm talking about. But if not, just trust me, it can be a real pain if you're just trying to do the whole build over and over again. What they're opting to do is say, you know what, let's kind of switch back over to a server side sort of behavior. And let's do things on request whenever we see the preview flag sent, because this particular person one probably already has the site, you know, cache to some degree, because they're hitting it. But two, they don't really need the super duper efficiency of statically generated stuff. You know, server side is going to be good enough for them. For this purposes, this actually ends up being a really elegant solution. I like it a lot. It's cool that they've made this single function, you don't have to do something special with it, it just kind of opts in or opts out of rerunning every single time. And that's going to be crucial for us to be able to, you know, get things on demand as we're doing a preview mode. Okay, so hopefully that rant made a little bit of sense to you. But if not, I apologize. Hopefully it was useful. So we'll come back to preview here. And the next thing we're going to do, we do not need these values, we just need the empty object here. And we want to start getting some params off of this query request. So if we didn't need rec, we could just do an underscore there, but we are going to use it. It's just a common thing, just so you know, if you're not using like the first argument of a function. We're going to do, we're going to pull product ID, that's what I'm going to name it when I pass it in, off of rec.query. Okay. So now, let's see what that is by console logging, product ID, product ID. So now if I just go here and I hit, I'm going to hit that same endpoint, API slash preview again. You know, I didn't pass anything in, so we should see an undefined for that. Hmm. What happened there? API preview ended fresh. Oh, silly me. What am I doing? I need to rebuild. I'm in production mode. It's not updating to my changes. I'm very sorry about that. System run dev, restart that over. I just had it in production because I wanted to show you the actual, you know, preview in production setup. So let's re-hit this route here. Go back to here. And there we go. So we've got this product ID, product one, and that's working great. So you can see now we can pull some params off and start doing some stuff with that. So the next thing we'll do is we'll head over to the Contentful space and we'll get the preview access token and start to set up like preview and all that. So for now, we'll only need the access token. So over here in my Contentful space, what you can do is you can go to settings if you're following along or doing your own thing. You can go to, we will do content preview in a moment, but for now we need API keys. So there's this next JS key thing here. And don't worry about any secrets. I am going to regenerate them. So normally I don't show people this stuff, but we already have the space and the content delivery. Now we're going to want this content preview access token. So I'm going to copy that. We'll go back over to our code and in our.env.local here, we're going to make a Contentful preview access token. You can name it whatever you really want here. I'll paste that token here. Why we specifically need this token as this is how we're going to get Contentful and many, you know, other CMSs that I've worked with have this idea of a preview mode where they have a different API that you hit for like draft content. And that's what we're meaning to get here. So in order to do that, if we go back over to our slug page, you'll notice that we have this like Contentful.createClient or whatever. And we're doing this access token and this process.env is using, or it's pulling off Contentful access token right now. We're going to pull off the preview token to do that. By that I mean, you know, getting preview data, getting draft data. So what will happen first though, it's going to make sense at this point. We were going to do it earlier in one of the previous videos, but it was a little bit too early now. It kind of makes sense to move this to somewhere else. So I'm going to abstract this code to a sort of like utils folder or something like that. And that's because we're going to need two different clients. I'll make a utils. I've got too many things going on in my brain, sorry. And then in this utils folder, we'll just do a Contentful.js file. Okay. So for now, just to get things working, we will cut, actually we'll do both of those. We will also want the import. We'll move that over to here. And oh, I did folder. Whoops. Lots of mistakes. So we'll do Contentful.js, a file, not a folder. And now we have this client, which we want to export. I don't know why it's a var. Let's see. So we'll do export const client. Okay. Back here, we're going to import that now. And then say client and Contentful. And actually, rather than do it that way, I'm going to do star as Contentful. So I have the whole thing. And then down here, we would change this wherever we use client, we would change this to Contentful.client. You'll see why I'm doing that in a moment. Okay. So it's just these two spots, get static paths, Contentful.client, and get static props, Contentful.client. Okay. So back over to here. Why we've done this is because we really don't want to be creating these clients over and over and over again. Okay. I probably should have left that. But when we go to, when we want to use preview, sometimes we're going to want to use regular data and sometimes we're going to want to use preview data. But the problem with this is when we instantiate this client, we have to give it the right access token and the host URL and all that stuff to use the correct API, right? But if we want to switch back and forth between the two, what, you know, if you're a little more naive, we might do is, you know, do some sort of like conditional here where we're like, hey, is it preview mode? Because we saw we could get that off of context. Hey, if you are preview mode, you know, use this client, otherwise make this other client. But the problem is, any time every little page runs, it's going to be recreating these clients instead of using more of a singleton pattern where you just make them one time and then import them. So now we're going to export const", "metadata": {"title": "Next.js + Contentful Preview Mode setup walkthrough", "url": "https://www.youtube.com/watch?v=HNDpkYJEjw4"}}, {"page_content": "import them. So now we're going to export const preview here. Let's actually call it preview client. And then I'll do Contentful dot create client, same thing, but I'm going to pass some different stuff here now. So pretty much the same thing for these two. I could have just copied this whole thing, couldn't I? And for Contentful access token, we'll say preview access token. All right. And the last thing we have to do is you have to specify a host, which is optional. They'll default to cdn.contentful.com. That's what's being done up here. But in this one, we're going to do preview.contentful.com. So now that we're exporting these two different clients, they're just like pre-made the first time that this file is imported, and then we reuse that over and over again. We imported it as Contentful, so I could access either one there. We can keep this await Contentful dot client because in get static pass, we're always going to get, you know, we can just hit the main API for that. I guess you might want to switch this to be able to do preview or non depending on if you had like brand new URLs that didn't exist yet or brand new slugs. But for now, we'll keep this. We'll just generate all of them based on the production URLs. And we'll do the switch here. So in get static props, we have this await Contentful client. Actually, I didn't want to do that because what I'm going to do is we'll keep this like client pattern, and then we'll say const client equals, and this is where we can say, hey, context dot preview. Remember, that was a true false Boolean. So we'll say if that's true, use Contentful dot preview client. Otherwise, use Contentful dot client. I'm going to format this. I don't know why it's not formatting for me. There are, you know, a multitude of ways that you could handle this. But I think this makes some sense. So now when we hit this route, it's essentially going to, you know, on production, it's going to first build them with this Contentful dot client, the regular mode, the production mode, whatever you want to call it, as it generates out all the pages. But then when someone comes here with that special preview cookie, we're going to switch to the preview client. And then everything else will be business as usual. Pretty nice, huh? So let's see that in action. What we'll do is we'll go back to our Contentful, go to content, and let's go to product one here. Now product one has the very first product. If I were to type draft stuff here in the heading, you'll notice it's saving, if you saw that. I'm not going to publish, though. I'm going to leave it just changed for now. And if I go back to my server, let's go to just product, product one again, and we should see draft stuff, right? Okay, so that's because we have these cookies. So let's clear those cookies real quick. And let's refresh. See, it went away. So that's how it's going to work. So it's just we, we, anytime we hit this, or the first time that we build all of our regular users, if we're in production, they're going to see this code. No one's ever going to see the draft stuff, unless they know how to activate this special little preview token cookie thing. So let's flip that back on again, just to see that. Go back to preview. And we really don't have to pass a slug. We could just hit whatever, because we'll get the tokens. We haven't set up that measure yet. And then if we go back to the page, beautiful. So we'll do redirecting and all that stuff next. So now let's set it up so that when we hit our preview, whatever slug parameter we pass there, it's going to redirect to this page. So it's essentially what we're acting as is sort of a link that you could give someone that will give them a special parameter that's like, hey, activate preview mode and add a cookie to their browser, and then redirect them to the page that they were kind of trying to go already. And that's going to be especially useful and contentful when we add preview links to each page. So when we come back here, we'll go back to this preview. And instead of res.end, I'm going to use res.redirect. Some of you might be scared right now. Let me actually show you why. If you go over to the documentation here, let's see, they did that. That's cool. Preview mode enabled. There should be a point here. They have this like kind of full example we're going to come close to as we step through it. But right here, you'll notice there's this res.redirect. Notice that they particularly say we don't redirect to rec.query slug as that might lead to open redirect vulnerabilities. So a lot of times you want to be really cautious with how you use res.redirect. And let me just give you a real quick example of why. So let's say that I redirect and I'm like, hey, you know what, just redirect them to product ID. So let's say, hey, if they type in their query params or whatever, we're going to send them all along onto the product ID. So if they type product one, then we'll send them to product one or whatever. Pretend that that's how our URL structure worked. Okay, it's just like everything's slash at the root. Now what could happen here is now that that's working, I'll go back to API preview. We'll do product ID equals. So if I go to product one, that's going to take me to, you know, API product one. And if I did slash, it would take me to slash product one or whatever. Okay. But let's, let's go back here and do API slash. And then maybe let's do something like preview and then product ID equals HTTPS colon slash slash Google.com. All right. Let's type two letters there. And if I hit enter here, it's actually going to full on redirect me to Google.com because we just said redirect to whatever they type in there. And that's really bad. That's a really dangerous vulnerability to have because what would happen there is if someone else could, you know, give someone a link to your site, let's say that you were a bank or a PayPal or something like that, you're using some sort of service. You could fully redirect them with a query parameter to your site that looked just like the other site. You could imitate it and you could like get them to type in their credit card data. And that's pretty scary. Among a bunch of other attacks that could happen. Right? So that's why the caution there. Okay. So, you know, you just got to be careful with, with, with how you do redirect here. So what people will do commonly is some of the examples show like right head here. And so you would do like right head with a 307. So it's temporary and not permanent. So we tell the, you know, SEO crawlers not to change their links and all that stuff. But what we're trying to do here is you could just say like set location. Let me actually type it out just so you know. And then we would be like, okay, let's set it to slash product. So go away. And then like product ID. So you could do something like this, which is a, you know, a pretty common solve here. In this case, I guess we wouldn't really even need it. But let's say that you wanted to send them here. You could just use right head as one alternative. I've seen some people recommend to do that, but we're going to stick with the res dot redirect because I am not too worried about that just because I'm not going to be ever just sending them directly here. You'll notice in the next JS docs that we referred to, they did like post dot slug. So they have like a qualified link. We'll kind of get into why that can matter in a moment. But what I can do here is I can do the same thing. It's a product slash product ID that I did before. And so the thing about this is, if you ever try to like do the whole thing that we did before, I know I'm taking a little bit of time here. It's just a pretty valuable thing to kind of have in your head. You know, feel free to skip forward in the timeline. If you're not interested in this, I should have said it beforehand, but it's pretty useful thing to know. So if you go to preview, we're about done here. And then we were to do product ID. And I did the same thing where I did that like product ID equals HTTPS colon slash slash google.com. And I hit that. Notice it's going to take me to slash product. So it won't actually work if someone tries to spoof a URL here, because I've hard set it to go to that product here. So because we have that URL structure first, I'm not as worried about that. But you know, just so you know, be cautious, do your own research and all", "metadata": {"title": "Next.js + Contentful Preview Mode setup walkthrough", "url": "https://www.youtube.com/watch?v=HNDpkYJEjw4"}}, {"page_content": "be cautious, do your own research and all that. All right, cool. So now let's actually do it for real. API preview, and we'll do the product ID is equal to product one, we hit that, and it will redirect us here. Pretty cool, huh? So if we were to clear that, we were to go there, we have a regular production mode. And then we go back to this route right here. And we hit it again. See, it's like seamless, it just kind of redirects us right here. And it sets our cookie and we get the draft mode stuff. I think you get it. So let's move on to setting this up in Contemple. So in Contemple here, we can come over and what we want to do is go to settings. And you do content preview. And mine's a little bit zoomed in here, just so you can see better. But you should see this kind of like blank set up a content preview page if you haven't ever done it before. You click it. And then here, you set a name, I happen to have next JS preview as a name. Cool, that works. I don't think you need a description. And then here, the content preview URLs, you get to pick for every like content model what you want the link to be, like if you want to turn them on and how you want them to go there. And this is pretty neat if you want to do like some crazy component stuff where you're previewing like just a certain type of component, and not like a whole page. But for now, we're just previewing the whole page. So if we go to product review now, notice they give you this cool example, right here, your website.com such product product review, entry field slug. Okay, so the part that we really care about here is this entry field slug thing going on. And looks, I've already got it from when I was messing around with it. Okay, I guess I'll just use that for now. So we want to type HTTP. For our case, we're using localhost 3000. A note on that in a moment, then we'll do slash API, like we did before preview, and then set a slug here, we want to do we want to do product ID equals. And then this entry, this is a contemptful specific thing, entry field product ID, let me show you what would happen if you were to put like slug or whatever they started out with, it should give you a warning that tells you that ID doesn't exist on this content type, which is really cool of them. So we'll say, yeah, we want to use product ID. And we want to save that. Perfect. Now, the note about localhost 3000, is that I'm using this for preview mode, you know, just to kind of like demo it and showcase it, because it's going to be faster to show it this way. But commonly, how I would do this is I would actually set this to the production URL, or possibly a separate server that specifically serves for preview purposes, if you want to do that, you know, maybe you've got a really big enterprise setup going on, but a production URL actually will work just fine. Wherever our site is hosted, we could point to that with HTTPS, please. With that, we can go to the production site. And the cool thing about that is that it's going to be reflective, I love this about Next.js and how they implemented preview, it's going to be reflective of the real data, the actual production data. So someone who's a content editor, and you're in here, whether it's you or other people, maybe on your team, or whatever, you know, I don't know your purposes for what you're using this for. But anyone who's using this as a content editor can see their preview data with the actual like production hosted site. So they have pretty good assurances that it's going to work or what it's going to look like. I just think that's a really cool, elegant solution. I've played around with I've had a lot of fighting with, for example, Gatsby Cloud, though it has improved quite a bit originally, you know, trying to redo these builds every single time that it previews and the delays, and they've made a lot of cool engineering improvements to make that better and better and better. But really, I just love this elegant solution with Next.js preview of like, let's just use a cookie that gets flagged that, you know, only they're going to set somehow, and that will show them the preview data and the regular users won't ever see it. You would want to add a little secret for a little bit of extra security. And we'll do that in just a moment. But let's make sure that this works. So now if we go back to content, and we go to product one, we'll see that there's this open preview button that used to be grayed out and is now here, because we just enabled it for this content type, the product review type. If I click that, it'll actually open a new tab and take me right there, which is pretty freaking sweet. So let me show that again by clearing my cookies. So we don't have preview mode on right now, right? And then we go here, and we click this, and it opens it, and it instantly went to that URL, we got redirected here to, you know, the actual product, product one, and we have draft mode on, which is pretty sweet. So now if we go back and we're a content editor, we could, I don't know, change some more stuff, draft subhead here. We do have to wait for it to save. And this is the one gotcha that I haven't figured out quite yet. I haven't spent a lot of time looking into it. You do have to reload every time that that saves. It's not a huge deal, but it'd be cool if there was like a webhook or something that would auto reload. Again, there might be a way to do that. I haven't spent a lot of time looking into it because I just haven't really needed to. But you do have to refresh. But you know, it's pretty fast. Like, let's just kind of show that in regular time. So let's, you know, delete that. Do that thing. There's a little debounce time waiter. It saves. As soon as it's saved, we refresh. And boom, it's there. Cool. So that's pretty sweet. So we'll do that. We'll get rid of, we'll get rid of this for now. I'll just leave that. And let me also show you what's cool about this is this works for every page. The way that we've set it up is really neat, because now if I go to ABC one, two threes page, and I click open preview, I can do the same thing here. It's opened this page and it's redirected to that. And now I have my preview mode set, which I already did. But if I were to add some gibberish here, and I were to wait for that to save, I'll go back over here and I'll reload. And there it is. So this is really neat. It just makes it really easy. Let's publish that and go back. I don't know why I did that. I didn't need to, but it makes it really nice and convenient for the editor to just kind of like pop over to that page. Okay. So I mentioned a secret key that you could do, and let's show that this is also recommended in the docs. But if we were to go to content preview here, let's reopen this. And here, let's add another parameter. So we have this product ID equals this, but let's make it to where they have to pass a secret as well. So we'll say secret equals, and we'll do super secret. You would want to probably create some sort of hash or something like that. Put that in here. And then we'll use the and to set another parameter, another query param. And now that we've saved that, what's going to happen is we are going to go back over to our API here, and we're going to put a little condition. So rather than making you wait for me to type it out, I'll just copy paste this over just so you can see it. So before we set preview data around here, what we want to do is we're going to make a little if statement that's like, let's check for secrets. So we're going to have to pull that off of query params, right? Secret, secret. We're going to do a secret and we're going to say, hey, if that's not equal to some sort of secret environment variable here, which we'll go make. Let's do that. And we'll say super secret, right? That's what we set it to. Go back to preview. And so we'll say, hey, if their secret that they passed in the query params, you know, if they don't have one or it doesn't equal it because this is an object, so it will be undefined otherwise, if it's not equal to this from our environment, or they didn't pass a slug at all. So if either of the params aren't there, let's give them a status 401, which is unauthorized, and then give them the message invalid", "metadata": {"title": "Next.js + Contentful Preview Mode setup walkthrough", "url": "https://www.youtube.com/watch?v=HNDpkYJEjw4"}}, {"page_content": "unauthorized, and then give them the message invalid token. Let's see that in action. Oops, I better save. So let's go back here and we'll go to API slash preview. Let's just pass nothing. See that? We get an invalid token here. And let's go back to the network tab and we'll see this 401. If we hover over that, does it tell us? Yeah, unauthorized. Cool. So now if we did, oh, let's do product ID again. Nope, sorry. We have some new credentials that you need. And so what you do need is you need secret. And let's try one more. Let's do wolf instead. Nope, that's invalid because it's checked it. What about super secret? I did secrete again. What's wrong with me? Cool. Slug is not defined. Oh gosh, I'm sorry. In my last one, I was using slug, but I feel like that didn't make much sense. So I changed it to product ID. These are good little errors to see along the way though. So I'm going to leave them in just because one, you know that I can bleed, but also it's really just, you know, it's the everyday life of a developer. Why try to hide it? Right. And you get to kind of see like what happens if you don't have a slug. So let's do it again. Super secret. Hit this. Boom. Perfect. So we've got that all working. Lovely. So what we'll do just to finalize that, just to be sure, is we'll go to application. We'll clear this cookie just to make sure that we're in regular mode. And here, now that we've set this up with our super secret and all that stuff, let's go back to a content type and we'll go to our content type. And if we did this right, we shouldn't get an unauthorized when we click this. Invalid token. Ah, well, I like, I'm glad that we were really getting to see all of the layers here because I made some new mistakes. We did. I don't know why I was so obsessed with typing secret, but that's cool. So you can see it wouldn't work if we didn't do it right. We'll click this again and you know, there you go. It's like TDD, you know, let's take the unhappy path and then the happy path. Make sure that it actually breaks first. Good to have that assurance. Okay. Now as a regular user, how am I going to get out of this dang preview mode? Like we, you know, as developers might know to go to this application tab and we're going to go to this preview mode. And we're going to go to this preview mode and we're going to go to this preview mode. Like we, you know, as developers might know to go to this application tab or whatever, get rid of our cookies. But one, we don't want to have to do that all the time. And to our users, you know, we shouldn't expect them to know that. So what we're going to do is we're going to create a separate route to clear the preview data, the cookie, and then we'll make a little banner that lets you know that you're in preview mode, which will be kind of cool. And it'll also have a button to go to that route. So let's do that real fast. Go back to here. And in our API folder, let's make a new one. And let's call this like cancel preview. Maybe I guess we should probably do hyphens. And I'll just paste this here. So this is just a function handler. We aren't using rec, we are using res, we're going to call clear preview data. And then we're going to redirect them to the homepage because why not, we could like figure out what page they are and all that stuff. But let's make it simple for now. So let's quickly test that that works. We did cancel preview. And so right now we go to this, we should see our draft stuff. But if we were to go to the route API slash cancel preview, it should redirect them to the homepage, it cleared the cookie. And then if we go back, we can see that we're out of preview mode. Perfect. All right. So now I'm going to add a component here. So I'm going to since we don't really have a components, I like to make a components folder at the root, pretty common convention, do everything in the root next JS. So I'll do components here. And then let's make this like preview mode dot JSX or j, are we just doing JS, we're doing JS in this one. Doesn't really matter. And to save you time, I'm going to paste one that I've made. And I know you'd love to watch me type out all these styles. So you know, it's going to be a style thing, you'll see how it's styled. But really, it's this preview banner. Let's actually call it preview banner. I like that name better. Rename banner. So we have this preview banner, we're importing link from next link, so that we're using it properly. We have a span here that just going to tell them that it's preview mode. And in particular, this is the part we care about, we're using a link you this is important, you have to set this pre fetch false, because this is a link to an API route. It's in the documentation. If you look in the like next preview docs or anything like that, they have a little hint here. But just so you know, you want to set preview or pre fetch to false that when it's loading, and it's like pre fetching all of the single page app links that it doesn't do this one in particular, because it's not it's not an actual page, it's a route. And then I had to sable preview, but let's I called it cancel preview in this one. So let's do that. So we're we're redirecting them to this cancel preview, which will then clear their cookies and redirect them to home. And that's pretty much it. It's very simple. As far as this component is concerned, there's not a whole lot going on here. And it'll be in the repo if you want to reference it. Now next, what we want to do is we want to go to our slug page here, we're only going to show this on the on the product slug here, we essentially want to have like a prop stop preview, or something like that. So what we would do is we would go down to get static props. And you'll notice that we had this like context dot preview to determine this, which of course, you could destructure if you want to. But we'll say, hey, props, let's add a new prop called preview here to pass along and get static props. And we'll say, well, that's going to be equal to context dot preview. And so you might think that you could just do this. Unfortunately, I think this comes through as undefined. Let's just double check that. Come back here. So if we're not in preview mode, when we load this, yeah, we'll get an error because it's like error serializing dot preview return from get static props. So what that's saying, you always have to, you can't just have undefined, you can do null. But whenever you have something that's going to be undefined, you have to have another state of like, if it's undefined, we'll set it to false. Okay. I wish that they like it's a Boolean that comes in as true. So I wish they would automatically flag it as false, but whatever. So we'll say or false. So for in preview mode, set it to true, otherwise set it to false. Okay, then up here in our props, we're going to have access to that now. So let's do something like this. Let's say when you return this, you know, this is the error version. So we won't do it there. But here, we could do something like props dot preview, if that's true, and and load preview banner. I think that should be it. So we'll save that. Notice that auto imported that don't miss that. No, if it didn't do that for you, you need to import it, then we'll come over to here. Let's see if I did that. Right. So if you reload this, we shouldn't see it because we are not in preview mode. But if we were to let's actually just use our handy contentful link, we'll click that boom, boom, boom, this is what it would be for a regular content editor. Now they have preview mode enabled and it's got draft stuff. Pretty sick, huh? And then we could just click this exit preview mode, and it will clear that for them. And then of course, they would have to go back to the page, which is, you know, a minor inconvenience. But if you want to figure out how you want to redirect them properly, go ahead and do that. Okay, so we're really just about done now. I think that the last thing we want to do is add one more little security measure. I mentioned that in the docs, we were going to kind of get to some some extra little security stuff that they're", "metadata": {"title": "Next.js + Contentful Preview Mode setup walkthrough", "url": "https://www.youtube.com/watch?v=HNDpkYJEjw4"}}, {"page_content": "get to some some extra little security stuff that they're kind of doing here. It's a minor thing, but it is minor for us to implement and you know, a good amount of extra security can't too much. So we have this thing right here, we're just like, hey, you know, if they don't have the correct secret key or the product ID, you know, go ahead and bounce them, otherwise set preview data. But really, what I would like to do is actually go and hit contemptful and make sure that this record exists. If someone's trying to get to the preview data of this thing, for whatever reason, let's go see if it's actually there. And let's redirect them to that product ID rather than use their query param. This will make it even safer with the rest are redirect. So as an example, we could go over to this like slug thing here. And what we essentially want to do is something like this, we would just take this like const product here we could this is from get static props in our slug, we could just take that. And we could say, hey, if they pass that first check, let's go ahead and fetch this thing. Now, we need to set our function to async. So let's do that. So that we can do that very easy. And now we can await this product. And so what we'll need to do, though, is we'll need to get client, right. So we'll import star as contemptful just to keep the same convention from and this is from our utils folder. Oh, it's just up one folder dot slash product dot slash I got lost utils slash contemptful. Sorry. Now we've imported it as contemptful. And now this will do contemptful. Client, we don't really need to do preview mode for this unless of course you wanted to, you know, also get URLs that haven't been published at all yet. That's a whole separate thing that I'm not going to do in this video. But what we can do now is we can check if this thing is here. Now, what's interesting about this is we want to do if you know, like there's no product, right. But what the contemptful reply comes back as for this get entries is going to be an array. And what we're really looking for is that array will have some metadata on it. And we've seen that in the previous videos. But in particular, the shape is going to be product items. And in this case, I'm going to use dot length because the items array will be empty if there are no records that match that. So we're doing a limited one, we're getting a product review type, we'll say, hey, it's equal to context dot params dot product. Oh, actually, we pulled that off though, right? Can we just do product ID here, because we copied it over from the other one, right? And so now we'll say, okay, the fields dot product ID is equal to the product ID that they passed in, go ahead and try to fetch that. If that comes back as an empty array, just bounce them again. And we can give them a different message this time, like instead of invalid token, we'll do something like invalid product ID, whatever, you know, message you want to put there. Okay, so finally, what we'll do is now just to kind of make this a little shorter and more readable code as well. Or not not to have so much down here, let's go and get that field. So we got, we can assume that if they got past this, we have a product, right? And we'll say, page fields is equal to and what we'll do is product dot items. And then we'll do at position zero dot fields. And so we'll say that's our page fields or whatever, you could do this multitude of ways. And then we'll say page fields dot product ID down here. So what we've just done is instead of using the product ID that they passed in, and just kind of trusting it as, you know, the actual link that we want to send them to, we'll say, you know what, okay, you pass the secret, you've passed in a product ID, your secrets good. Okay, well, let me hit Contentful, let me make sure that that entry exists. If that entry does not exist, I'm going to bounce you again, you're unauthorized. But if it does exist, I will go and I'll get the field of product ID from that actual record, not the one you pass me in. And I will redirect you to that. So now let's test that out. And we'll be good. So if we come over to here, in our browser, we'll go back. And we'll say, Hey, you know, let's hit API slash preview. And this whole thing again, do I already have my stuff all saved? Cool. Whoops. Yeah, I do want this one. So we've got this long token here secret, this might be hard for you to read. I'm sorry, I can't like zoom in the URL preview equals secret. Secret equals super secret and product. So let's do product like 37. Right? If we do that, we should get bounced for invalid product ID. But if we change that back to product one, it should be good. And preview mode is now enabled. Pretty cool, huh? So let's make sure that still works with this link. Of course, we'd open preview. And you know, our users are still good. Well, I think that that will wrap this one up here. As usual, I hope that that was useful for you. I really hope that stepping through this, you know, piece by piece and walking through and explaining everything was useful for you, as opposed to just, you know, a lot of times just going through the docs and just kind of like speed running it, you know, might give you the answer quicker, but not really tell you the whys and the particulars and might leave certain things out. So, you know, please let me know if you appreciated that or not. And I will do my best to improve upon that. But regardless, I hope to see you in the next video, and good luck to you.", "metadata": {"title": "Next.js + Contentful Preview Mode setup walkthrough", "url": "https://www.youtube.com/watch?v=HNDpkYJEjw4"}}, {"page_content": "Yes If that simple answer is not sufficient for you if you still have a burning desire within you to understand the why that you need to commit these lock files then let us go on a little quest so the NPM package lock JSON docs if you go to them It'll actually tell you here you could skip this first paragraph And it says this file is intended to be committed into source repositories and serves various purposes So you know skimming over this obviously you can go and and read the docs if you like But what it's going to get to is that you want this Representation of a dependency tree. That's exactly the same across different environments and Let me go over to the yarn lock docs real quick, which I also have open. Let's say roughly the same thing It's a little bit more Missable I should say that you need to go down to the bottom where it says check into source control and the yarn dot lock File docs and it says all yarn dot lock files should be checked into source control This allows yarn to install the same exact dependency tree across all machines Whether it be your co-workers laptop or a CI server So at the top it also does a brief little introduction Saying that you know in order to get consistent installs across machines Yarn needs more information than the dependencies you configured in your package JSON Yarn needs to store exactly which versions of each dependency were installed So I like the explanation that the yarn docs give though They you know, they both give their own insights, which is pretty cool And the main point I think to bring out of this is that a package JSON many people almost treat yarn lock files as if they're You know Redundant or an extra bit that the package JSON is already doing and that's not the case While the package JSON is a set of instructions for dependencies to install It's more like a rough target. Whereas the lock file is an exact so I think to demonstrate that we should jump over to the terminal and kind of make a little demonstration project so we'll start with making a directory here and What I'll do is I'll say make dir versioning and lock files, which you can see I've already made before Just a little bit of you know pre-gaming there and what I'll do is I'll CD into versioning and lock files I'll touch and make an index.js though. I don't believe we'll use it I want to knit this project dash Y to just say yes to everything and Then what I'm gonna do is I'm gonna npm install you can type out install or just I and we'll do chalk why not since that's there and And then I am also going to do yarn which you should not do You should not usually use two package managers in one project, but I'm just doing it for demonstration purposes So hit yarn and you'll see that it even gives you this nice warning package lock JSON found Your project contains lock files generated by tools other than yarn It is advised not to mix package managers in order to avoid resolution inconsistencies, etc, etc, so Yes, don't do that Now that we've done that I believe the last thing I need to do is I'll do a git ignore And the reason for that well, let's just open up code Trusty editor here and the reason is I want to you know, ignore node modules if I can type and Here we are So in our package JSON, we can see that we have this one dependency, which is chalk at 4 1 0 Okay, so when we run just you know The install the package without any numbers or anything like that What it's going to do is it's going to grab the latest and it's automatically going to prepend this little character up arrow here And what that means is that it will not ever move above Whatever version it installs the major Version so really quickly to go over this so this is called semantic versioning this convention and it's major minor and patch now a patch means probably a bug fix or just some, you know minor little fix of some sort a minor is a new feature typically Something that does not break your code though It's just a new feature that you can opt into and a major means that is a breaking change in most situations and that it pretty much means that if you are already using the project and you want to Upgrade to the version and you might need to change some of your code based on the change that they made so let's say they made a Major feature change to a certain color within chalk, which is a logging package Well in that case, then you might need to change the way that you call that function That's why it's a breaking change if you were to upgrade to it'll actually break your code if you don't make the change Hopefully that was a succinct enough explanation. We might get into semantic versioning in another video, but that's the gist of it Okay. Now if you were to leave this arrow off, it's going to say I want exactly this version Don't ever give me any other version. So now that we know how all that works. Let's jump over to the lock files So the lock files here what we want to look at will start with package lock JSON You can see there's all these other dependencies even though in our package JSON We just have this one and that's because this chalk Package has a bunch of other things that it needs to install In order for it to run it's using these other packages So you can see it requires ANSI styles and support color. And so there's ANSI styles and you know if we were to find Let's say we want to find supports color. You can see that has that uses has flag and etc, etc You know, it's just a chain a dependency tree. That's why it's called that so looking at chalk, you can see that the version installed is 410 and that is what we chose it to install but Let's take a look at the yarn lock file and see how that differs So the yarn lock file it's a little bit different format, but it's giving you a lot of the same information The major obvious difference right up front is that it has this Version appended to the actual package and then it has a thing called version. Let me show you what that actually means So if you were to say change this to 4 0 0 so that's our target now And I were to run yarn and I'll also run npm i There's a few things that we need to talk about here So the first thing is that you can see it still says 4 1 0 and if we go to the yarn lock It now says 4 0 0 and 4 1 0. Why is that? That's because this is this first one is saying what your you know, target version is and You know, that's why it has the caret there and that we want, you know No more than four but any minor or patch version can be upgraded, you know, whatever new ones out So anytime we run yarn that will that's what will happen. The version itself is telling you the exact version that's installed so This is the major difference here That you know it if we were just to look at the package JSON file and we can see that we have 4 0 0 Selected but that's not actually what we have installed as you can see here and in the package lock We have 4 1 0 so you might think if you didn't know this a little better That 4 0 0 is what we have installed since that's the instruction so let's say that Hypothetically, let's let's bump this to you know, three let's say and I'm going to just like delete these real quick So I'll delete those and we're gonna install three so yarn PMI We come back here. And if we look at the lock file, we'll see that three is installed And if we go to this lock file, we'll see that three and three are installed. That's interesting, right? It just happened to line up now Imagine in this hypothetical world. Let me go back here that I have a project and I'm using this dependency chalk and I'm on version 300 now if I did not Commit and push up my lock file what could happen is another person Using my project that pulls the project down fresh and runs install with whether it's npm or yarn doesn't matter they Might get a different version. Let's say that maybe an hour or two later or a day later Someone's pulling this down and since then the people who work on the chalk project have pushed up a new version They've got 3 1 0 out. Okay. Well, that's a minor and that should be okay, and we're not gonna move past the major So we might be fine, but a bug could have slipped in there or some sort of behavior That's a little bit different might you know cascade into a problem and what's tricky about this is that? Even though we have this, you know baseline set of instructions that we want to start with 300 I now locally have 300 and you let's say that you're using my project have 3 1 0 And so the problem there is that if you have a bug You might say hey, I run your project and I have this issue and I'll say well that doesn't exist on mine And now we don't know what it is We don't know if it's someone else's code a third-party code or if it's our code that we wrote and that's that's really the problem that the lock file is trying to solve\n\nSo with the lock file if you've committed this and pushed this up It is not going to install later than this version that you see here regardless of what the target is Whatever whoever's lock file is there is what's going to take precedent So, you know, even if chalk 3 3 0 is out or 3 3 5 or whatever It's not going to move past 3 0 0 it's going to use that one And so that ensures consistency between all our servers and it's not just for between developers It's also for as they mentioned like CI continuous integration or on a server or deployment or something like that We want consistency between all of these so that we know we're all running the same code base as much as we can anyways So I think to round this video off One thing that you know Why don't people commit a lock file and I want to at least show something for that. Well, what commonly happens is that You have an issue Let's say in your node modules or you have some sort of conflict and people are just you know Tired of dealing with the issue and so they they delete node modules Or they think the only recourse is to delete the lock files now deleting node modules There's actually, you know, pretty normal in a lot of situations. You shouldn't have to do it too often But every now and then it's fine because you can just delete the lock file You can just reinstall them and if you've got the lock file it'll install the same ones but if you delete the lock file, you're essentially starting from scratch there and You know everyone else who pulls down your version is gonna have a whole new set of things to install It might be a problem it and it might not be a problem, but it does interfere with inconsistency or does interfere with consistency So let's create a weird hypothetical just to show how to deal with that situation Okay, you know, I can't cover them all but hopefully I'll cover a major one here So what we need to do here is we first need to add all our files since we're not picky at this point And then we're going to commit let's just make this the initial commit and Then what I want to do is I want to get checkout dash B I have this v4 bump that I want to do, you know We'll just say that we're we're bumping up the version 4 for whatever reason Bear with me now on this branch. What I'm gonna do is I'm just gonna change the target to 4 okay, and maybe actually I'll make it like exactly 4 for whatever reason, you know That person is that important here? And then so what I'll do is I'll run yarn and I'll run npm install. Okay, and You know, let's look at what happened here and you can see that because we changed what the package JSON target is We were able to change the lock file at that point, you know, don't be too surprised by that And the same thing here And so now what I'm gonna do is I'm going to commit this time I'll do it through VS code because why not all each of these files you can see we change the lock file here We changed this lock file and then we change the package JSON Now a quick note here. The yarn lock is not meant to it's it says or all lock files It's this is an auto-generated file do not edit this directly. So, you know, let let the package installers deal with that So we'll say bump to v4 Perfect and now what I want to do is I want to go back to master And I'm gonna make a new branch and this one I'm gonna say Bump To for one, you know, these these branch names are terrible, of course, but You get the point So now I'll go to my package JSON and I'll say I want this to be for one, okay Now I've chosen these because they're actually going to create different lock files here So when I run yarn and I run MPMI And I go back to my editor What I should see here in my files is if I look at the yarn lock the chalk version is set to for one this Time, okay, perfect. Same thing with this lock file shouldn't be any different. We'll go back here We'll add all our files. I'll make another commit that says bump to for one Don't write commit messages like this in the real world, please Look at our status beautiful So now we'll go back to master and what I'm going to do is I'm going to git merge and I'll do this It doesn't really matter what order here, but I'll do I've got these two bump to for one Okay, so we'll merge bump to for one first and then now what I'm gonna do is I'm gonna you know Let's say someone else made another PR for this. I'm gonna bump. I think what did I say before? Let's see. What what branches do I have? I've already forgotten my names V4 bump nice naming conventions. So git merge v4 bump And notice we have a conflict. Okay, we have a conflict in the yarn lock We have a conflict in the package.json and we also have a conflict in the package lock json. Okay So what do you do in this situation? Well, this one might be pretty straightforward It should be but I'll go over it real quick. You've got these two versions your package json You do need to manually resolve this you need to decide which one do you want? So let's say that we want the 410. We're just happy with that one. So we'll accept current change Okay, perfect But now you still have a lock file that's in conflict and a package lock json that's in conflict And the problem here is that you're not supposed to edit these files at all And so I know that some people will just delete this and start over, you know Because they're not they're not really supposed to change it or they'll just change it manually And it'll just kind of get out of sync. But here's what you're really supposed to do Now that you have the package json file resolved you just write yarn. Oh, that is because We need to go to package json And we need to add that file What does it think? Oh, that's because I haven't saved of course So now I've saved it, right? So this is kind of cool little accident here, but it'll tell you an unexpected error occurred And then it'll tell you this arrow in json. It's not a great helpful error I wonder if I can actually go back Let's go back to this conflict real quick just so you can see now if I were to run npm install You actually get a lot more nice error in my opinion from npm So it'll say please resolve the package json conflict and try again So let's go back to that We'll save and now we'll run them so npm i And notice it said a git conflict was detected in package lock json attempting to auto resolve Beautiful and then I'll run yarn and the same thing will happen merge conflict is detected And the same thing will happen merge conflict detected in yarn lock and successfully merged Perfect. So now if we look at these files, we do not have a conflict anymore So now we can just add all of them. We can ignore this error log that I generated discard that Okay, so that's how you should resolve that type of conflict Obviously, there are other ones that arise that you know Would make this video very lengthy to try to come up with all the situations So i'll leave it at that just know that you are supposed to in the end commit your lock files up You should try not to delete them unless the most extreme emergency And you're just pulling your hair out and you can't find any other way But if you're working on the team of developers, please let everyone know and consult with them first Because you might cause more problems than you solve in the long run If you made it to the end of this video Hopefully you walk away with a better understanding of semantic versioning As well as why you should commit your lock files up to your version control And if I happen to miss anything or didn't cover anything as much detail As you would have liked just leave a comment. Thanks everyone!", "metadata": {"title": "Should you commit Javascript package lockfiles?", "url": "https://www.youtube.com/watch?v=i-AuSqlRRpQ"}}, {"page_content": "Welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and in this episode, we are going to be covering a Webpack TypeScript setup from scratch. I'm going to be going over every little piece of code and package that you need to install in order to have a basic TypeScript setup running so that you can feel a little bit more confident about what your project configuration is doing under the hood. We'll start in the terminal here, and we're going to make a directory, and I'm just going to name it Webpack TS. You could make this directory whatever you like and however you like. If you want to use an editor or whatever, that's fine. And then we'll just cd into there. And then what we're going to do is we're going to init a npm project dash y is to say yes to all the options. We don't care about answering them right now. And then what we can do is we know that we're going to use Webpack, so we'll just install that. Now, the I here just is short for install, and the dash uppercase D is short for dash dash dev, which installs it as a dev dependency. And the reason that you're going to want to install it as a dev dependency, which you'll pretty much do with all of your build tools typically, is because your end result that you're going to ship to the client, it doesn't rely on those packages. So you really just want to use them just to build the things, and then they're not bundled together in your final output. Hopefully that makes sense. And then, well, let's actually just create a file here while we're here, and we're going to make a JS file to start. We'll turn it into a TS file in just a bit, and then we might as well just open our editor of choice here. Okay. Ooh, did I do code? That was weird. Okay, so now you can see we have our package JSON, we have our lock, and then we have our index. And so let's just real quick create a age variable and just set it to 99. It doesn't really matter. And then we can jump back over to the terminal here, and then what we can do is run NPX, which comes with all the modern NPM installs. It's just a way to either use a local version of something you have or go ahead and grab that real quick and run it from NPM's registry. So we'll do NPX webpack, and this is just so you don't have to install it globally. And I kind of want to just show how you, what little you need to run this. So I'm a fan of when I'm trying to learn something, I like to go through in sort of like a red-green way, kind of like TDD, if you're familiar with that test-driven development. And what the red-green means is I want to see the error first and then make it work. So rather than install the packages right up front, like maybe a readme would do or a lot of walkthroughs, I want to show you kind of how I go through the process of figuring out what all I need to make this thing run. So in this instance, you can see that when we ran NPX webpack, it says that you now need webpack CLI. And that's kind of cool that they tell you that. So normally when you set this up, you would just see the docs saying, okay, install webpack and webpack CLI because you need them. And I just like to test them, like, do I really? Let's see. So yeah, we'll say yes. Cool. Seems like we do. And that's good enough for me. Okay. So then it finished. And you can see that we got this module not found, can't resolve dot slash source, which isn't the greatest error, but it kind of leads you in the right direction. So what this is about here is that our index.js is not in the source directory. And when you run webpack without a config, which a lot of people don't even know that you can do, you need to have some defaults in place. And one of them is that it's in the source directory. So source index.js dot slash source is kind of short for that. So now that we've put that in here, let's try and run this again. Npx webpack. And it built. Pretty cool, huh? So let's jump back over here. And you'll see that a dist folder was created for us. And then if we go into this, we'll see a main. Now there's nothing in there. Well, that's because we're making a production bundle. And we created this variable, but it doesn't do anything. So if we were to log it, for say, whoops, just type the number in, you silly goose. And then we'll go back and we'll run it again. Now you have to run this every time you're going to build. We'll do a watch mode in a minute. But for now, you have to run it each time. And now you can see in your main.js, it's going to do console.log the number. Okay? Because what it's trying to do, it's not going to try and build every single line of code that you are writing. It's going to build what you need to run your program in the end. All right? Now we want to keep running this script. So what we're going to do is we'll make a script called build in our package.json. And then we'll just run red webpack, just like we did before. All right? And then now, whenever we want to run this, we can just do npm run build. And that'll do the same thing as our npx thing. That's just so that it's actually local in our project. Now, we're going to change our index.js to a ts file. Okay? And then we're going to do the same thing. We're going to come back here. We're going to try and run it. And you're going to see that it fails. So the error here is the same that we just got before. So that just kind of clue us in now that we've solved that. It can't seem to find that file. All right. Well, that is because what we need at this point is a webpack config if we want to actually use a ts file. So if we make a new file in the root of our project, we can name it webpack.config.js. And that's your default there. And then this is just going to be module.exports. And you're going to export a sort of a config option here. Now, what you need, the minimum that you're going to need for this is actually just to resolve that file extension, surprisingly. You don't even need a loader at this point. So extensions is going to be.ts and.js. So we're saying what I want you to resolve or look for is anything that ends in.ts or.js, because by default, it's just going to look for those js files. OK? And now, if we come back over here and we run this again, you can see that we got a build. All right. Well, let's check it out. Did it work? Yes, it did. Pretty normal, right? Now, we're not writing any TypeScript code just yet. So let's add some TypeScript syntax here. So we'll say that this is a type of a number. And then we will run this. And now we get a different error here. We get this unexpected token. And this is where it actually happens. So it's nice enough to show us that. And it gives us sort of a hint. You may need an appropriate loader to handle this file. That is correct. I wish it would try to steer you a little bit more toward like what kind it is. But that's probably pretty hard just from a random token error. So that's all right. So what we need right now is we want to run npm i dash d ts loader. That's the loader that we want. And then we'll just jump right back over to here. And if we go to our webpack config, we actually need to set up our loader now. So this is a little bit more involved. But this is pretty much the normal song and dance for webpack. So once you get this down, it'll just make your life a lot easier. So what we're going to have is a module type. And that module has rules. And that rules is typically an array of objects. And then here we have a test. And so what I'm going to do is I'm going to write a regular expression here. And I'll explain that in just a second. And then we'll say, what do we want to exclude? Because we need to say that we don't want to run this on node modules. We don't want to run it on other people's code at all, other packages that we're using. And then the last property that we need is the loader that we're going to use. So we could do loader ts loader. And then we're going to need a comma down here. And then we're good. So what we've written here is we're saying, OK, when you're processing any of my code webpack, these are the rules that I want you to go by. Now the test is what you're testing files against. So it's saying, hey, if there's ever a ts file, because this regular expression is capturing anything that ends in.ts, this dollar sign says ends in that character there. And then we don't want to run on node modules. And this is the loader that you're going to use. Cool. That's it. Now let's come back and run this one more time. npm run build. Whoa, we got a big old error here. All right. Cannot find module TypeScript. All right. Well, that's pretty simple, right? We'll just do npm i dash t or dash d TypeScript. And then we're going to run it again just to see if it'll run. OK, now we have another error. No worries. We're making progress here. And we're kind of figuring out exactly what we need as we go along. So we can see that ts loader requires TypeScript to run. And then now it says the files list in the config file, ts config.json is empty. When I first encountered this, it got me for a while. This is a terrible error. It really, I don't understand why they can't just tell you this. But really, what they're trying to get at is you need a ts config.json. And this happened to me one time because I actually just misnamed it. So the whole the files list in the config is a bit confusing for that. Now let me show you how you can get a ts config going pretty easily. So if you run, we'll use npx again. There's a tsc here, and that's for the type of file.", "metadata": {"title": "Webpack 5 and Typescript Project Setup Walkthrough", "url": "https://www.youtube.com/watch?v=4lpmVZdj12g"}}, {"page_content": "script compiler, and you can do dash dash init. And what that will do is create a ts config in your project. So let's go over here and look at that now. And it created this file. And you can see it's got all of these options. Some of them are just here automatically. And a bunch of them are commented out, which is really cool because it's just showing you the defaults. So for instance, no implicit any is by default set to true. So you can turn it on and we will in a moment to like disable that or change some settings if you want. But let's just go with the basics here. So now let's try to npm run build. And again, and see if it'll work. Boom. Okay, we got some output sick. So now if we go to main j s, you will see that we got our output, like usual, it's getting a little bit harder to read nothing crazy here. Of course, we can read it because the code so short. But let's say that we actually want to be able to read it as we go along. So if we go into this webpack config, there's another option we can add in here. And this is what's kind of cool about the not needing a config a config less setup is that you can just add things as you need them. And we can set this to development as the mode because by default, it's production. And then when we do this, what will happen is when we run this build, and we go back to our main j s, we will see a completely different format. Okay. And this is close to what we want. But there's some weird stuff here. But check out this nice little comment they've given us the eve al dev tool has been used maybe by default in mode development. Yes, we are in that. And this dev tool is not neither made for production nor for readable output files. In the end, basically, what they're kind of pointing us to is that we can disable this by doing dev tool, tool false, or setting that to some other dev tool configuration that they give us a nice link to. So let's come down here and say dev tool. All right, turn that off. No dev tooling. Let's run our build again. Come back to our main j s. And there we go. Okay, so now we have a nice little readable output that we can compare and see what our stuff is actually being built into in the end. And now you'll notice that our TypeScript is actually just being compiled to regular old JavaScript, right? So that's pretty sweet. So that's working fine for us for now. Let's actually set up a watch script now so that we can make some changes and see the code change on the fly. So there's a couple things that you patterns that you could follow here. I like to just do the colon pattern here and say, well, build colon watch is the mode that I want. And in this case, I want webpack dash dash watch. And this just comes with it. So it's really nice. And then if we come back over to here, we can say npm run build colon watch. Oops, typo. And so what that is going to do now is watch for any time that we change any of our ts files. So now come back over to here. And let's actually change some stuff and write some TypeScript here. So if we were to do, let's say we'll make a function, we're gonna call it wolf. And wolf takes in a noise. And that noise, we're going to console dot log it. All right. And what you're going to notice here, let's go back over to the terminal, because it's actually going to TypeScript's already kicking in here with its linter, that's saying implicitly has the any type, which we don't allow by default in the config. And we're getting that IntelliSense in our VS code right away, which is really sweet. So it's saying, yeah, you can't do implicitly any. Now, it's kind of weird to me, though, about this is that if you look over on the side here, you can see that our output is there. And if I were to just like, remove this, let's say, and save, you can see the output updates, even though I'm technically building an error here. But if you were to run npm run build, so not putting it in watch mode, you'll see that we actually get a failure on the build, which is what we would want. In TypeScript. So just so that you know. So let's actually change that in our config here. So if we go over to our webpack, actually, our TS config, sorry. And we can go to this no implicit any. And what we'll do is we'll set that to false. And so now the interesting thing is that this will pick it up right away, VS code will not be yelling at us anymore about that not being true there. But also, if we restart our build, it will actually build properly. So you can see that it's using the TS config to determine some of the rules that TypeScript wants to set up. Okay, so let's flip that back on, though, because we are going to want that. And you can actually just recomment this if you want, if you if you just want to do it that way. But it's nice to leave it, you know, set to true so that you know the defaults in case you forget. So now let's go back to watch mode. Watch here. And we'll get that error. And that's fine, because we're going to fix it in a moment, we're going to be bad kids and actually write any here. Okay, and got a reason for this. But typically, of course, you want to avoid any in TypeScript, if you can. So where we're going to leave that any now is for my illustration purposes, what we're going to do is we're going to create a object. So we can get some real cool TypeScript functionality going on here. So you can see that it's building more than just the simple types. So if we create this object, we're going to make it nested object here. So I'm just making up some random keys for fun. And then we're going to do an awu. We've got our dog noise here. And then you can see all this code is being built out here. Now remember what I said before, we've switched it to development. So it's actually printing out our code. If we were to switch it back to production mode, all of this is going to go away. And just the final output is going to be there just as a quick reminder. Now, here, what we want to do is say, call the wolf function, and we're going to pass it object. Okay. And you can see that getting called. And then what I'm going to do right here is I'm gonna open up my terminal down here, CD into this directory, because it didn't think that it could be cool enough to do that for me. And then we'll run node, and we'll go into the dist folder, and we'll run our actually its main.js. And there you go. You can see it running our code. And just printing out this object. All right, great. But that's not quite what we want yet. I'm going to get rid of this log here now just to clean this up. And then what I want to do is say, okay, well, what if we were to call noise.1,.2,.3, and then run that instead. And so now if we run this, we'll see we get our string printed out. But what if we weren't going to pass that in? Okay, what if we passed that in? We passed in like null here, let's say. All right. We run that, we're going to get an error. Okay. And I'm just opening this in this terminal just so that you can see it in line here. Our webpack is still running in the background every time we change on the other terminal. Sorry. So console.log noise.1,.2,.3, you know, pretty, pretty standard issue here, right? Like we tried to run a property or call a property on something that doesn't exist on undefined. Cannot read property one of null in this instance. So okay, how would we normally solve this? Well, if we weren't in, let's say, TypeScript here, we would do noise. This is one way. Noise.1, noise.1,.2. Everyone hates this world, right? Noise.1,.2,.3. We checked 1, 2, 3, I even got to look it over. And then now let's try and run this. And we'll just get null. So at least we don't get an error, right? Get what we expected here. And then you'll see in our output on the side, that we have just a bunch of ands. It's just normal JavaScript, just the way that we wrote it. But what we could do instead is we could do, why can I not type? Noise, and we can use the optional chaining functionality built into this. This is actually in the latest version of ECMAScript as well, but TypeScript's had it for a little while, and we're going to show it generating that out with TypeScript. So what we can do is say, does noise exist? Okay, well, then access this property. What about that one? Okay, and the next one? What about that one? All right, the last one. Through three. And then now we run this. Boom. You can see that we get this null and undefined. They're a little bit different. And I'll talk about why. If you come over to here, let's bring this over here a little bit, got some stuff in the way. You'll notice that the first one that we wrote is a little bit different than this one. And it's kind of interesting, huh? There's this very long set of like void code. Actually, I'll make it a little bit longer. So you can see it this way. You know, doing multiple different checks with ORs and ternary here. Okay, so why is this? This is actually by design. The optional chaining is trying to be a little bit more robust and reliable here, because if you were to type in just zero here and run this code, what's going to happen is you'll notice that zero got printed out in this check, and then undefined was printed out in this one. And typically what you would have wanted was undefined. You're saying, hey, if you don't have any of those properties, don't just break, but just return undefined to me. But the thing about it is zero in a double ampersand check actually returns the value, because this first value that does exist, it's zero. And that'll be the same with like an empty string and some others that just wouldn't give you the behavior that you would normally expect. And it's kind of hard to troubleshoot. So that is optional chaining. And at this point, uh,\n\nyou have a TypeScript setup working, which is pretty cool. You can see it transpiling here and you can see it line by line in watch mode. If you're curious about what it's kind of doing under the hood. And I don't understand as a quick note, uh, you know, all the code that's being generated out, of course, uh, I just like to peek under the hood every now and then to get rid of a little bit of anxiety of like the mystery of what Webpack's doing. It's kind of cool to see what it does under the hood, uh, just to get a quick gist of it. And then I can, you know, move on with my life feeling a little bit more confident. So we're pretty good. Here at this point, uh, I'll give you one last little piece here, uh, to make this a little bit more flexible for you. What you can do here for this mode, because you might want to switch back and forth between, um, production and development. Now you don't even have to put anything if you want production, just as a reminder, and let's go back over to the terminal here. Um, and stop this build. Cause, um, whenever you change the Webpack config, you do have to rerun this and we'll just run a regular build here. And then what I want to show is the output is going to go back to this minified version that you'd want for your final output. Okay. And I'm going to close this for a moment. So to go between those easily, you can do something this simple. You can say, um, whoops, you can actually access a process dot ENV dot. And then typically you're going to use node ENV here and you can actually go to the output. And you can say, if that's passed in, um, I want you to use that. Otherwise I want you to default to production. Okay. And now what we can do is we can say, all right, let's set our node ENV here and we'll set it to, um, development. Actually, let's not set it the first time, just so you can see that. So if I just run NPM run build now, uh, and go back to here, our code will just be run in production mode, just so that you can see that it works. And then now we'll set node ENV equal to development and we'll do NPM run build. And we'll go back over to here again, and you'll see it ran it in this mode. And just so that, uh, in case you're wondering, Oh, well, what if we just pass something non that? Okay. Well, typically your system shouldn't be doing that, but if you did happen to do, you know, woofers or something, you can actually do that. Something like that here, and then do NPM run build. You'll see that you get an error. It'll tell you, uh, we expect the development production or none. So it's pretty nice. Um, that, that, that's the gist of it. And then now, if you want to just set up some scripts where you set node ENV or however you like to do it in your system, um, you've got a little bit more flexible config. Now, of course, there are a bunch of other rules that you can set in the web pack and fig. Uh, you can find those in the docs, or I actually have a video that, uh, more thoroughly goes through a web pack, trying to understand the basics of it. And it covers, uh, like source maps and having a web pack, dev server, uh, entry and output points and all that type of stuff. I'll link that in the description and a little notification card in case you're interested in that. And I'll probably be doing some, uh, future videos pretty soon about the different types of loaders, like probably doing style sheets, SAS, and all that type of stuff, uh, in the next set of videos. So if you're interested in that, please like, and subscribe, and I'll see you on those videos.", "metadata": {"title": "Webpack 5 and Typescript Project Setup Walkthrough", "url": "https://www.youtube.com/watch?v=4lpmVZdj12g"}}, {"page_content": "Hello and welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and the goal of this video is to get some data from a headless CMS into our Next.js site. The headless CMS that we're going to be using is called Contentful, and I've chosen that because I have a fair amount of experience with it, and I've seen it growing in popularity, especially in the enterprise sector, where more and more companies are starting to adopt it. So I do think it's a good tool to have in your tool belt, but I do recommend learning multiple content management systems since it is a rapidly growing tech trend. It's just good to have a general familiarity with how these systems work. Keep in mind that that doesn't mean that this is my favorite CMS, it's just a generally solid one that a lot of people like, so I've chosen for this video. For the Contentful setup, I will be creating a new account, just so you can follow along with me and see what it's like to create a Contentful space, as they call it, create your first content type and content entry. And I'll be explaining some things along the way, whatever is necessary to get our minimum viable setup going for consuming that data in Next.js, but I won't be going over every little detail of Contentful in this video, just so you're aware. I'm assuming most people clicking on this video will be familiar with Next.js, which is what we'll be using as our JavaScript slash React framework of choice for this video. So while I will be walking through each of my steps so you can follow along, even if you're not very familiar with Next.js, I do think it'll be easier if you have a general familiarity of the basics of it and what it does, and of course with React and JavaScript. I won't be going into what exactly is static site generation and what's server-side rendering, or even why should you choose a headless CMS over other content management systems. It would just lengthen the video too much, and so I'm trying to keep this to sort of a minimal setup, where I do spend some time walking through, you know, what is Contentful and how to set that up, and what are some of the steps of Next.js. But our primary goal is just to get those two things hooked up and generating out pages with minimal setup. So feel free to use the timestamps if you have a specific thing that you're looking for. One last note is that I do plan on making some videos in the near future of some additional features of this particular setup, such as preview mode using Contentful and Next.js, as well as dynamically generating out pages by a slugger ID. And now that you know what you're in for, let's get into the code. I'm going to kick us off here by creating the Next.js project. So you can do that by doing npx create next app, and then at latest is usually what they recommend. I'll press enter here. And we can name this whatever we want. So we'll call it Next.js Contentful site. And then depending on your connection and everything, it'll take a little bit to run this. You can see it's installing React, React DOM and Next, and then for dev dependencies, ESLint and such. Now, just so you know, I'm on Node version 16.14.0, in case you want to follow along and you have any issues or anything like that during installation process, you might want to be on the same one that I'm on. But it should be fine on many other versions. So now what we want to do is go into this directory that they've just created for us. And I'm going to open it in my code editor of choice, VS Code for now. And as that's open, what I'm going to do is I'm going to flip back to the terminal and I'm going to start this by running npm run dev. Now, you can find all that out by going to here. Let's see, the docs for Next.js. You can go to docs and I'll link this in the YouTube video, but you can just search Next.js on Google. Scroll down here in the getting started and here's that command we ran. And you could also use yarn and we could have done TypeScript, but I want to keep it as simple as possible for people following along. Scrolling down here, you'll see that here's the scripts that we're going to take a look at in a moment that you could run. And even down further, this is just a basic example of like the simplest component that you can export here. So let's go back to our code. We look at our code, we go to package.json. Here's the packages that are installed. And so also if you're following along and you have any issues or whatever, you might want to try to make sure that you're on the same version that I'm on, 12.1.0 for Next, and that will subsequently install these. We also have these scripts here and that's what we're running right now is dev. So if we go to pages, this is the way that Next.js works. When you create a file in pages, whatever you name it is going to be the path. So you can do product1.js here, just right in the root of pages. And just so you can see real quick, this is our index.js. So that's like our homepage, pretty standard format there. And they came with a bunch of like code already set up for us, which we're going to see, but we want to create this product1 page. So the minimum thing to do that is to do export default, it has to be a default export, and then do function, and we can name this whatever we like. So I'm going to name it product page. I really recommend naming it and not doing an anonymous function because it will show up in the stack trace. Instead of being anonymous, you'll have product page, so it'll help you get to an error quicker. Then just like a regular React component, we'll just return some JSX here. We'll say hard coded heading. And then let's go back to our server that we started up and running that went on localhost 3000. And here we are, here's that homepage I was talking about with all that code they started us with. This is pretty standard, nothing crazy, but it's nice. It points you to where you can kind of start editing stuff. We want to go to the page that we just created, which is slash product1. Okay, so we have our server, here's our homepage, here's our product1 page that we just created. It does have hot reloading, which is really cool. I'll just show you that real quick, so if I were to change this to hard coded h1 or something like that, if I flip back over, it's instantly changed. You know, nothing crazy there, it's just, you know, hot reloading is pretty nice. It's a nice time to be a developer. So next what we want to do is kind of scaffold this out. So what I'm going to show you is there's this method you can go to in the docs called getStaticProps. And this is pretty much the, I would call it the default method of what you should be using if you are doing any sort of static generation or you're just kind of doing a lot of static generation. Static generation or server generation, because there's also a couple, like there's this getServerSideProps that you can use as well. So let me really briefly kind of go over the difference between these. So one of them is using static site generation, which is just doing it all, building all the pages ahead at build time. Okay, this is usually what you want to use because it's going to be the fastest for your users. You're going to incur a little bit of a penalty on build time. You won't notice it much until you start doing some pretty advanced stuff, you know, much larger scale. But the getServerSideProps is also really fast. And it's a good alternative when you need to do something dynamically, like you want to know what your user's location is or what their device is or something like that. That's the time where you kind of opt into server side props. There's other times too, I'm glossing over it. I just want to give you a quick overhead that there's these couple different methods that you might use. And how you would use that, you can see, let's actually just copy this. As you go back over to your code and on any page, it's kind of cool, you can opt in to this behavior. So normally it's just kind of like, you could think of this like createReactApp or something like that, it's just a regular component. But then we can do this export any function. I'll leave off async for now, actually. Normally you would do an async function, but I'll just leave it like this just so you can see. We'll clean up all of the clutter. And this will essentially just make it work. Let's go back to our thing, server here, reload, and it runs just fine, right? Now, let me show you when it doesn't run fine. So let's say we didn't put that, we just exported the function. What's really nice is Next is going to let you", "metadata": {"title": "Next.js + Contentful minimal setup from scratch", "url": "https://www.youtube.com/watch?v=MbEIGh5cWWI"}}, {"page_content": "What's really nice is Next is going to let you know, hey, getStaticProps function did not return an object. Okay, so they want you to return an object, and then subsequently they're going to tell you you need to return props with an object. So this name is important. Next.js is looking for this name specifically getStaticProps. And for our purposes, we're just doing this like one single page, pretend we're doing a product review website or something like that. So normally you might dynamically generate these all based on the slug or ID or something like that, but we're just going to keep it simple, minimum viable. We're going to set this up in such a way that we're just creating every page. We're kind of starting out and we're like, all right, we only have a few product pages, so we might as well just hard code those. So this could be whatever path you want and whatever name. And now how you get the data from this into this product page is through the regular props, just like a regular React method. So what are we going to want here? Well, we would want something like props.heading. So let's provide that for ourselves. We'll go to props and we'll say, oh, well, I want a heading here. And we'll just hard code it for now. Let's see, getStaticProps.heading. If we go back over to our site, we should be able to refresh. And there you go. We just get it. Now, if that seems a little pointless to you, well, right now it is. But what we are wanting to do here is this is a function that runs at build time. So you might be used to something like, if you're just doing a regular single page app with React, you might do use like useState plus useEffect here, and you'd do a fetch and you'd hit some API and then you'd render some data. That's all client side. And so the user has to wait for that after they've already downloaded the document and everything. This is doing this at build time. So we're going to get data from headless CMS here, or fetch an API or whatever. And that will run at build time and pre-generate all of that content out into the HTML so when they get the document, it's already built into the page. It's pretty cool. I'm not going to go into all the depth of showing that for here because the purpose of this is to hook up to Contentful. I'm just kind of trying to give a quick overview for those who aren't super familiar. So now that we have our kind of scaffold set up, we know what we want. Let's go to the Contentful website and set up our account. So we can go to Contentful.com here, and I'm going to do sign up for free. Now, this page is very corporate-y. It's very enterprise. You might be a little thrown off by the, they need a company and they want to work email. And if you go to sign up, it's all required, right? So don't worry about that. You can just use GitHub or Google, and they have a pretty generous free tier. You can totally use it just as a regular developer. I'm actually showing Contentful because it is, you know, appealing to a lot of enterprise companies right now. So it's a nice skill set for you to have, but you might also want to use it for just, you know, your own sake of knowledge, or maybe you're just dabbling with a bunch of CMS. So I'm not going to have you watch me fill this out. I'm just going to, you know, make an account real quick, and I'll skip ahead. But the one thing I do want you to choose is like, make sure you choose JavaScript as your development platform. That might matter. Job title, you don't have to worry about this. Just do other, and then maybe like developer job function, whatever you want there. Okay, I'll see you on the other side. Okay, I finished signing up, and it's just loading now. And then it jumps over to this tutorial, which is pretty cool. So kind of follow along with this on me. You could totally do it your own way if you want, but if you want to follow along, here's what we're doing. We're going to do don't know yet, so we don't have to answer anything. And then I'll do, I decided to use Contentful. These are the important options. We want to do that we're not at all familiar with anything, and that's because we want to go through their little tutorial. It's pretty neat. Okay, so here we are at the quick start guide. Now what we're wanting from this is essentially, it's going to walk us through creating our content model, a single content type, the entries on that, and then, well, yeah, an individual entry for that content type, the fields on that, that's what I meant. So a content model, what is that? You know, they have a quick little description here. It's essentially, you know, the schema for your database or something like that. It's how you're going to store all of your data and what you want the content structure to look like. It'll make some sense as we go, but that's kind of the overall database here for your CMS. So we have this editor view here that's showing this. It's a cool little diagram here where we have this news article. This is what we're going to look like when we're editing things. And that is rendered based on this right here, this news article content type. It has a heading field, a hero image field, and an author field, which you can see is a one-to-many relationship here. That's what it looks like anyways, of this author, also a content type. So these two different content types kind of drive this. So let's design our content model. Yep, we want to create our first content type, cool. And then here, I've already done a little dry run here. So you can see I've got some auto-filling, but this is a product review that we're going to make here. Make whatever you like, of course. And a brief description. I'll show you where this shows up for products. So this is just the content type. You can type whatever you want here for the description. When I create that, it's going to ask me to add my first field to it. So I'll add a field, and there's a bunch of different types. I'm actually going to go over some of these in future videos, but for now, we're just going to stick with text to keep it simple. We'll choose a heading. We'll choose short text, which don't worry about it saying exact search. There are different methods you can use to search. It doesn't have to type it exactly. I'll show you that. But we're just going to call it heading. It'll automatically give you an ID, and we want to do create and configure. We could do create and come back later, but I just want to do it right now because I want to go over to the validation tab and pick required field. So I just want that to be required, nothing crazy. And then there's a default value, which is new, and that is very cool. I'm pretty excited about this, but we don't need it for this purpose right here. There's also an appearance. You can pick what you want the field to look like, which is pretty neat. You can embed it in a YouTube video or something like that, but we just want some help text here. So I just put, this will be the text for the H1 tag. I'll click confirm. And now I have my first product, and you can see here's that little description. So this is the first content type in our content model is a product review. If we click save, that will walk us over to, or actually it'll just save, sorry. It wants us to click content. So it takes us over to content when we click that. And this is normally where you'd add all of your entries. We have nothing yet, so we'll click this. And now we're going to create our first entry, which is like an individual instance of a content type. So we'll create and edit an entry. And all we have to do is fill this one field out that's required, and you can see here's our helper text. And I didn't really mention much about the helper text here. It's sort of implicit, but if you've never been in this situation before, this can be really nice if you have like content editors using this and they don't quite know what these fields map to on the website. It can be nice for little hints like that. At least that's what I use it for. So now the heading will put the very first product, bang, bang. And now as soon as it saves, it'll let us publish it. And now that is published for us to call from the SDK or an API. So let's go to Space Home. And that just took us right here, Space Home. And then here we've done our first couple of steps and they now want us to fetch content from the API, which is what we want, of course. They give us a space ID, content delivery token, and the actual entry", "metadata": {"title": "Next.js + Contentful minimal setup from scratch", "url": "https://www.youtube.com/watch?v=MbEIGh5cWWI"}}, {"page_content": "space ID, content delivery token, and the actual entry ID, which is really nice of the thing that we just created. You'll see how we use this in just a moment. Come down here and it wants us to make our first request. I've actually tried this curl command and I couldn't get it to work. I tried messing with it in different ways and just never worked for me. So if you have that problem, don't worry about that. If you got it to work, then you're smarter than me. But go to JavaScript and there's a little guide that we're gonna follow here. With this JavaScript guide, you can just scroll down and it wants you to install Contentful. Let's just do that real quick. So go back to our terminal, we'll shut down our server and PMI Contentful. So that will default save it to our dependencies. Okay, we might as well start our server back up. Come back to the browser and you can see that we can just import it this way. Now we're using ES modules, so we might run into a little thing with that in just a moment. I'll kind of talk about that. But what we really want is this initialized client. So I'm gonna copy that for now. You can guess I could just click copy on. And I'll come over to here and let's see in our editor. So now what we want to do is we're gonna want to use this here. I'll explain that in a moment. But, or why we're doing it there. Let's say that we wanted to, they had this like var, Contentful equals required. This is just like normal JS, like you're using it as a script in the browser or whatever. And Contentful. So if we do that, let me show this. We can just log it right now, just to see. And I'll comment this out so we don't run into an issue with that. So I'll log this out so we can see if it's working or not. We'll go to our server. We have to actually refresh or like hit the server curl or something to get it. And let's see. Module not found, can't resolve content. Oh, I had a typo there. Contentful. Sorry about that. Okay, so it ran. And if we go to our server, we'll see right here, it logged it out. So it did work, but I actually don't want that. Why? Well, if you go back to index.js, you'll see that we're using ES modules as kind of our standard. And it's cool that that works, that we can do that. We can actually do that in conjunction with an import. So we could do import like link from next link. And this will work fine, but I just don't know what the ramifications are for that. And I don't really like mixing the imports here. It just gives me some concerns. So I was like, well, I'll do import contentful because usually if they support ES modules, you'd be able to do it this way. And they do say that they do. But what happens here is I'll get rid of that. And then I'll hit the page. So we're just gonna use an ES module version of it. Go back to the terminal, and you'll see that it says contentful undefined. That's really unfortunate, right? But let me show you how to deal with that. So what we can actually do, if you don't know any better, you could try and just do this star as contentful. And I'll kind of show you why that is. Let's refresh this, see if it works. And you can see it does work, right? That's pretty weird, huh? There are some docs that I did finally find that walked through that they wanted you to just do. This is an alternative you could do. Pull off this create client, sorry, method from. So you can always destruct like that. But how come the default didn't work? A lot of times when you use a library and you see the common just way to import it, which is like this var contentful or const contentful equals require, whenever you see the require syntax, you would think that you could just import this as default like we did before. So the reason that this is, is because sometimes when they support ES modules, they just kind of don't bundle it that way. They don't set it as the default. And so just a little troubleshooting tip here, you could go into node modules, it's going to get in the weeds here. But if you come down to the package contentful, what I'll do is I'll take a look at their package JSON. I'll be like, do you have a module type because webpack and some other bundlers will use that as a sort of flag that that's where the ES modules are. And they'll just continue to use main as like regular common JS. We do see that they have that. So we could go into their dist ES modules and it's telling us contentful JS. And in here, I'll just search for exports. And so with exports, you're commonly going to get this one because this is just part of the bundler, the exports ES module setting it to true. But then there's one more and it says exports dot create client. And that's the only one there is there's only these two. So we know that there's only this one export apparently. And whenever it's exports dot, that's going to put it on the exports object. So that's what's going on here. That's there's there's no default here. That's been set up. We just have this exports object. So we can import star which is like import the whole object and name it contentful. That's just the way that I like to do it. So I can kind of keep the same contentful dot create client syntax. Cool. So just a little tip there if you're you know, we're stuck in that land, can't find it in the docs or whatever. So I'm gonna get rid of all that. And we'll just use this syntax going forward. Import star is contentful. Alright, I'm happy now. So now we have this client. And we want to connect this up, right? So, hmm, okay, what do we do here? Well, we go back to this little tutorial here in our contentful. And they have given us nicely this space ID, I'll copy and paste that now this is public. It's perfectly fine for this to be known. In fact, it's right here in the URL bar. It's how you access it. I personally would still keep it secret because it's just another attack vector. But it's not the end of the world if you share this, however, access token. Don't share that. Make sure no one knows this. You can see mine right here, because I'm just gonna hard code it here just to get it running really quick. And some alarm bells should be going off for some of you, please don't do that. I'm gonna remove this space first of all for myself. But if you are following along here, do not commit this up, because this will be a headache for you. You'll essentially have to generate a new API token. It's not the end of the world. You can't really get it out of git history. It's kind of a nightmare to try. I've been in this situation before if you accidentally commit this up. So don't commit this right now. I will show you how to obfuscate this in a moment. For now, I'm just going to try and get this connecting, right? So we're all over the place, sorry. Now we're at this point where, okay, I'm getting the client, but why are we doing it here? You know, how would you know to even do it right here? Well, you can think of it this way. This git static props, right now it doesn't really matter. It's only going to run this one time because we have it on this one page. But if we were to do this dynamically, there's a time where we'll run this function for every single page that we're generating out. Anytime you're putting something in a function, just kind of expect it to be rerun. We don't want to recreate this client over and over. We kind of want the singleton behavior. So you could put this in another file. I'm just trying to co-locate everything or less fancy terms. Just put it all in the same file for now to keep it simple. But if we put it right here, it will just run as soon as this file is imported. So whenever Next.js uses this file, it'll run one time. And then everything in the scope of this file has access to that. Okay. That's just the way I prefer to do it. So now we'll have this client and let's go back to the docs and make it do something. If we go back here to this like JavaScript thing that we were following along on, I'll make sure to link these as well, both of these in the YouTube description. You can go to request a single entry. That sounds great. So let's copy that code, come back over to here, and we're going to run that right here. So we have the client. We'll call the client. We'll call client.getEntry, which is essentially a fetch here. And now we just need an entry ID. And then", "metadata": {"title": "Next.js + Contentful minimal setup from scratch", "url": "https://www.youtube.com/watch?v=MbEIGh5cWWI"}}, {"page_content": "And now we just need an entry ID. And then when it comes back, it's going to log these things out. So let's get that working. Go back to our space. And here's the entry ID. This is really nice of them to show you this. Okay. So we'll copy that. So this is for the very first product. It's the ID that we just created, or that it created for our product. And we'll paste that right here. We'll save that hard-coded. And then now we will hit our server. Boom. And go to our logs in our terminal. And here we go. Now you'll see that we got all this metadata for the first log, but then we got undefined. All right. So sort of so far so good. You can see that is our space and everything. But what we really want, you can see that it's a content type of product review. What we really want, sorry, is this right here. They gave us product name, and I didn't switch that to heading. So hopefully that's kind of making sense that what we're getting back is the entry that we created. There's some system data forward or metadata or whatever, but then field is really what we care about. Let's go back to that just to kind of cement that in your head. If you go to content here, these are all your content entries. And you click this one, and these are your fields. Okay. Or another way to look at it is go to the content model, click on the thing, and these are your fields. Okay. So we have a field of heading. Let's try and rerun that and see if we get it. Reload. And there we go. The very first product. Cool. So now all we have to do is pass that data along. Okay. So we can just pass that along to our component right here, product page, the way that we had already set up. But because we're in this promise, we actually would need to like, you know, we can't just return in this promise, essentially, we'd have to return the promise. But, and that will work fine. But I think it's a little more straightforward to do it this way. Because we're like, how do we get the data out of the promise after we're done? Well, we'll just set a sink here, like we originally had. And then what we can do is we can say const, let's call it product equals client dot get entry, you know, we don't even need any of this. We'll just fire this off. And whatever comes back will be the product that we get. And here we could do product dot fields dot heading. Oh, I didn't do a wait here. That's cool that they auto completed that for us. I actually want to do that up here. Sorry. That's kind of interesting. So I want to await this fetch and then move on to pass this into here. And this should just now work. Okay, our heading should change now. Reload the very first product. Cool. So we now we have a contemplable space with our first content type, and then pulling that data in to our next JS site and rendering it on the page. Pretty sweet, huh? So if we go back to Contentful, just in case you were following along, and for whatever reason, you didn't get these like home screens or whatever, all this stuff, let me show you how to get some of that information. So the first things first, you can go to your content entry, you can just go to content, click here. And if you click this info over here, that's where your ID for the entry is. Now a lot of times I won't be using this most of the time, because I'll be kind of just like going through a loop and generating them automatically. So I don't have to look them up by ID. But just in case you ever need to, this is where you get that information. Also, for the API keys, you can go to settings and API keys, and they just have this blank one like auto created for me. So I'll name this like next.js or something like what it's for. And then scroll down and here's your space ID. And here's your content delivery API access token and all that stuff. Okay, there's also a preview token, which is for like when stuff's in draft state, you want to publish it, I'm actually going to do a video on that too with next JS preview would be pretty cool, but I'm not going to go over it right now. That's for a future video. Okay, now I promised you that I would show you how to deal with this stuff. Okay, so we don't want this in here for when we commit our code up. So how do we obfuscate that? Well, the normal way is with an EMV file, you see, we don't have one by default. But if you go to their git ignore, this kind of clues you in, they have these dot EMV local development test production files ignored. Okay, the quick overview of how next JS handles this is you could actually just use a dot EMV file, they'll read that as well. But dot EMV dot local is really what they're intending for any like secrets and stuff like that. That's because the regular dot EMV, we come back to that. The regular dot EMV dot development, not dot local, just dot EMV dot development is a file that you can use along with production to kind of put some defaults that your system will run on. And then you can have some very specific things that you want, especially like hidden secret keys and stuff like that API keys, you can do in dot local or the dot local versions of these. Sorry, if that's a little confusing, just for now. Usually you'll be fine. If you have any secrets, just storing it and dot EMV dot local. So Contentful, I'm going to name this Contentful space ID. And then I'll do Contentful access token. Those are the two that we need. I'll just copy these. So I've got the spelling right. And then here, what I can do is I'm going to copy this one to this one. And I'll copy this one to this one. Okay, so there's our file. And you can see it's not being tracked. It's gray here. So it's not wanting to track it. That's what we want. And then for these, we can just do process. This is just like node dot EMV dot, and then that name, this name right here. I'm making a mess of everything. Sorry. Same thing here. Replace this with process dot EMV dot. Put that there. Beautiful. So now let's make sure that when we refresh the page, everything's still working. Looks like I messed something up. Expected parameter access. Oh, you know what? I think we have to restart the server because we added some EMV files. So let's do that. Come back here. Refresh this. There we go. Very first product. Still working. Cool. So we have a really basic setup here, and we're pretty good. Let's just wrap this up by adding a couple more fields to make it a little more real here. So I'll go back to my Contentful instance. I go to content, and you can just discard those changes. We'll go into this. Actually, we're going to go to the model. But notice right here for the name, it says the very first product. It's by default using the heading. Okay, we're going to change that. So if we go into our content model, product review, we can now add a field. I'm going to add another text field, and we'll call this subheading. I'm just going to create it. No stipulations. And then we're going to add another field. It will also be a text field just to keep it simple. And we'll call this product ID. This one we are going to create and configure. We want to do a couple things here. We want to say this field represents the entry title. Sorry about that. So this will represent the entry title, and that's that name that it showed whenever you're looking it up. So this is the thing that we'll see as the default. So imagine that we kind of want to tie each of these review pages to a product ID to find it easy so we don't have to search by heading or whatever. Then we'll go to validation. We'll do required field and unique field. So we want, you know, it's an ID. We want it to be unique, and then we want it to be required. And that's pretty much it. We could do a placeholder or something like that, but I don't think we need to. You can rearrange these however you like. We'll click save. Then we'll go over to content. In the content, you'll notice that this is untitled now. That's because we haven't filled that out. So we added a field, so we can't publish until we add this required field here. So we'll call it product one. Then for the subheading, we'll do a cute subheading. Okay, so while we're here, let me show you the search thing I was mentioning. So one little quick pro tip here is you can, if you like wanted some extra fields to find, like, you know, say you've got a lot of different entries in here and you're trying to find one, you know, you could even have hundreds,", "metadata": {"title": "Next.js + Contentful minimal setup from scratch", "url": "https://www.youtube.com/watch?v=MbEIGh5cWWI"}}, {"page_content": "one, you know, you could even have hundreds, you could click this little cog and come down and you can show whatever fields you want, which is very nice. So heading, we can do the very first, let me zoom that out just so you can see it. It's very first product. So you can see it. That's what it normally would look like. I'm just zoomed in to make it easier to read. Now, if we're searching for things, this is a little tricky because if you search for like, let's see, will it actually search by very first? Let's do first. Oh, that actually does work. It's like weird because it's wrapping. It's throwing me off. Okay, so if you're ever wanting to find something and you can't find it by a regular search, you can click filter and you can come down and you can filter by any type you want. So you could do heading and it says it is an exact match. So if you type a letter, it's not going to find anything. If you type even like first, it's not going to find anything. You'd have to type the exact, the very first heading or product. Bang, bang. Was that what it was? Yeah. And then it'll find it. But what we can do is we can change that to matches. This is what I was talking about earlier. You can make it a loose match here and then you can change it to a match. So if you're a loose match here and then you can just do like first, boom, it'll find it. Just another way to search through your stuff. Okay, let's bring that data in and wrap this up here. So coming back here to our product page, all we really need to do now is pass the rest of the thing. So what we're going to expect is let's wrap this real quick here. Let's do a div. I wish you would do that. Okay. Oh, I don't have formatting. Bleh. Okay. So we have a div, we have an H1. Now we're going to want an H2 with props.subheading. And let's console log props while we're here, just so we can see it in the actual page. So we're not passing that though, but we are getting it because we're getting the entire entry. So what we could do is we could pass the entire entry. So we could pass the entire entry. So what we could do here is instead we could change this to, okay, well, what if we just spread product.fields? Okay, because that's entry.fields or whatever. So all the properties that are on fields, we could just spread that into this object, or we could just assign, you know, whatever we want to the fields object since it is an object that's fine too. But let's just do that for now. Now, when we go back to our browser and refresh, we get it. Okay. And if we inspect, look in the console, you'll see this object, go away, that also has the product ID. So we've just effectively spread all of the fields just to kind of clean up the data for ourselves and give us all these different things that we can access. We're not even using product ID, but you know, they're all there at that point. You can do this however you like, massage the data however you like into the format that you want. You could also put this on like a product key or something like that, you know, some extra stuff, but we'll just leave it like this to keep it simple. So that'll wrap this whole process up. You know, I hope that that was useful as a kind of quick and dirty, this is how you set up Contentful and Next.js to get a sort of working product. Like I mentioned, I'm going to have some videos in the near future where I'll show some additional features such as preview or dynamically generating slugs and all that good stuff. But I kind of wanted to just get you up and running so you can see, you know, it's actually pretty simple once you know the right places to look to get this whole thing working. It's quite elegant. So I truly hope that video was helpful. Please let me know if it wasn't, and I hope to see you in the next one.", "metadata": {"title": "Next.js + Contentful minimal setup from scratch", "url": "https://www.youtube.com/watch?v=MbEIGh5cWWI"}}, {"page_content": "Hello, and welcome to Swashbuckling with Code. I am Jimmy Cleveland. Today, I want to do something a little bit different. I've had something that I've been thinking about, and I just want to talk about it today. There's not going to be any code on screen, so if that's all that you're interested in, feel free to skip this one. So what I want to talk about today is something that I talk about, I guess, somewhat frequently with my team. It's something I'm really big about, is walking away from problems, and more specifically, knowing when to walk away from problems. Now, I'm not talking about walking away from your personal problems. I'm talking about coding problems or challenges, or really any challenges in life that you're really trying to critically think about. So to kind of give you just a quick example, you know, imagine that you're problem solving something in your code, and you have this bug, and you just can't quite figure it out. It's really just your nemesis at the moment. No matter what you try, you just can't seem to solve it, or process it, or anything. You know, it could be a bug, it could be that you just don't understand the code, and you're really trying to grasp it, anything like that. So imagine that scenario. What often happens is that you will sit there, I know I do, and focus on that problem, just kind of like waiting for it to solve itself, or just trying to figure out, okay, where's the next avenue that I need to look down to figure this out? And I'm just here to tell you that a lot of people take for granted and don't talk nearly enough about just walk away. Honestly, stand up, you know, stretch your legs out, get some water, get some air, I don't know if it's fresh air, but whatever air you can get your hands on, you know, walk outside if you can, take a walk, five minutes, really, just at a minimum, just try to take five minutes. And wow, how many times the problem will either be solved, or I will completely realize that I should have that I should have come at this from a different angle. The amount of times that that works out in my favor is always astonishing to me. You know, I'm the type of person that when I get deep into a problem, I don't want to walk away. But there are certain signals that you can learn to watch for in yourself. And I really think this is like a hallmark of a seasoned developer. It's something that I've developed a lot in the last year or two of my career that I wish I had started from the very beginning. It's one of my great, you know, regrets. You know, I don't really think of it as much as a regret, but it would have been a lot more efficient had I started that way, say it that way. Where there are these clues that you can look into that you'll notice kind of like tells within yourself. So one of them for me is making silly mistakes, especially syntax mistakes, things that I know that I know better. Once I have a couple of those, there's kind of a little bell that goes off in my mind. That's like, you need a break. So, you know, you have a syntax error and you try to run your code and it doesn't build or it has a runtime error or whatever. And then, you know, that's like, okay, whatever that happens, right? It happens to everyone all the time. But then you have another one right after it. And then especially if you have another one right after that, take a break. There's a good chance that you're just, you're getting a little mentally fatigued. And here's the thing. If you take that break, you're probably just going to feel a little bit better. It's only going to be a few minutes. You know, you're not going to forget the problem. It's fine. But one thing that is really just not talked about enough, in my opinion, I can't stress this enough, is background processing. Let your brain background process that problem. From my experience, the way that I kind of think about it is that there is a certain amount of effort that when I put into a problem, my brain essentially will say, whatever the background processing part of my brain will be like, okay, wow, I can see this is extremely important to you. So I will work on it. Fine. And then you just walk away. And the best thing you can do is not think about the code. Don't think about the problem. Think about anything else, you know, creative pursuits are great. Or what do you want to do on your weekend? Or just anything at all. Just kind of, you know, chill out. And so often, what will happen is that you'll either just have this awesome epiphany, that happens less often, but it does happen often enough for me to feel that it's a reward that's worth pursuing. But if you don't have that epiphany that just solves the problem immediately, you're probably going to have some sort of either idea about a different way to solve the problem, a different way to troubleshoot the problem, or a different avenue of attack, or something like that, you'll realize that you're kind of like, you know, wasting time the way that you're doing it, and that there's a better way to do it. This happens so often to me. So I really can't stress this enough. I think this is a vital skill, and you will save time, and you'll feel better. Whenever I can code for a large amount of a day, it typically falls very much in line with how often I take breaks, you know, how well hydrated I am, if I exercise that morning, all those things, you know, your mental health, your physical health, all play a factor in it. Don't just sit there and slog away at the computer all day. You'll feel worse, and you'll get less done. That's my experience. So it can be easy to just get lost in those problems and just want to keep solving it. It's the hardest when you're in the middle of it, and you just can't quite pinpoint what it is, and you're like, I'm so close, I know that this is going to work. But just trust me, just take a five-minute break, walk away from it, and you're not going to forget the problem. In fact, you're probably going to come back with better insights. Just try it, okay? Now, so how can you try that? How can you enforce that? It's pretty hard to notice those things in your mind right away. It's something that you should just try to be aware of, and you'll develop over time. But a great way to jumpstart that, in my opinion, is Pomodoro timers or any other timer that's like it. Pomodoro timer is essentially 25 minutes on, 5 minutes off. So you work for 25 minutes, take a 5-minute break. You come back, you work for 25 minutes. You do that cycle four times, and then you take a 25-minute break. This is fantastic for pair programming, in my experience, or mob programming or whatever, because it's a natural switch time. It keeps everyone more engaged. And I think everyone just does their work a lot better when they have these little intermittent breaks. My team loves it. I was pushing for it for a while. We don't do it often enough. In fact, that's one of the things that gets brought up a lot in retrospective, is that we need to do Pomodoros more. So that's really cool. And I like to hear that feedback. And you can definitely tell engagements better. Everyone who's on a call is less lethargic because they can just get up, take a break, get some fresh air if there is any, etc. So try it out. I think Pomodoros are really cool. And like I said, I'm not really strict about the four-on 25-minute break, although I would like to try that more. It just doesn't end up lining up with lunch super well for me because you have to be pretty disciplined about taking the breaks when you do and not get interruptions and all that. But one note that I have on it before I leave that topic, be very careful about stretching into your five-minute break. It's fantastic to have a timer that just automatically starts your five-minute because then you have to actively pause it, which, you know, it's better to be active about that than kind of letting it happen in the background. Because you will want to keep going. You'll be in the middle of something and you won't want to quite take a break just yet. And that's okay to an extent, but really more than like a minute-ish, you got to be real careful. You know, if you just need to really quickly wrap something up and see it run, okay, cool. But you got to set a limit for yourself because you'll turn that 25-minute tomato into a 45-minute very quickly. So you got to be careful with that. So I think that that's very important. I just wanted to put that note out there. Be careful with your five minutes. Try to take them right away. You'll be fine. Like, you'll be able to pick up where you left off and it's probably going to be for the best, you know. Like I said, if you're right about to, you know, run the code one time and see how it is or whatever, fine, cool. You know, you wing it. You're the boss. You can do that. That's just my word of advice. So take it how you will. So I think that's all I have today. I think that sums up my points pretty well. There's, obviously, I could talk on and on about this, but for the sake of some brevity, you know, let's call it here. And if you're interested in more thoughts or just general learnings or experience, anything like that, you know, please let me know in the comments, you know. Give me a like if you like this video. Give me a dislike if you don't. It's fine. You know, I just want to know what is going to be the most valuable for your time. What are you interested in learning? You know, is this a waste of your time? Do you only want to see the code tutorials? Or are you interested in this from time to time? Or you'd like to see more of it? Just let me know. But hopefully it was valuable to you if you sat through this. And I hope you have a fantastic day, week, weekend, whatever it ends up being before the next time I see you. So, take it easy.\n\nBye.", "metadata": {"title": "The Skill of Stepping Away from a Problem", "url": "https://www.youtube.com/watch?v=coabHZWlM_Q"}}, {"page_content": "Hey everyone, welcome to Swashbuckling with Code. I'm Jimmy Cleveland and we're going to go through generating out dynamic routes in Next.js using some Contentful data. If you haven't watched the previous video yet, I highly recommend going back to that one which I'll have in the description. It'll be part of this whole playlist that we're doing of walking through and building up from scratch a Next.js plus Contentful site. However, if you're just here to see how dynamic routes work in Next.js and you want to hear me talk through the differences between get server-side props and get static props and setting up your get static paths and all that good stuff, then I think you should be fine just starting at this video. If you're unfamiliar with what dynamic routes means in this context, the quick version is that you can imagine that we have a series of pages or a collection of data or records that we want to generate out a bunch of pages for, rather than creating each of those pages one by one, you know, requesting the data for that or whatever we're doing. We essentially want to react to however many records we have, we want to loop over that data, and we want to build one page per each. And that does mean also generating out the route based on some sort of ID or slug or something like that. So that's why it's called dynamic routing, and I think the rest will make more sense as we jump into the code. Okay, so we're picking up where we left off from the last video in the series. I have the playlist in the description as well. And I'm going to be on a new branch here, dynamic slug. So I'm exactly the commit we were before, but I've made a new branch called dynamic slug. And I'm going to be using this pattern for each of the videos in this series. I think it's just the easiest to have one branch all in the same repo, one branch per video. That way at the end, the main branch will have, you know, the end of the project or wherever I've kept it most up to date. And then you can go to each individual branch for the end of each of the videos to see, you know, if you want to compare your code to mine. So to start this off, I'll just start up our server with npm run dev here. And we're going to open this in our browser and just see where it was where we left off. So we never touched the homepage, we are going to go to slash product one, and make sure that our content still rendering and it is so this is still coming from Contentful. And then here, let me show you in the code. We're on this product one page. So we have hard coded this page right now, or just made this file, I should say. And you scroll down here, and we're just getting the entry for a very specific ID, right. So the next thing that we're going to want to make this a little more real world is we're going to have multiple entries. In this case, we're kind of simulating we're doing product reviews. So we're going to have multiple pages of product reviews. And we're going to want to generate them all out. Now we could go through and make each file for each one, you know, in a really, really classic HTML way. So I can make a product two page, I can make a product three page. But then I have all this duplicate code that I've figured out how to abstract. And it's just kind of silly, when I could just fetch all of those entries and dynamically generate them all out as pages. And that's what we're going to do. So it'll probably make the most sense to go over to Contentful and make a couple of those pages. First, let's do that. So here in Contentful, in my space, we the only type we have is this product review. And so I'm going to do add product review. And that's on the content and go back here. So you click content in your space to go create some new entries. And here, what we'll do is we will have a new product. And we'll just say this is product two. We'll keep with the same convention. You know what, maybe I'll actually make something just so you can kind of see sort of dynamic difference. We'll make like XF Z dash 331. You know, let's just make up some like product ID here. Then I'm gonna make a heading. And so this will be the fantastic second product or something. Subheading does not matter. We're just going to fill all the things in. So we'll publish this. And now we're ready to fetch this. Okay, we'll go back to content. And you'll notice that when I made that one and backed out, it made an untitled draft. So I'm going to go back into that. And I'm going to finish that off. And we'll just make this one, you know, ABC 123. I don't know why I wouldn't just do that in the first place. Product number three. Okay. And woof. I don't know why. So now coming back to content, we have these three pieces. And you can see what's kind of cool is we can sort this by updated in case we ever want to see like, you know, if we or anyone else came in and updated this, what was the last change that happened? I do this a lot. I just pointing it out because I do this a lot when other people are editing a bunch of content and something for whatever reason, unfortunately, has an error that, you know, breaks the build, or you got something weird happening on the site, you can come in here and kind of see who did the most recent changes and go look at those articles and see if anything stands out. Now, I know these IDs are going to be hard for me to remember to test things out. So I might copy those over in a moment. But let's actually get some things working here. So we have these three product review pages. And we want to say, okay, I want you to go fetch those and build them out for me. And what I'm going to do, which might be a little weird at first, but I hope that it will kind of make the whole picture a little more clear by doing it this way, is I'm going to switch our get static props to get server side props. Okay, I'm going to explain why. So get server side props, just like that. You can also find that in the next js docs if you want. Now, as far as this is concerned, nothing should really change. Like if we go back to our website real quick, and reload the page it from our perspective, nothing's really different. Okay, the the thing that is happening different is that we are essentially generating this content out at request time, it's not going through and building up the pages out at build time ahead of time, and then you know, having them as a bunch of flat or static files, as they're commonly called. So we're behaving a lot more kind of like a traditional server here, except we are, you know, still generating out all of this, what normally would have been react client side code before, you know, into the document before we give it to the user. So we're doing this on request here. And the reason I'm doing this is because it's a little easier to set this up for multiple pages for a particular slug. And let me show you that. So if I rename this, and I promise I'll explain this and the when we transition back to get static props and why we're doing it and show some examples. So we can change the name of this, we had it as product one, right, we can change the name of this to brackets slug, this is a next JS convention. Now it does not have to be slug, I'll show that in a sec. So we will name that whatever we want. But it's a really common convention to name a slug. And if you're not familiar slugs, pretty much a common term for sort of like an ID, something that you throw on on the end of a URL. So for doing you know, whatever page we're on slash whatever. So in this case, this is saying any routes that since I have it in the root of pages, any routes after just the homepage route slash whatever, are going to resolve to this template. So let's test that out and see if that's actually working. So we go here and we refresh. And you'll notice that we do get that right product one, but we could actually type whatever we want here, we can type ABC, see it wasn't even one of the ones that I had, it's always going to return the same thing right now. So if I go back to product one, and then I go back to my code here, what I can do is there is an object here called context, you can name it whatever you want, of course, and we're gonna log that. Whoops, context. Probably should just put that in an object. But then what we'll do is we will hit our server. And we'll look at the actual server output. And you'll see that we get this", "metadata": {"title": "Next.js + Contentful Dynamic Routes", "url": "https://www.youtube.com/watch?v=vOsx9NuQe6Q"}}, {"page_content": "server output. And you'll see that we get this big dump, right? So this first object has a ton of stuff on it. So if we go to here, it's even further up, sorry, lots and lots of data. And this is like a, this would probably be familiar to you if you've done some Express stuff before with the request object and all that stuff coming in. So you can see it's context, all this stuff comes in. And some of this is really, really useful. And this allows you to, you know, respond to let's say, like the user agent, if they're using Firefox, or whatever they're using, if you want to base it on like the type of device they're using and their location, all that type of stuff. We're gonna keep it pretty simple here. What we're particularly looking for is going to be down here, I think at the bottom. And you'll notice there's this params property. That's what we're interested in. And it is very similar to query, but query will have additional stuff like what's on the query string. Whenever we pass, you know, slash whatever, and it's going to come in in our params object as whatever we named that little file. So let's go back to our code. And we can just simply log out context.params.slug. Okay. In fact, I'll just log out params from this point on just to show up for there. And so all we need to do now is figure out, okay, so whatever the user typed in, that's what we want to go and request, right, like that product ID. And it will just to show you if I rename this real quick, I'll name this to, you know, I'll rename this to, you know, I'll rename this to, I don't know, we used wolf earlier, so let's just use wolf. And then we'll hit our page again, go to our server. And then you'll see that params object here is going to be wolf. Okay. So we do have to match it, I'm going to change it back to slug. We do have to match it to whatever we named this file. And since I'm editing this currently, it would probably make a lot more sense if this file resided in a like slash product slash whatever the ID is, right. So we'll create a new folder, we'll call that product, new product or plural products, whatever format you want, move that file into there. And now what's going to happen is when I refresh this, this is no longer a valid route, because I need to type in product slash and then whatever we want. So product slash one or product slash product one, you know, whatever the whatever the key is. Now, a quick note, I was going to leave this to a future video, and I'll cover it a little bit more later. But just in case, just so people don't get confused, you might see a format sometimes in the docs that's like dot dot dot slug, right, like brackets, or even double brackets. Okay, so what that is, essentially, let me give you an example, just so you know, is that if the limitation here is that if you do product one, that works fine. But if you did product one slash two or slash whatever, that doesn't work. So our bracket slug is only catching this first param here. But we would do the dot dot dot if we wanted to catch multiple paths. And there's a lot of different reasons why you might want to do that I'm not going to get into right now, like maybe you're doing some sort of crud or whatever model where you know you want to have you're fetching the thing for an ID, but you have like an edit view or a show details view, you know, the read view. And there's other reasons as well, you can kind of come up with all sorts of different paradigms that are pretty common for that. But a really common simple format is just to use this bracket slug. So we're going to keep it simple like that for now. Okay, so now what's really left to do is to go get that content by the ID that we're requesting, right before we switch it back over to get static props. And I'll show you how to do that. So we go back into our browser, I have these docs up earlier, and these will be in the description if you want to go find them. But there is these there are these using JS CDA SDK. So using the JavaScript SDK for Contentful docs, and we had previously used this get entry to get a single entry. So if you scroll down a little bit, there's some more about get entries. And they do talk a little bit about it, how you would do pagination, there's some useful things here. But in particular, probably the close, let's find the closest that we want, we want to get something by content type, this is a really common way to use this and how I usually do it. So I'm going to copy this part, I don't need that that after part, come back into here. And for this client dot get entry, instead, we're going to do you know, I actually got rid of all of that client dot get and trees. And that takes an object of options here. And you can do by product type. So how do we know our product type? Well, if we go back to Contentful, and we go to our content model, you can click this. And you can see right here, this is the content type ID. And that's in particular what we want. So we'll just paste that here. It's a string. And now we're going to get entries for that. So let's look what that returns with that, you know, this is going to break. But for now, let's just do product. And this is actually products in this case, but let's do that. We'll call it product. I'll just leave that for now. And we should still even though it breaks, we should still get a response here. So we refresh this, we should get an error, I think, oh, actually, we just get nothing. Let's go back to our server and see what we got here. Okay, so we did for the context, we got the slug of one, we just went and got all products, we didn't look up that particular one. And you'll see we get some data back, it says we got three entries, and we do have three total. So it did get all entries. The skip, that's just when you're doing pagination, it's limited to 100 at a time. And then you can see items. So items is usually where it comes back on. And so that's how we would get all of those things. So of course, like we could go and get all the entries. And then we could just, you know, search through them for the ID that we're looking for. But a better way to do this is actually to to do this, you can throw another property on here, it's a string. And that's fields and dot, and then whatever the field is, in this case, it's product ID. And then that's going to be equal to let's just set it to product one for now, just to make sure that we get something. And let's see what we get. So we come back here, and we'll refresh. And this is still not going to work, because I haven't got it out of that array yet. But here, we should see products, notice, we only got one here this time. And we have then there's that array. Okay, now really quick, how we would know that we were using product ID, well, you could go back to your your thing individually. And you could look at whatever you're trying to grab it by, in this case, we want it by this ID. And so you can enter, you can click settings for that. And it's right here, this field ID. And I have tried this, just so you know, to write this as an object instead of the string, and it doesn't work. So you do have to write it this way. So it's always fields. And then it's whatever your field is, this might seem a little weird to you. At first, it was a little weird to me that we're kind of getting entries instead of having a get entry method for a particular type of field. But that's just the way that there's works. I haven't found a way to do it with get entries. I've been looking at the signature. And it looks like it still just takes the product ID requires that and then whatever options you want. And I've seen it in some docs somewhere, I just couldn't locate it to link it to you, that this is a potential way to do it. One thing you could do as well, as you could look into their, I'll probably link this as well, their content delivery API, this is like the generic docs for their, their whole API, not just the JavaScript one. And the SDK that we're using is just a wrapper over their restful API. So you can come in here, it's really nice docs, they will see if we could, I'll do like fields dot, you can see this down here, they have these sort of examples, it doesn't quite give us exactly what we want. It tells us some common fields and stuff like that. I just couldn't find", "metadata": {"title": "Next.js + Contentful Dynamic Routes", "url": "https://www.youtube.com/watch?v=vOsx9NuQe6Q"}}, {"page_content": "fields and stuff like that. I just couldn't find the spot where I had found that before. But if you look up this, like, get single asset type, you can sort it by, you know, different, you know, select your platform for generic stuff, you can see all the parameters that you can pass. So you might want to just dig through here and kind of see, you know, what are some common things to pass to it. But this is the way that I do it. So you know, if you just want to follow along here, you can just stick to this format, you will still get an array back. But that's also the way they do it with GraphQL. But their API, you also still do a get all of the collection, and then you just put like a limit one, and, you know, filter by the ID and all that type of stuff. In fact, you'd probably want to throw limit one on here, I might move this up. Because just in case there's duplicates or whatever, you still only want one entry back, right? It should never be duplicated, because it's a unique field, but a unique field. But just to be sure. So now what we really want here is we get this product back. And what we're going to want to do is return. So we'd say, okay, well, I'll do product at zero, it's actually dot items, if you remember, at zero, and then dot fields. And this should still kind of work. It's a little dangerous way to do it. But let's try it. There we go. Okay, so it is working, we are, you know, hard requesting that one. But this is a different way to fetch that same one. If we go back into here, we can see that we do have our limit one here. And we have this items that we're pulling that off. And so items is going to have all the different types of that content type, I think you get it. Okay, well, let's actually change that, right, to be realistic here. So we go back to our code, let's take that context dot params and use that slug. So for here, for product one, we use context dot params dot slug. And of course, you could destruct this or whatever. I'm just leaving it here because I think it's a little more transparent when you're just barely learning it. But if you want to clean it up, go ahead. We'll kill that. And we'll still log out the product just to see. And then we'll go back here. And we'll refresh. And we'll see that we get an error, right. And this is because it doesn't actually exist. Let's make sure it works with the happy path first. So let's do product one. And it does work. Okay. And if we go to let's do one of our other types. So we had content and we had this ABC 123. Well, that's an easy one to remember. So let's just do that. ABC 123. Boom. And there you can see that one working. So this is working. But we noticed a flaw here. What happens when we go to request a slug that we don't have? Well, we have a problem when it comes back. Okay, so there's a number of ways we can handle this. But you know, it's a little unrealistic for us to, you know, limit what you know, we go and fetch, we're still going to end up doing this little request here, because you know, it's constantly updating and we don't really want to maintain, you know, a matched list where we have to keep track of every little ID that's in our contentful thing. You know, that's just a disaster waiting to happen. So, you know, an easier way to do it is, let's hit it and request it. And when it comes back, let's check if it's even there. Okay. So what we could do is we actually could cheat and just do these little optional chain operators, which are cool. You can even do this with an array if you didn't know. And we can just do this all the way here. And just this seems like this would fail because it would spread on undefined, but actually won't do anything. You can see that right here. So we're re refresh that. And you'll see that we just get this empty page, right? Now that's not ideal, but at very least, it's not breaking. And does the, you know, correct one work? Yes, it does. Hmm. So what could we do to, you know, give the user a better feedback loop? Well, we could do something like, you know, let's put an error on the object if we have one. And we could say, okay, well, if there's not product.items.length, and I happen to know that you just get an empty array back, by the way, if you don't, but you could check that yourself. You get an empty array back if it doesn't exist. So if that doesn't have a length, you can do an and and here. And then we'll just type some message like, let's actually interpolate it. And we'll say no item or no product with ID. And then we'll do context.params.slug. Okay, now I'm going to wrap this here, just to make it a little easier to read. And then, of course, we need to put a comma here. All right. And so now what's going to happen is this going to come back false. If we, you know, did have a item come back, because it'll check the length. And otherwise, it'll come back with the string. And so what that will allow us to do is we could just check our props here. And we could do, you know, something simple like if props.error. Okay, we'll return just a simple thing here, we'll do an h1. And we'll say an error occurred. And then h2. And then we'll actually print out the error. Okay. So if we get an error, let's print them something some different render. And otherwise, we'll just continue on. You could, you know, clean this up and abstract it however you want. And it is a pretty simple primitive way to do it. I'm just giving you kind of an example. So we could refresh this, this will still work. If you type another thing, it'll be like an error occurred, no product with ID ABC 123. If we go back to our terminal, we'll see that when we got back products, we'll see that here's this items with an empty array. And that's what we were checking against. Okay, so that's just a really simple quick way to have a fallback while using server side rendering. And when the user is requesting something that doesn't quite exist. Of course, there are a multitude of ways that you could handle that. But I'll leave that up to you and the concerns of your app. So now what we've been building up toward is we want to use get static props, because we actually want to render this ahead of time. Okay. So why I went through all this, you'll see right now, when I save this, I just flip it over to get static props. And I go back and I'm going to make a request here, we're going to get an error that says get static pass is required for dynamic SSG pages get static pass, that's a new one. So when we're static generating pages, and saying it's missing for this, you know, path that we made, and they give us some docs here to check, right. So we can go over to the docs, and they will kind of clue us into here, what our particular issue is, but I'm just going to walk you through it. So what it is, is I did the get server side props first, because you can see that, when we are doing it server side, we're doing it on request, we can essentially respond to any of these IDs, we can say anything slash product, whatever the user types in whatever link they clicked, or whatever, however they got here, we want to go and request that particular ID. But how do we do that ahead of time? If we don't have anyone to go in and type those numbers or, you know, any requests coming in, how do we say, well, you need to build out all these pages, it has no way of knowing that, right? It doesn't know what all our product ideas are, or how many we have or anything. So what we need is this get static pass. This is kind of the mental model that helped me kind of figure this out why it was needed. So I hope that that explanation makes some sense to you. So what we're doing is we're now going to make a function export async function in the same file called get static paths. So you need this whenever you use get static props with dynamic generation, we didn't need it before, because we were just rendering out one thing. And next is smart enough to realize that and give us a nice error. So you can think of get static passes, the thing that runs when our build starts, it's going to go and for each of these paths that we give it, it's going to run this get static props on it. So what it expects here is we're going to return an object, and it's going to have paths on it as a key.", "metadata": {"title": "Next.js + Contentful Dynamic Routes", "url": "https://www.youtube.com/watch?v=vOsx9NuQe6Q"}}, {"page_content": "going to have paths on it as a key. And if you actually hover over this, you can see it does have, you know, it expects a promise back with paths of any I wish it showed more than that. But so we know that it wants paths back. And what it actually wants is an array of objects here. And that has a familiar signature of params. And in this case, whatever params we want to pass, so that we'll do like slug, and we can really pass any params we want here, it's the same as when we looked at the context params before. So we're kind of, you can think of it like we're simulating a user going through and passing in each of these things or clicking each of these links or whatever, making these requests. So for this first slug, let's do product one, okay. And then we just need to copy this. And we'll paste another. And I guess we'll just do we'll do all three here. This is ABC 123. And that it doesn't really matter the order per se. Yeah, we don't really care that as product 123 or whatever. I'm just hard coding it for now. Let me go get our other one, because I already forgot it. As I said, it would X F z 331. Okay. X, C 331. Okay, now that's almost it. So it's going to go through this array. And for each one of these, it's going to call our get static props with these params and that slug. And then you know, the rest of it's all wired up, it's going to go ahead and make that fetch per one, build out those pages ahead of time. Now there's one more thing that's required here. And you have to have a fallback key. And it would have given me an error if I tried to go ahead for that. They're really good about that. Now fallback, we're just going to do false. And I will briefly explain that after we see if this works or not. So we're gonna come back out here, and I'm gonna do npm run build just so you can kind of see it happen. Okay, so finished up, you let's check our logs first. So you can see that we got these products. Let's see. So for the first one, the error was false. We got this data. Same thing here. So we got the very first product. And then here, here's our other product. Cool. So we looks like we got each of them, the build was successful. And I wanted to point out this really nice little output that next JS gives you. So you have to see how they have this legend here. And it tells you that this static site generation, you know, using get static props is a filled in little dot. So you can see our 404 page is just regular static here. We have this sort of little lambda type thing, where it's slash API slash Hello, that's just our API route. And you can see that's a server one. Our homepage is also simple static. You know, that's just saying that we just wrote the code, we're not doing any sort of dynamic generation thing. But then here, everything under product and even prints out the ones that we made are all under this SSG using get set of props, right? So that's pretty cool. What if just to kind of see the output real quick, before I load it up? What if we were to just do get server? Oops. Side props, I moved my hand and messed me all up. I'm going to comment this out just in case. I don't know if I'll be mad or not. And we go and we rerun that build, we should see that we should have that little symbol here for Yep, product slug. See, it doesn't even bother printing them out, because it doesn't know ahead of time what they're going to be. You can request any ones you want. It's dynamic. So that'd be requesting it from the server, right? Okay, so let's go back one step, switch this back to get static props. And let's actually see it working. Now I could just start up my server here, but I'm going to do npm run and start up the one that I had built for production. I mean, let's come back to this. We'll refresh the page. If it's done, is it done? Oh, oops, that's the bad one. Okay, so here, we've got that. And then we've got one, or is it product one, right? Okay, and it's all working. So that was statically generating it. So there's the trade off, right? Like, you know, time to first bite and all that's going to be a little bit worse with server side rendering. But we have less build time to do it that way, because we're waiting for the user to request it. So it's a little bit slower for them. It kind of depends on your use case, if it's noticeable or not. At scale, it can be very noticeable, if you have a lot of things going on. But we're using static generation, which is basically what they recommend for Next.js if you don't have any need to do it on request. So we're going to incur sort of the penalty for the users, you know, we're going to take the blow for them. Our build is going to take a little bit longer, because we have to build those out ahead of time. But they're going to get a better experience overall. Those are the trade offs that you have to decide when you're choosing between these things. Now, you might have noticed that if I typed a bad product ID, I just got a 404. Okay. And so that's what we wanted. And that's what this fallback false does. And you have to choose this, it's required, these are the two things fallback and then pass. Okay. So the fallback, I said I was going to explain this. So what it is, is when you set this to true, it is setting a fallback and you'll you can kind of see it right here. If I were to refresh this, notice that we got that little error occurred thing. So that's how we could sort of still have this behavior where we static generate out the pages that we told it to. But if they want to request something that we haven't static generated out, it's still going to let it through, you can think of it that way, and do our normal flow and kind of render it as a server request, basically, it's still going to try to statically generate it for future use. But the reason that you would want to do fallback true, which you can look up in the docs if you want to read about it a little bit more. But the quick and dirty is, if you have a ton of things that you're rendering, that's a really common use case where you really don't want to wait for this gigantic, you know, multi 1000 page build, you might but a lot of the times you won't. And so what you can do is you can use fallback true to essentially say, Okay, well, I want to generate out the first like 100 pages, because those are important to me, or maybe I'll pick and choose which ones are really important and put them in my little array that I pass and get static paths. And then if the user ever requests one of these other ones, and they exist, like go ahead and and build that statically for future users, but don't build it in the initial build. This gets a little bit too much into the weeds, and I'm not going to go too much further. But there is also like incremental static regeneration, which is another cool feature the next 12 has, you don't really need to worry about these things. When you first start out, those are things that will give you some cool solutions to some problems you might have down the road. But when you're just starting out, you can be pretty solid. Just using fallback false is what I would recommend until you, you know, need fallback true. That's my personal preference. If you have a, you know, a small amount of pages starting out, start out with fallback false, you know, come back to it and read a little bit more about it and build up the complexity of your app when you actually need it. So for now, we're just going to say, hey, if you hit any, you know, product that we don't have, we're just going to 404 you. Okay, we're almost done with this one. There's just one last thing. We hard coded these. And like I said, we don't want to maintain this list of all these different slugs. So what we want to do is do this get entries request here. We're going to strip it down a little bit. And we'll say, you know, products in this case, because it's going to be products. And we're going to do still by content type, but we're not going to do a limit or anything. We want to get all of them. Then when we get products back, what we could do here, and I'll do it outside of the object. It's really common to do it in it into the return object, but I'll just do it here to make it sense. So I'll do const paths, let's call it equals. And so we're going to take this", "metadata": {"title": "Next.js + Contentful Dynamic Routes", "url": "https://www.youtube.com/watch?v=vOsx9NuQe6Q"}}, {"page_content": "it equals. And so we're going to take this products that comes back. And remember that products has items on it. You can look it up in the console if you want to check it out. And the items is an array. So we're going to map for that array. Okay. Now with that, we're going to say for each one of those, we have a product, we could call it an entry or whatever you want. It's really common to call it an entry since we did get entries, but I'm going to call it product. And for each product, I want to return an object. And what I'm doing is I'm making my object look like these objects so that I can simply return paths really simply. So I'm going to say for each product, I want you to return an object here. So we're going to have an array of objects that has params on it. And it has slug on it. And that slug is equal to product dot product ID. Okay, then we can replace paths here. And actually, we can just do comma. So you know, it'll be the the key is the same as the value. We can also do this inline down here, however you like, it's fine. And that's it. So now if we did this, right, let's actually, you know, run a build real quick. See it print them all out. Nope, no, I did something wrong. Let's log this out. Let's make sure that it's right. Let's do this on the fly here. So we'll say paths, paths. And we'll run build. Oh, slug is undefined. You know what, I know what I did wrong. It's product dot fields. Silly me. Product dot fields. I'm sorry about that. Cool. Okay, so that worked. So now we can, you know, just double check that we're good. We can have him run dev. And now we're requesting each of these things. And we don't have a product one, three, we have product one, though. And we could very simply to test this out. Let's go make another product. And we'll just do product for I know we're being silly here. The fourth product. We'll publish that. And then when we come back here to our dev server, actually, I didn't have to go to the code or anything like that. I should just be able to request product for now if we were statically building it, of course, we would have to build it out all over again. But with the dev server, it kind of live requests it. And there you go. So now you've seen how you can dynamically render these and you can do it server side or you can do with static generation for each product with whatever format that you want, whatever, you know, sort of path URL and slug ID, whatever you want to call it that you'd like. Now, I'll just give you a little hint of kind of the next thing that you normally might want to do. In this case, you're probably fine with product reviews just to have product and slug. But a lot of times you might have a, you know, slash product page, right? Without another slash and a URL slug, because that might be a sort of list of all of the articles or something like that. For that, all you need to do is get a new file and do index dot j s here, and then do your regular song and dance of next JS and put whatever you want there. So I'll leave that as a little challenge to you if you really want to do that. But you pretty much have all the code in here to point you in the right direction to pull that off. You just remember you don't need to do get static paths because it's just a single path. So you could just do it, get all entries, dump those out however you like. Just don't forget to use next link when you do it. You know, make sure that you look up in the docs next JS link. Make sure you look this guy up because you're going to still want that fast single page app behavior. But that's all I have for this video. Once again, I hope it has been useful, and I hope to see you in the next video where we continue to build on to this little project.", "metadata": {"title": "Next.js + Contentful Dynamic Routes", "url": "https://www.youtube.com/watch?v=vOsx9NuQe6Q"}}, {"page_content": "Hello and welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and we're going to go over just the JavaScript testing framework in this video and see what it has to offer. If you're not familiar with testing in JavaScript or unit testing in general, what it allows you to do is write some code that effectively runs whenever you run the script, and it tests each of the individual units of your code that you wish to test for reliability and consistent results. And if you're wondering when you would actually run those test scripts, well, it's actually up to you, but it's really common nowadays to run them in continuous integration setups or in your code pipelines or anything like that, where each time that you push up your code or you make a pull request or anything like that, some tests will automatically run, and it'll give you that extra bit of confidence that you didn't make any mistakes in those commits and those pushes or PRs, etc. You can also run them manually as you're doing things, and you can even do a really cool thing in Jest where you have a watch mode where it's watching your code for file changes and automatically running the test on those codes so you'll get instantaneous feedback of whether you've introduced an error or regression or anything like that. This is really useful for you to get some extra confidence from running the tests as you run your code, but I think it's even more useful for maintainers or people that are foreign to your code, people reviewing your code if you work at an organization or if you're doing open source, or even users of your code to know that your code runs as expected by just reviewing the tests or running the tests really quickly. It's kind of become a standard in a lot of companies that your repository or project must have a test suite. This even allows people that don't write the language of code that you write to run the tests and see that it does run as you expect it at least. It even doubles as an extra form of documentation, which I think is really cool, and I go over a little bit in the video where as you're writing these tests, it's showing to someone who wants to come in and look at your code. Rather than looking through that code and having to mentally load everything that's going on, they can start at looking at, well, how do you call this function and what do you typically pass to it and what does it typically return? So with those definitions out of the way, I'm going to show you setting up a project from scratch and adding Jest to it, which is pretty simple. And then we're going to add some tests step by step as my usual format, and I'll show you what it's like to pass a test and fail a test and making some new files so we can bring into test a little bit of that red-green refactor pattern for test-driven development. If you've ever heard of that, I'll just briefly touch on that. We'll also go over some of the nice little tools and functionality, such as the watch mode, testing regular expression patterns for files, matching, and stuff like that. We're going to go over coverage reports, which is a really, really cool feature of Jest that can show you how much of your code is actually covered by your tests. And it'll give you a nice little visual report of what things are missing, what branches of code that you're not actually checking in your test, which is awesome. And then I'm going to wrap it all up with snapshots, which is one of the things Jest is really known for. Love it or hate it, it's a hot topic. But it's actually really useful in my opinion, and I'll just show you some basic use case of it in a little bit more complex testing example. And I think that sums up the overview, so let's write some tests. [\u266a Music \u266a All right, so let's start out by making our project. And what we'll do, I've already made the directory here, but we'll do npm init dash y. And I'm just going to answer all the questions yes. And then I'm going to npm i for install Jest. And you can obviously use yarn if you prefer, doesn't really matter to me. Now that that's completed, we could make a script in our package.json, or we could just run npx Jest. Now when you run that, it's going to run all the tests once. And in this case, you can see it says no tests found. So what we'll do is we'll do npx Jest, and then you can pass a dash dash watch flag to it, which also isn't going to work for right now. And they tell you why, it's because without git or hg, please use the dash dash watch all command, which is nice of them to give you that hint. Now the reason for this is because the watch all command, just every single file change runs all of the tests. Whereas if you're, let's say you use git, it will watch the changes to each file and try to run the tests on only the files that have changed, just so you know. We're not going to add git for now, because I don't really need it for this demo. So we'll just continue to do watch all. So we'll say npx Jest dash dash watch all. All right, so you can see that it didn't find any tests still, of course. And we have all these little helpers, which I'll go into a few of them a little bit later. For now, let's actually make a test to satisfy that. So I'm going to make this woof.test.js. And you can see that it automatically picked it up, and it says your test suite must contain at least one test. So dialing back just a second, this woof.test.js, well, I named it woof because I'm actually going to have a function and a file called woof. And that's a really common convention for testing is to name the test the same as the file and or the function. And then there's a few different ways that you can structure your code. For now, we're going to keep it flat, but it's sometimes common to put all of your tests in a test folder. And it's sometimes common to put them right next to the files. It's really up to you and your workflow to decide what's best for you. I kind of like the merits of both, but I typically put them right next to my files. For now, we're going to keep this flat. And you'll notice that this.test, well, this is why it's picking up this file automatically without any configuration at all. Just is going to look for any files that are named.test. And here, I just want to show that there's also a common convention to call it spec.spec. And in some languages, that's how they commonly do it. But I usually see it.test, and that's what I stick to. So you can choose that as well, but you'll see that floating around just so you know. Okay, so now it says your test suite must contain at least one test. Well, they don't really help you out too much here, but you could read the docs really quickly to figure this out. So what you can do is you can type test here. Now, when we type test, this is actually a global that just is adding to the test runner. So when you're running the test suite, you have access to this and any of these like test files. So I'll just call that function, because I know that I need that. And you can see that it says invalid first argument, undefined, it must be a string. So that's pretty cool. So let's do that. We'll say our first test, we'll save that. And now it says missing second argument. It must be a callback function. You'll notice they also make this little hint to perhaps you want to use test.todo, which is really cool little helper that I'll show you in a little bit. So for now, let's give it a function. Now we can just pass it our standard function format, just like this, or you could use an arrow function. And I'm not going to do anything in that I'm just going to add the braces and save. And you can see that our test passes. So this is interesting, because we haven't actually done anything. But what it's just looking for is that the code runs successfully within this function. So you might wonder, okay, well, what causes the test to fail? Well, let me show you. You could just type some gibberish in here. And that's not real code. So it's going to fail, right? You could also type, let's see, you could actually throw an error here and say did not work. And now it'll actually give you that message. Our first test, you can see the X failed, did not work. And something interesting that I want to show you is this, unlike, you know, having all of your code execute in like one file, where if you end up running an error like that, the rest of your code will stop executing in JavaScript there. Well, I can actually make another test here. And in this test, I'm going to say failing above or something like that. There's really no rhyme or reason to what I'm doing. And you can see that that test still ran. And that's the thing that I wanted to point out is this is kind of an isolation here. Whenever whatever's running in here fails, it's still going to go on to run the rest of the test suite because you want to know like in total how many tests fail. You don't want it to just fail on the first one. So that's really cool. And I just wanted to show you that's basically how that works. So next what we want to do is actually make a file for this. So I'm going to remove this and I'm going to remove this for now. Save both of those, get our test passing. And then we'll make a file called woof.js here. And in this file, I'm going to make a function. I'll call it woof. And I'm actually going to make it take a string. And what I'll do is I'll just return the string and then I'm going to change it just so it actually has some sort of functionality. And I'm going to add a loud woof to the end of it. And I'm going to use module.exports here to export that woof. Now, of course, you can use ESM, Eclipse script modules if you have that set up. But we're just going to keep it with this module exports, js format. So let's actually import that now. So I'm going to say const woof equals require. And then I'm going to go grab that package real quick. Woof. And now importing it works fine. And then here we'll actually run it. So I'm just going to call woof right here straight up. And I'm going to call it with a string ohero. Now, you can see it's still passing. So how do we know that it's actually running that code? Well, if we hop on over to woof.js, let's just throw a console login here. And then let's say the woof ran. And then we'll just put, like, the argument that it got here just to show that. And this is pretty neat. So you'll see over the left here there's this console.log the woof ran ohero. And that's what we got. All right. Well, that's pretty neat. And so you can see that it's actually running our code from the test suite and receiving our argument. Now, a quick little thing that I want to show you here is I'll close this down. Now, there are times when you're troubleshooting and you want to console log some stuff, especially when you get into mocks or you're just trying to figure out, like, how that all works. And it's really flooding up your test logs. Well, what you can do, just so that you know, is you can run, let's say we run this npx jest again, just to show that you're going to see that console log.", "metadata": {"title": "JavaScript Testing Basics with Jest", "url": "https://www.youtube.com/watch?v=__QEPUdnJS0"}}, {"page_content": "If we run jest dash dash silent, it actually won't print out any of the logs that it receives, which is pretty cool. So that's just a nice little flag to know in case you don't want to be adding and removing logs over and over again, just to hide that stuff and see the tests. So let's go back to our watch mode. Watch all here. So let's actually make this fail now from the actual code that runs. So I'm going to take out that log and I'm going to change my function. And let's say what I actually wanted to do is take the string that comes in and do a dot length. OK, and so now I'll have however many letters there are in my string. OK, and if we want to see that, we could do let's store the result for a moment. So result or whatever you want to name it. And then we'll just console.log right here. What are we getting back from that result? OK, you can say we get eight. Woof. So what I'll do next is I'll pass it nothing. And you can see that when we pass it nothing, we get a failure, and that's because we try to read dot length. So it says cannot read property length of undefined. You get your typical error printed out. All right, well, let's just make that pass. Now we just go over to our code and then let's do a condition here. And we'll say, you know, type of string that's passed in the argument is not equal. To a string. If that's not true, then we want to return. OK, and then now you can see we get back undefined, but our test does indeed pass. So right here, this is a pretty normal workflow for testing. And this is what can help you get a little bit more confidence from your code. And why testing, especially unit testing in this case, is so useful, because you get this immediate feedback from running your function and then trying it out in different ways. And every time you find a way in which it could fail, you can write a test for that and then you can make it pass afterward. And that is known as this red green refactor pattern, which you might hear sometimes, especially in test driven development. So that means that red is a fail. You want to write your test first with the idea of what you want to test. And so that's our wolf function. And we'd say that we expect it returns the number of wolves or something like that. So let's do that. Let's say this should return number of wolves or something, you know, name it, whatever makes sense to you for your functionality. This is obviously a silly example. But from there, we'll make it fail first by passing it no argument like we did. And then we go into here and then we rectify that. And then now we have a test to give people some confidence that that works. And then what's cool about that is if someone in the future is not even looking at the test files or anything like that, they come in and they change this for some reason. Maybe, you know, they change it to just look for was string passed in, but then maybe it's not. But then like something that an argument is passed in that doesn't have the dot length property. So they'll get a fail as soon as they run the test suite and they can know that they need to go back and fix that code. And so we get a little bit of extra assurance in an automated way that takes, you know, human error out of the picture. Now, this topic gets pretty deep. I might actually do a video covering all about unit tests and the why and the how and all that stuff, you know, not from an actual code perspective. But instead of derailing us, let's stick to, you know, just functionality for now. I just want to give you a quick little reason on, you know, why we're doing what we're doing. So going back to wolf.test, we can actually take it a step further here. I'm going to stop logging this for a moment. We can use the next type of jest functionality, which is an expect statement. So this will return what's known as an expectation object. And so what we can do is we can pass in the result there. You could also just run the code right there if you want to. So we could just call wolf like this. But I'm just going to do the result since we have it. And I like to store it in a variable because then I can, you know, quickly log it out or do other things with it. So that's just my preference. So when we expect result, that's not really going to do anything just yet that's useful for us. We need to add what is called a matcher after that. And then one of the most common matchers is to be OK. So when we run this to be here, what we want to say is, what do you expect to come back from this? Well, we know that from our previous log, we're going to get a wolf back. Right. So I'll just put that exact statement. Now we can see that our test failed because we didn't pass anything in. Right. So let's go back and pass in what was it? Oh, her role. And that gave us our path. Now, how do we know that that actually works? There's a lot of ways we could go about this. So you could just change the string. That's the first thing I do. And you'll see that it gives you this nice highlighter and it shows exactly what's different here. So maybe we got the number right, but for some reason we messed up the string and you'll see it's like, oh, expected received. Let's take a look at that real quick. So it tells you the name of the test that failed should return number of wolves and then the expect received to be expected. And it's trying to tell you that the green here is the good scenario. This is what you want. You think that you want eight WF to come back in this instance. And then received here is what you actually got. We have these kind of reversed in this, in this instance, but it's just for showing like how to make it fail. And so this, this is showing you here, okay, like you got something different and we're, we're kind of color coding it red. Sometimes this gets confusing in certain scenarios of why it's red and why it's green. So I always just kind of like default my brain back to, well, the expected is green. Like what we expect in our test should be green. So let's make that go back to passing. Okay. So now we have a passing test. We have a test that says, uh, here you go. You call this function and you pass it the string. And then I expect the result of that to be, and you can see how it kind of reads, uh, like a little bit like English here. And as this eight wolf as the argument. So that's an exact match there. Now, what's really cool about this is that this starts to show how testing itself can be used as a form of documentation. And I'm not saying that it should replace, you know, actual handwritten, uh, full explanation documentation, but it's actually really nice to come in and look at. Okay. You know, I've got this wolf.test file, so I'm new. Imagine we're new to this code base and we're trying to figure out how something works, or we've been working in it and someone added some new functionality. We're a maintainer. Well, I might look at this wolf.js and in this case, it's really easy to read, right? No big deal. But if it's this big, long file, it will take me a while to mentally parse that. But if I go into the tests, not only can I run the tests and be like, does this code even run first of all, which you should do, um, you know, run as they expect. The user who wrote it is like, I expect it to work in these situations and they write the test for that. But you can also come in here and read this statement and go, okay. So it looks like wolf is supposed to return a number of wolves and, uh, then we expect to be, oh, okay. So this is how you use it. Basically, you're saying, oh, you just, you get to see it in action. It's called. So you get a little example here and then you get to see what you, what the result is. And so that's a really nice way to kind of be introduced into a code base, uh, to see all the code and how they intend it to be run. So we have this statement and to re iterate over the terminology here, uh, this is called an expectation object that's returned from this. And this is called a matcher by just documentation. Now there are other forms of matchers as well. So let me show you, um, if you, you can run more tests in this one test, so we can expect result dot to be. And in this case, uh, let me show you the opposite. You can do a not in front of it. So you can say dot not in front of any of the matchers. As far as I know, I've never seen one that you couldn't do it in front of, and this will say, I, it's kind of how you say, I want the opposite. So I expect this not to be, now this is a dumb example, but you know, let's say bark and that works out right now. I could do a wolf just to show you. And it will fail. So the first statement actually passed because it did expect it to be, but the whole test fails if any of these expect statements fail. So in this case, let's say that, um, you know, we, we removed that. And the first thing that we wanted to test was, um, you know, we had an error one time where the number was printed out and we, we changed our code in the future that we didn't want the number printed out or for whatever reason. We might throw this in as kind of a cover for that to make sure that doesn't ever revert back to that functionality. Or we might want to just test the other values that we know might come up are not what is the result here. And so that's what the not is for in a lot of situations. There's other, other reasons to use it, but just to show you that. So there's also other managers here. So there is, uh, let's, let's wipe this whole thing out. I want to show you that there's a two equal, um, that sometimes people get confused with. And so you might wonder what's the difference between to be and to equal let's copy that and replace it. So now they say the same thing to be into equal. You see, they both pass. And that's what kind of trips people up. Understandably is that it's like, well, what's the point of this? Well, to equal is actually, uh, meant for objects and arrays for the documentation. And that has something to do with, uh, to be being more of a strict equality comparison, uh, or an exact equality comparison. Whereas to equal like objects and arrays, you typically have to handle them differently. Uh, you, you serialize them or something like that, uh, to do a comparison. So that's what two equals typically for. And let me show you that, uh, with a few examples.", "metadata": {"title": "JavaScript Testing Basics with Jest", "url": "https://www.youtube.com/watch?v=__QEPUdnJS0"}}, {"page_content": "While I show you that you can actually, uh, just write, you know, whatever you want in here, first of all. So let's just make an object. Okay. And this will be an interesting example. So we'll say, uh, we have this object and we'll do a is equal to one. And then we'll just do two properties. Okay. B is equal to two. Let's actually get rid of that sidebar real quick here, just so you can see the whole code. Okay. So, uh, now of course that's not going to work. So what I'm gonna do is I'm going to copy that whole thing. We'll put it in here. So now I have, uh, both of the same thing, uh, being compared here and you can see that it's passing them. And if I were to change anything in this, it's going to fail and we'll actually give you this nice little layout here where it shows you, you know, the properties and exactly the difference between them. So remember that the green is the expected. So our two equal here is what we expect. And then the red is what we actually got that was wrong in this case. So let's go back to that and let me show you if we were to do two B here, it will actually fail. Now this kind of threw me off a little bit. Um, since it says, uh, if it should pass with deep equality, replace two B with two strict equal, they don't give you just the simple, the answer that it should just be two equal. Uh, but I never used two strict equal for any sort of deep equality check, to be honest, because I always test my objects in smaller chunks or snapshots or something like that. But, you know, if you happen to know why, uh, that is the error that's thrown there, go ahead and throw a comment. Um, but I'm not sure. And I know that it's just supposed to be two equal, uh, per the docs. If you're just doing a simple comparison here, and this is also true with arrays. So we could make an array right here and it'll be the exact same thing. Let me show you another common matcher here real quick. So we can also say expect results. And if we want to get a little more generic, which I find to be really useful, and I use this quite often, we can use to match here. Now to match, we'll also take a string, but what we can pass it is a regular expression, which is what I usually use it for. And I'm typically going to make it a case insensitive here. But what we can do is we could just pass, you know, a woof or whatever. Now notice I'm leaving off the exclamation point here. And when I test this, it actually passes. Well, what if I do something like that? No, it's not because that's not the correct format, but we could leave off the eight as well. So what this is essentially doing is it's saying, you know, can we match any part of this here? And so what might be useful in this example is we might want to use, uh, the escape D for like digits here and say, uh, I just want to make sure there's a number in front of it. In front of it. Okay. And then it has the woof afterward. So let's say that we don't do that anymore. You can see we'll get a fail, uh, here. Oh, let's actually go back and, um, comment this one out for a moment. And then you can see expected pattern. It'll tell you that the pattern that it expected and then what you got back, it can't give you, um, you know, as much nice highlighting, cause there's a bunch of different variations that could match this. But just to show you that, uh, that, that is a really common way to get, uh, the general meaning of what your test is supposed to do is to use regular expression matches. And I usually use case insensitivity. It depends on, uh, you know, what your use cases, you don't have to do that. Of course. Okay. So cool. Now we've got, uh, to be, to match. Um, those are some quick ones that, uh, I would typically use in this situation. So quick note for you following along here. Let's say that, uh, you start writing the statement out and when you're doing this, you don't get what I'm getting here. This IntelliSense or helper, uh, text here that will auto, uh, complete what you're typing as you type it out or list out all of the possible matches and all that stuff. So I had this, uh, once and what I actually did was let me show you, I installed the, uh, at types slash jest package to get the TypeScript types for it. And that fixed it for me. And what's really interesting is even though I installed it just locally in one project, it, um, has seemed to carry over, uh, to some of my other projects. And I'm not sure why that is exactly. I'll just do that real quick, just so that you can see. Um, but you know, that, that worked for me and then that made auto completion just start working. So just so you know, now I'll give you one, one more quick matcher here, just so you can see a little bit different than just checking for equality here. You can also do stuff like, let's say we have an array here that our thing returns and it has an A, a B, a C, something boring. And then what we can do is we can say to contain, this is a really useful one, and you can just check for a single property in that. So it'll test that. So does this contain an X per se? No, it does not. Expected the value X, receive the array ABC. So it's really nice. And so here, this is a, another way where you can just check like partial, uh, you know, maybe you, you give it, uh, some sort of object or array, and then afterward you expect it to just return back something that at least has one of those things. So that's a way that you can just kind of test for just partial functionality or partial properties or something like that. Okay. So now at this point, let me show you a little bit more, uh, usual way to handle this. What we're going to do is we'll close this down. We're going to go to package JSON, and I'm going to add this test script. So that usually comes with one, so you can just update this and you just simply need to run Jest. And so that will make it to where, uh, instead of running NPX Jest or whatever, we can run NPM run test, and then it will run our test. Pretty cool. Right? And what we can also do just as a shortcut, just so you know, is you can, if you're using NPM, you can do NPMT. I don't believe Yarn has that one, unfortunately, but you can just run Yarn test. So now what I'll do is I'll also get init just to show that. So now we've initialized this. And of course, this is mad because we have a ton of changes. So let's make a new file. We'll make a get ignore real quick and add node modules to that get ignore. So now we have get set up. Please go away. And when we now run NPMT, we can use the dash dash, a little argument here to append more arguments to our test script. So we can append more arguments to our NPM scripts and the dash dash watch. So that is going to be the same, you know, as if we were typing NPX Jest dash dash watch in this case. If you're using Yarn, you don't have to append that extra dash dash just so you know. So NPMT dash dash dash watch. And you could also make a script for this, but we'll just see if that works. And you can see that it now works. And what's cool about this, there's an extra little command here that you don't get with watch all. That's press A to run all tests. And I use this a lot. That's why I'm mentioning it. Because sometimes I feel like Git can kind of or it can make some mistakes when it's reading Git and not read all the files that it should be or not test all the files that it should be. And so I'll press A just to like give myself a sanity check. Like, hey, run all the tests again. I want to make sure that they all work. Now that you have the gist of Jest, let's go over coverage because that is really cool and something that I love a lot about Jest. So if you do NPMT, just for your, you know, Jest command, and then you can pass it a dash dash coverage flag. And what that will do, this is kind of an ugly format when it's too small. Let's make that more normal here. Rerun that just so you can see it. Okay, so now you have this table laid out. That's just because my zoom is high for recording. Typically that won't be an issue for you. So when we run this, you can see that it gives us this overall coverage of all of our test files. And what that means is it runs each of the files and notice it'll tell you the file itself, not the test, the wolf.js file where the function comes from. And it's going to say 75% of statements are tested, 50% of branches, which is like conditional logic, you know, if statements and ternaries and such like that, and then 100% of functions. So we've tested, there's only one function and we've tested that one. So it's 100%. And then how many lines of code? Well, that ends up being the same as statements in this case. And then it tells you the uncovered lines, which is really cool. Now, this is something that's really exciting to me. And it really leveled me up when I figured out how to utilize this. So let me show you. If you go here now, there will be a coverage folder in your directory that's been created. You could open that. You can go to this lcoverport and what you're looking for is the index.html here. Now I'm going to do reveal and explore just to open it. However you want to get to it on your file system, that's fine. So I'll open this up and you'll see here, let me bump that up for you real quick. That should be good. So you see here that it's kind of the same information, but it's done it in this nice little graphical way for us. It gives us this bar of this file to show all of the same stats that we saw before, a little bit extra actually. So when we click this, it will take us to the code for that file. And it's really nice. It'll tell you how many times each of these lines were run. And in this case, this red line is saying this is the part that is uncovered. If we hover over this eye, it's really small, unfortunately, but it says if path not taken. And so this is using Istanbul under the hood, if you're familiar with that at all. It's really cool. And what it's telling you is that this condition right here, you're not testing this. You are testing that your function runs and you've tested all this other stuff, the module.exports, it's just because you imported it. But this was never tested. You remember that we wrote a test before where we passed it nothing and that worked. So let's try that out again. So now let's say...", "metadata": {"title": "JavaScript Testing Basics with Jest", "url": "https://www.youtube.com/watch?v=__QEPUdnJS0"}}, {"page_content": "We're going to write a new test and here we'll say, should return, and I'm actually going to make it do null. So we get something here, but I'll set that up first. Should return null when given, when not given a string. So we'll do a function this time. I'll just do an arrow function just to mix it up a little bit. So we'll do the same thing. We'll say const result, because I want to store it here, equals. Woof, calling it, and then we're going to do... Oh, we're calling it with nothing. That's right. And let's just do that. It's not even write an expect statement right now. So we can go back over to our terminal. We can run our coverage command again. And you'll see, you can just see from here that it passes. So you don't have to open it. But if you want a little bit of extra information, let's go back to here. This is all updated now. You can just refresh once you've opened it once. It's really neat. I kind of wish I had a sort of server or an auto open. I tried to look that up, but I couldn't find anything like that. If anyone knows of anything that allows it to do that, that'd be pretty sweet. You can append like an open command, but it's not universal across operating systems, unfortunately. So I didn't go down that route. You might write your own. But I wish there was a more standard way to do that. Anyways, rant aside, now we can see that all of our code, it's not highlighted red. We don't have any notifications or anything like that. And it shows that this has been run one time. And this is see how this has been bumped up to two, because we've hit this actual statement twice now because we have two different tests. It's pretty cool, huh? So now we can move back to our code and then do our test as usual. So we probably want to do in this case, expect the result and then to be null. This is one that you'll commonly do and not for like not to be null because you want to make sure that it doesn't or whatever. And in this case, that's what I'm going to do, because I'm going to show that it will fail right now. So we can use coverage to test that. Notice you'll still get the failures when you run coverage. Now, why would you run coverage all the time? It actually takes a lot longer. I think the documentation says that it can increase it twofold for how long it takes because it has to build all the coverage stuff. And so you wouldn't want to run this all the time. You probably run this in your continuous integration pipeline if you're doing that. That's what I do. And it's really nice for just doing some coverage text real quick. But just so you know, you could do that or you can just do MPMT like you normally would. And you'll see that this test is failing. So I just want to show that that is the coverage report also will print out failed tests and that the whole thing will return a failure code. So here you can see it expected it to be null when not given a string and it received undefined. OK, so let's fix that real quick. Go back over here and we'll just do this null. And let's say, yeah, that's that's actually what I wanted for whatever reason. I don't want it to just be whatever I want to specifically be null. Test that. Boom. We're passing again. And just to make sure that's our coverage. Awesome. So now we have that covered. Now, because this comes up so much, I'm going to cover this here, though it can get pretty deep, so I'm only going to briefly dive into it. I want to show that in a lot of situations, you actually would just want to throw here in your code. Let's say that's what you want. And you just want to say must be a string. You know, you probably want to write a better message than that. But in that case, let's go back to here or run T. And let me do the side by side again. And then let's start our watcher back up. And if you're doing this a lot, you might want to make a a little script for that. Just a reminder. OK, so now we get the error printed out. And I want to show how you do this, because it's a little bit different than the normal expectation object matcher paradigm here. So this time we don't want to be null. What we can actually do for this, I'll just do it all in one. We can say expect. And then you want to wrap this in a function and call. It's a little bit weird. And then now we can say to throw. And you could check for a specific error as well. I'm just showing that that passes right now. But you could actually say to throw. Well, did it throw a wolf? No, that shouldn't work. Right. Received message must be a string. So we could check that. Can we just pass? Let's try a lowercase one just to make sure. Nope. Must. There you go. So you can see that you don't actually have to put the whole error. You might just want maybe you wanted like something printed out, an ID or part of a message or something like that. You just want to be like, OK, it should throw roughly this error. Essentially, you can play around with that. Now, coming back to this, this is a little bit weird. You have to wrap this in a function here. And the reason for that is that it needs to capture it inside that function. Otherwise, you remember how we when we did just a straight up throw error here before? Well, that's what's going to happen. It's going to throw that error and it's going to fail the test. And so you can think of this as putting it inside of function here. We'll allow this expect to capture this, and then you can just check whether that threw inside there. And then we'll come back here and just, you know, you could do your coverage again and everything's going to be that is very unfortunate that that's so hard to read. OK, so now you can see our statements are only 80 here. And so let's go back. To this refresh and you'll see now we have this return null because we didn't we can't return anything when we throw an error. So this is pretty cool, just kind of showing you that you might leave some dead code here that isn't tested for. And so it'll catch more than just errors. It'll catch kind of just little mistakes and stuff like that. Not necessarily things that just, you know, fail when you throw an error. When you run it. So let's quickly go over, get rid of that, and then we'll be good to go. Now, I don't run coverage all the time. This is typically something that you run in your continuous integration suite or, you know, every so often when you push up or something like that, it's just a good general check to do, especially when you're writing a bunch of tests. Now, there's because there is some really cool stuff that you can do there. I'll probably do a whole video on coverage in general, because there's a lot to cover there. So let's move on, because there is some other cool stuff that we want to get to now. OK, so back to running our test suite here. Let's say that we know that we want to write another test, but we don't have the time right now. This is a really neat thing that we can do. We can write test and then dot to do. And with that, we could say maybe we are going to test for should not allow numbers to be passed or something like that. You know, whatever that ends up being that you think about. And you'll get this. It'll it'll pass everything like normal, but you'll get this little. It's supposed to be a pencil, I think. This should to do should not allow numbers to be passed. And that is really, really neat. This is a little bit better to me personally than writing comments, saying write a test for this or write a test for that, because it does actually get print out, printed out in your test suite when it runs. And you can see it actually right here in this nice little format. I think that's just a cool little functionality that they added. OK, so what else can you do here? Just give you a couple of extras, a little fun ones. Let's say that we we ran wolf like this and we know that it fails our test. And currently we're dealing with this thing where we've got maybe, you know, five or six or so tests in this file. And we don't want to run this test for the time being, but it's really long. We don't want to comment it out for whatever reason. You can really quickly just write dot skip here and you'll see that it does that little circle around it and shows that this is skipped and reports that it was skipped just so that someone doesn't accidentally leave that when someone tested in the future. That's a really nice little quick way to skip a test. What you can also do is let's say that you had multiple failing. OK, so we have two of these. I know I don't really need to do this, but, you know, you've got a bunch of tests that are failing and skipping it isn't enough. You're just trying to get to a passing state. And maybe you're trying to test the functionality of just one test. Well, let me show you. Let's say you've got that. You can do dot only here on the end of this one. And it'll only run that test. See, I just automatically added skip to every other one. And so that's that's really useful. Just so you know, this only does it per file. So it's it's going to do that for here. But if we had other tests for different files and stuff like that, those are going to be run. Well, let's show an example of that real quick. So I'm going to really quickly make a mu dot JS. And then what I'll do, actually, let me show you this. This is interesting. So I will make a mu dot test dot JS. And then in that, I'm going to make it. You shouldn't mix and match these normally. I'm just showing that you can. So I'll make it does the mu. And then that takes a function, et cetera, et cetera. Et cetera, et cetera. OK. So you'll see that it automatically pick that file up and run that test. Now, let's do this really quickly. I have a reason for what I'm doing here. Bear with me. I'm going to throw an error. OK, whatever. I don't care. That's going to throw that error. And I want to show that if we were trying to get around that error in our wolf tests here, let me do this. We're trying to throw an error to get around that that test. And I only want to do test only. Well, you can see that I left that there and it's not working. It's still.", "metadata": {"title": "JavaScript Testing Basics with Jest", "url": "https://www.youtube.com/watch?v=__QEPUdnJS0"}}, {"page_content": "Still failing and still printing out only the failed one, because by default, just is going to put emphasis on what's failing. That kind of sucks. OK, so what we could do here. As we can use some watch usage, we're finally getting to this. We press W to show it and then you can press A to run all the tests again, etc, etc. But now we can do the filter. Let's see right here. Press P to filter by file name regex or you can press T to filter by file name regex. You can also press W to filter by a test name. So in this case, let's say we want to do a test. So I'm going to do a test and then we have this test that shows should return the number of wolves. And it's actually the only one that has wolves in it. So maybe let's do that. Press wolves, enter. And look at that. So now it doesn't show those failing tests. But if you look at this right here, you'll see that it's checking for this this regular expression. Whoops. And that's your pattern. Now you can do the same thing with a file. You could you could press C to clear the filters. You'll see it starts failing again. And then you can also come back here and then let's say, well, I don't really care because I have dot only. So what I want to do is I just want to press P to check for files and then the file itself. Well, that is the wolf file. And there you go. Now you get all of the tests in that file and it'll stop failing on your mute.js there. This is really, really handy. Now, the reason I made that extra file was because I want to show you and enlarge again. That's annoying. When I do coverage, coverage. That notice that the mu is not in here. OK, it's only checking Wolf dot JS currently. And the reason why it only has this lower coverage is because we are only testing that one test. We've skipped all the other tests that actually would make this coverage complete. Let me let me show that again. So let's get rid of that just real quick, just so you can see. And we'll run coverage again. And there you go. So our Wolf's great, but we're not even tracking mu. And that's kind of interesting because it does fail. Where is that here? It is failing this test here, interestingly. So why that is, is because we aren't ever importing it. So by default, the coverage report is only going to show. Well, we don't even have anything in this file, right? So let's let's just say const mu equals some string. You know, this is pointless, of course. Module dot exports. Mu. Show that again. You could see the only Wolf is there. And if we go over to here, we go back. We'll only see that one file. And then now we'll say const mu equals require and then dot slash mu. Now, as soon as we import that, let's see if it does anything. Look at that. It automatically popped up and said that it's 100 percent covered because it's just a simple string that was imported. And so that's what it does. Now, if we are really quickly to change it to a function instead. So let's say that it's a function instead that returns that. We'll run this report again. We'll see that it's not covered now. Zero functions because we never called it. OK, so that's that's the gist of how that works. When you are without any configuration, that's that's important because there is a just dot config that you can set up for this. It's going to only run the coverage report on the things that you import into your tests and actually have. But you can set it up to check for, let's say, the whole source directory. You can set specific ones, folders not to look into and to look into. And I'll probably go over that in the coverage video that I'm planning on doing. But it's a little bit much to get into right now. But just know that that's the case. So you could you do a really cool thing where, you know, you check that all of the JavaScript files in your source are covered in some way in your tests if you want to. And a common question that comes up there that I'll answer right here quickly and then we'll move on is how much coverage should you have? Because you might look at these numbers and be like, well, what does this even mean? You know, what should it be? You might not know. There's no hard and fast rule for that. You will typically see in my experience with other languages trying to aim for like an 80 percent threshold. That's just really generic and it varies by project. Just so you know, in just setups that I've seen, you typically want a little closer to 90 to 100 percent, depending on your project, because probably due to snapshots, another functionality that just gives you to cover things a little bit more easily. So just so that you know, you're trying to get it. It's a goal to get as high as you can. But there are diminishing returns and you typically don't go for 100 percent. I know some people strongly debate against that and it really depends on your project. But just so you know, it's just the more tests you have, you know, the more comfortable you can be that your code is working correctly. But don't overdo it to the point where you have to test every single little thing possible because there's sort of a diminishing return there. You can just do some reasonable default checks and be fine. Don't let that be a barrier to you getting into testing is what I'm trying to say. You can add those things as you go. And the best thing about starting with coverage now and adding tests as you go is that once you have like the basic building blocks, you can see as things are starting to get out of control and then you can use that as a mental reminder. So you could see that Mew or Woof ends up getting to like 30 statements covered after a certain amount of time. And that's a good flag for you to just be like, I should probably write some more tests because we're getting a little bit crazy here. It's kind of a hot topic. I'm going to leave it at that. All right, well, let's wrap this up by going over snapshots, which is a really cool functionality of Jest. To showcase snapshots, I'm going to reference some code that's a little bit more involved than I used in my git bisect video. And let me show you how this works real quick. When I run start, start command, all it does is it simply prints out this invoice. And you don't really need to know a lot about how the code works for this example. All it is is that it runs a series of different functions and then it ends up printing out the sort of invoice statement. This is actually taken from Martin Fowler's refactoring book. Now, I really should test all the individual functions there, but I'm going to show one of the cool things about snapshots is how you can really quickly get a test up and running that shows you the difference between outputs when you run tests. Let me show you that. So if we do expect and we do first invoice here, we can do to match snapshot. Now, when we run that, we'll run NPM T. And you can see it says one snapshot written. And if we take a look over here, there's this new snapshots directory. And if we look into it, it's pretty interesting is that we have the essentially the exact same output here printed out for this export. So how is that useful? Well, if we go over to the invoice printer, I want to show the mistake that I showed in that example. There was, you know, while we're refactoring our code, we moved into a new function. We accidentally left off that minus 30 and we didn't need. Now, I want to show this first is that, you know, if you're doing NPM start and you run this, especially if you're you're doing a lot of changes or it's been a long day or whatever, and you're kind of brain fatigued. It's very easy to miss the differences between these outputs between these outputs here. So you like as you're comparing them, 137 credits, oh, 47 credits. So this kind of 47 to 137 got messed up there, but the rest seems to be OK. Right. So come back to our test here. What if we just run NPM T again? Boom. Look at that. So it immediately. Went and checked our snapshot, it prints it out in a different formatted color now is pretty cool. And then it highlights the difference. So, you know, the rest of this was all the same. But here it automatically tested this for us based on the output. We didn't have to individually run each of those functions. Now, you got to be real careful here. I have to start with a disclaimer because this is a really hot topic in the testing community, especially JavaScript here with snapshots and all that. That snapshots are not where you should aim to be for all of your tests. And by that, I mean, don't use it to skip testing out individual functionality. It is nice to get a test up and running because what it essentially is telling you is that your test does run your code and does return a consistent output based on the previous one. But it doesn't necessarily know whether that output is intended or not. So in this case. We ran this test. You can see it said inspect your code changes to run NPM test dash dash you to update them. And you can also do this in watch mode. Let me show you. So when you're in this mode, there's a you command to update the failing tests. And so if you're not careful, you might come in here and you have like a lot of different dips or something like that. And you kind of get overwhelmed once you have a ton of snapshots going on. You'll just press you automatically and update it. Be like, oh, yeah, yeah, that was what I expected. And you won't read each individual line. It happens. Trust me. And that's bad because now you have a fail in your code that's not really testable. Let me show you. I just press you. And now it just thinks that that's the correct output.\n\nWe've just moved on and we think that we have passing tests. So I just want to show up throughout there that there's a little bit of a disclaimer that needs to be said that it can be a little bit dangerous to just, you know, go willy nilly on all snapshots. So this actually, to me, though, is a pretty cool example of how to start with just a real quick test snapshot, because as you could see from that one before, let's change it back. It immediately caught this regression is what that's called. You know, the code went back and performed performance or functionality or reliability in some way. So I want to update this to say that. Sorry. And then I'll fix this back. So let me show you this real quick. This is really neat for small code examples like that. This is perfect for two match inline snapshot. And I really love adding this to some tests. You can see that it made one snapshot obsolete. That's the one that was in this directory here before. So it wants us to press you to say, yes, that is obsolete. That's fine. And then that those snapshots go away now for that particular instance. But now it's printed out here live. Isn't that crazy? So it takes the result and it prints it out as a string and automatically updates this file. So if we were to go over here and we were to change this, I'll show you before I save. Notice it says you earned 47 credits down here. We're going to save that. Flip back on over here. And then notice it shows the difference here between the two. And then I press you to update and my code automatically updated in the actual test file itself to 137 credits. That's pretty crazy. So this is really nice to show like a quick documentation of what the output is when when it's very short or condensed and it's able to do that. You wouldn't want to do that for a gigantic CSS file or something like that. But for this instance, it's actually quite useful. So as you can see, snapshots are a really quick way to test whether the output of particular functions or anything like that is returning differently or whether you want to test that it's consistently outputting the same thing each time. And I already gave all the disclaimers that you should be careful with how you use those. But they're very nice addition to some tests. Some people really don't like them at all and don't think that they should be existent. I've actually found them to be really useful, in particular when I have a React component library and some CSS. It can be a flood when you change a component and you have a bunch of test snapshots that fail because you change one line of CSS. But if you're diligent about that, it's a nice thing that can catch things that are really difficult to test otherwise, especially when it's just like output CSS or JavaScript, which you really probably shouldn't be testing that too much anyways. But either way, let's say you were to change a button and another component uses that button and you forgot about that or that it added a different styling and it overrides that style. So it can catch some things like that. And I particularly found it to be useful, although other people have obviously very heated different opinions about that. And that's fine. I just want to show it to you so that you know that you can use it as long as you know, great power, great responsibility, all that good stuff. So that wraps up everything that I wanted to go over for this particular video, Jest Basics. You know, there's a lot more to it, of course, you can never get it all. But I think that that gives you a pretty good intro into what Jest offers, a little bit about unit testing and how you use it and some of the different matchers and expectation objects and formats and how you typically use it in an idiomatic way. But I do plan on making more Jest videos where I go a little bit more into configuration and some general setups and then use cases and all that type of stuff for more of the functionality of Jest if you're interested in that. So stay tuned for that. And of course, you can hit me up on Twitter if you have any individual requests about Jest or anything like that. But that'll conclude this video. I hope it was useful to you and thanks for watching.", "metadata": {"title": "JavaScript Testing Basics with Jest", "url": "https://www.youtube.com/watch?v=__QEPUdnJS0"}}, {"page_content": "Hello and welcome to Swashbuckling with Code. I'm Jimmy Cleveland. Today I want to talk about imposter syndrome and how to manage it. I say manage it because I don't know if it can ever really be defeated or eliminated. I'm sure some people might not feel it, but I think most of us do to some degree. And I feel it and I wanted to share some ways that I've found helpful in managing it. While it's not uncommon to find talk in the wild about imposter syndrome, I really don't think it's brought up nearly as much as it should be or held to as much import, at least in the coding community, and I would say let alone the rest of the world. So the first part of dealing with it for me is to accept that most people have it. Now you might commonly think that it is a thing that rookies or new people to a profession or just new jobs in general, maybe you've been working on that profession for a while, but you just have a new place that you work, that those are the type of people that have it. It's definitely not programming. First of all, it's very widespread and you can easily find people online admitting that they've had imposter syndrome at a job that they've worked at for over a decade. I also think that the internet has made it far worse probably because you really can't go online to, you know, let's say tech Twitter or Reddit or Hacker News or wherever that you go online without seeing people do amazing things every day in social media and as we've all, I hope, learned at this stage in the social media driven world, it's not a healthy way to compare yourself. Our brains love to group things together, especially the experiences of people. It's kind of like how you'll hear someone say, you know, Twitter hates this thing or Reddit is obsessed with that thing. You might think that that's pretty small to say this blanket statement, but I think that really echoes in the way that we think about the world. It's so anecdotal though, like these communities are large and it's ridiculous to assume that they all think the same way or feel the same way and when you especially know that you can go on Twitter any day and see people hashing it out and fighting, so they obviously don't have aligned views, but we really like to kind of aggregate those together. So we love grouping things, I would say because our brains are lazy and we'll see this thread that has, you know, 20 or even fewer people saying, I love XYZ framework or technology or tool or whatever and our brain just love to over exaggerate how many people that is. I've even found myself, you know, talking to my wife or a friend or someone and saying, oh yeah, everyone seems to love this new thing or whatever. When I stop and think about it, it's like, that was like 10 people that said that. Why did I say that? Or even worse, you'll learn about something new and you'll go to a colleague and you'll say, everyone's talking about this new thing when it's really just your small little circle and it was maybe a couple tweets or something like that you saw, you know, ended up being a handful of people. I'm not saying that that doesn't mean that a lot of people are talking about it, but we like to over exaggerate things. So I guess the point that I'm getting at here is that keep in mind that your circle of influence is relatively small compared to the vast world out there. And you have to be objective about that and navigating it to stay sane. People are going to show their best side online. Just because you see a bunch of people learning something or doing cool things, you know, that doesn't mean that everyone is doing it. And it also doesn't mean that those people are also experts at other things or knowledgeable about other things that you might know. It's easy to lump the skills of the world together to kind of this strange aggregate of a person or a prototype of a developer online. And that's just not realistic. So that leads me into my next point, which is you should recognize that all great developers have gaps. There was this fantastic blog post that I just highly respect Dan Abramoff for putting out. I think the rest of the world did too. It's called Things I Don't Know As of 2018. I'll put a link in the description where he's this prominent figure, if you don't know him, that gets his skills get over exaggerated quite a bit, which he himself admits and is kind of trying to fight against. I don't know if fight's the right word, but the point of the article was for him to come out and say that he's in a pretty good position where most people think that he knows a lot more stuff than he does. And he goes through and he writes all of the common things that a lot of people do know or that assume that he knows and the things that he just doesn't know at all or know anything about and reveals his weaknesses there. I really think the world can use a lot more of that. It's really hard to put yourself out there sometimes as a developer and reveal your weaknesses, especially to more junior developers. And especially when you're an influencer or a content creator or something like that, because you feel like it erodes the confidence in you. Now, I'm not some great developer, but I have been a senior and a lead and a mentor. So I have seen people assume that I know a lot more than I do. So I have some experience there. This is kind of the reason that I leave mistakes that I make in my coding during my videos, as long as they don't waste too much of the user's time that is because I think it's good to show that programming is just full of making mistakes every day. I would say no matter how good you are, but I'm sure that there's some developers that maybe don't make that many mistakes, but I think they're probably pretty rare. Sometimes you're making mistakes all day. But in tutorials, we hide that and it creates this illusion. I'm not saying that content creators are all nefariously hiding their mistakes. They honestly might be doing it to save time and give people what they came there for. But I know that if I'm reluctant to show my mistakes to the world, so are others. And something that's kind of interesting is that the more experienced you are, the better you are at talking to your strengths and avoiding your weaknesses. So all of that is to say, don't take the image or possibly illusion that experienced developers constantly put out there as the entire truth. We are making a lot of mistakes behind the scenes. We've made a lot to get to this point, and we're still making that many. And to me, that's kind of the fun of programming, to be honest. I'm sure there's plenty of other fields are like that, but it's a meter stick. It's a way to show that you're constantly growing. If you're not making mistakes, then you're not learning new things. And that's also to say on the last topic that we can also see that people are pretty quick to judge other people by their weaknesses. So I don't think it's unreasonable that we feel nervous about our weaknesses being exposed because we ourselves might jump the gun on judging someone by some mistakes they're making or some weaknesses they're showing when they're supposed to have a certain skill level. So just keep that in mind. So the next piece of advice I have is to go out of your way to expose your weaknesses. If you're really early in your career, this can be very beneficial for you. And I wish that I had done it. I know it can be very scary, but honestly, experienced developers will be the most forgiving during that time that you are earlier in your career, a junior, whatever title you want to call it. And it's super valuable for you to lay all your cards on the table, and that will cause them to more thoroughly explain things to you. If they don't, then you might be in the wrong place. The worst thing you can do is sit there and nod your head along and pretend like you know what they're talking about. I'm sure that you've done it. I've done it. But it's terrible. Please stop doing it. Because eventually, they're going to see that you don't actually get what they're talking about. And that seems like you're just lying. Most people I have found personally appreciate working with people who are honest about their faults and areas that they lack experience. It makes them respect you more. So I really think you should just take the risk. Just put all your cards on the table and ask questions and just drink up that experience while you can. Like I said, I really wish that I had. It could have propelled me much further in my career much faster. So the next thing that I want to cover is, I suppose, it's a Jimmy Cleveland original. I call it the Anxiety Stack. And it's an actual actionable item, actual actionable, that one's tough. It's something that you can actually act upon should you choose to. So here's how it works. You take all the things that you don't know that you keep hearing about online or at work or whatever that contribute to your imposter syndrome or the anxiety you're feeling. That's why I call it the Anxiety Stack. I like to use Asana for it, but you can use any sort of task manager where you can reorganize, you know, sort of to-dos up and down. That's fine. But let's take an example here. Let's say that you are newer to JavaScript and Closure is really tripping you up. You know that you should know it. You might need to know it for interviews, but you still don't really understand it or you're just not very familiar with it. So you'll put that on the list. And that doesn't mean that you have to get to it right now. You know, you leave it alone. You just put it on there for now. And then you'll hear another term. Let's say it's Jamstack or, you know, a framework that you haven't delved into or anything. It could be anything. So eventually what you're going to do with that stack is once a week is the amount that I like. Sometimes I do two a week. You're going to pop one of those off the stack. And what that means is that you're going to take the item that's the closest to the top, which that's why you want to be able to reorganize it because based on frequency, something might be a little more pressing in your mind or maybe you think it's easier to tackle. But you're going to pop that off the stack. And I like to take a Pomodoro timer. So 25 minutes.\n\nThat's worth because I'm big into Pomodoros. And I will just go and read about that thing. And that's it. And very often, that actually completely alleviates my sort of anxiety from hearing that word. And oh, no, I know I should know what that is, but I don't actually. And I'm kind of embarrassed. Obviously, 25 minutes isn't long enough to fully understand most things. For instance, let me give you a good example. So I mentioned closures in JavaScript. What about closure the language? OK, there was once a time where I kept hearing about closure, not cool it is. And I didn't know anything about it, but I felt like I kind of should know. So what I did was I just went through the docs and I built a really quick starter closure app and I loved it and it was really fun. And the thing is, I still haven't gone back to closure and I might someday. But that alone, you know, put that idea in my head of, OK, yeah, when someone says closure, I know what that is like. I don't know a bunch about it, but I get the gist about what it is. And I had a little bit of experience with it. So that's cool. And for me, that alleviates a lot of anxiety. I'm not saying it just all goes away, but it it helps you continually, you know, broaden your skills and your general knowledge. And a nice side effect about this is that you get exposure to the rest of the world that you might not normally get. So I kind of learned some interesting little paradigms from my exposure to closure, and it changes the way that I kind of think about the way that I wrote code every now and then. I have a little interesting idea about it's almost like a little a little seed is born in your mind. And the more exposure you can get to that, the broader your skill set is going to be in the better a big picture you're going to have. Now that I've explained all that, I do have to throw out a disclaimer that I don't think that you should just be hunting or all sorts of information and burn yourself out and get yourself all stressed. You know, maybe this the anxieties tech or whatever you like to call it isn't for you. It's just a tool for me that I it kind of turns the anxiety problem into somewhat of a little bit of a game. And if I keep at it, I always feel better on the other end. So. You do what you will with that information. Now, I actually find it even more helpful if right before you do your timer, if it's a Pomodoro or whatever, you note down somewhere on your little ticket what you knew before you jumped in and how you felt about the subject. Like, I don't know anything about this. I don't even I think it's in this general direction. I think it's a functional programming language. But outside of that, I really don't have a clue. For example, then you write down how you felt after you've completed it. This can kind of just help solidify what you've learned. It's actually particularly useful if you write a blog or something like that, or even if it's just for yourself. That kind of encapsulates what you went over and what you went through. It really helps solidify, you know, it's old homework trick. Right. And this leads me as a segue to my last point here, which keeps me going. Keeping a journal of some sort is highly effective for me at dealing with imposter syndrome in general. So this is kind of hard. I must admit, I'm not always on top of it, but it's really useful if you jot down things that you learn. You know, like I said before on the last item, if you're doing the anxiety stack thing, this can be a nice little launch point for that. If you write before, like what your feelings were in general about just, you know, completely being a noob or being nervous about a thing or whatever it is, and then you write down afterward kind of what you've learned and all that stuff. And if you continually jot these things down over the course of, let's say, six months to a year, I like to look at it around every six months, it will probably surprise you how much you've learned. So to give you like a real quick, just like real world example, there was a point in time where I didn't know what an interface is. And it gave me a lot of anxiety because it got brought up all the time with other smart programmers and I didn't really know how to use it. But now I write them a bunch in TypeScript and in Go, and it's really weird to look back at a time when I didn't know anything about it. And it's kind of funny because when I go back and I read it the first time, I'll be like, oh, really? Yeah, I guess I didn't really know that very well. And I'll start to come back to me. So it's funny how you'll forget these things. And it can feel really good to have that like, oh, yeah, cool. Yeah, I am learning a bunch of stuff, actually. That's sweet. So for me, this is really valuable, because it's just too easy to forget what you didn't know. And I think it's a good humility reminder for myself when I'm explaining things to other people, to just constantly be reminded of how many things I've learned recently and how recently I didn't actually know that much about it. Because we often kind of start to accumulate all this knowledge into ourselves and don't really recall that it was only three or four or five months ago that we really didn't know much about it. It's just kind of become a part of our being or everyday work. So try out keeping a journal and reviewing it every six months to a year or whatever for a little pick me up and a little bit more objective reflection on all the things that you've learned. If you're working on a big project and you write very descriptive commits, this is also a really nice way to go back and look at throughout the project, all the different things that you did and that you learned, by the way. Well, that will about wrap up this video, I think. And I don't really know if it will be that useful to people, but these things have been pretty helpful to me. So I thought I would take the time to just make a video and share them with you. So if they are helpful, I love to hear about it in the comments. And otherwise, I'll hope to see you in the next video. Take care. Bye.", "metadata": {"title": "5 tips for managing Imposter Syndrome", "url": "https://www.youtube.com/watch?v=TKMDu2gDxgM"}}, {"page_content": "Hello and welcome. Today I'm going to be covering using stories from Storybook in your tests. I'm going to be using React, Jest, and Testing Library for these examples, so you'll want to be familiar with those. If you're not, I'll put some links in the description for some documentation and general videos that you can use to get spun up with any of those, and I'll have some of that content on my channel pretty soon as well. But if you've already have those covered, let's dive right in. We're going to start this off with a project that I've already created ahead of time to save some time, and it's just a create React app simple project that we've used Storybook init to set it up with the default Storybook setup. I've made some slight modifications, which you'll see, but let's start it up so you can see what the Storybook actually looks like. Okay, so you can see the default Storybook button story that you might be familiar with, and it has its various different states. I haven't modified that at all. We also have a carousel component here. This is the demo that's a code sandbox that David Courchide showed, and it's really cool. It has, it's using CSS grid to lay things on top of each other and then using the hidden attribute with CSS targeting that to display it. So it's a pretty neat little demo, and I'll link it in the description if you want to check it out. And we've got this here to do a little bit more involved testing after we go through the basic testing setup of the button. So now that you know what we'll be writing some tests for, let's head back over to the code. And just so that you know, we are on Storybook 6.1.21, and I'm actually gonna start up my tests, kick over here, and do yarn test. Now the default React, create React app has testing built in, which is pretty cool. It starts with this test, and the test command runs a script that does it in WatchBoat, just so you know. So we have this app.test.js here that just comes with React Storybook. And popping over here to our code, you can see that I have this folder with these components and a button and a carousel. So I've just, I haven't modified any of the original button story, except for I've moved them into the folder structure that I like. So if you come over here to index.jsx, it's the same one that you've always seen before in Storybook, just the default. If you never checked that out, you can just run up a new init and you'll see it. And then here we have all of the starting stories. So you can see we have the primary, the secondary, the large, and the small. Okay, so let's start here. So I'm gonna make a test, and I'm gonna name it button.test.jsx. And you can use JS or JSX if you like. I'm a fan of JSX personally as the extension for just identifying them a little bit easier, but it doesn't really matter. Some people have a strong preference for it. And the same thing with the folder structure here. You know, this isn't the ultimate folder structure. It's just one that I like that works at a pretty good scale for me. But of course, do whatever you like. And also just a quick note, you might notice that my icons have a test icon and a storybook icon. I really recommend picking a icon library for your editor that does that. Mine is the Viking icon library, but I switched it around a bit. But I really like to have the storybook and the test icon and the react icon just to easily identify those when I'm looking through my folder. Alright, so let's start with the first test here. So what I'm going to do is I'm going to start this out by importing button, and that's actually a destruct. And I'm just going to import that from the directory that we're currently in. So I'm using dot. And then we know if we're using a testing library react, which is the default with create react app. I highly recommend you use that for testing personally. We want render and screen from that. It's going to be pretty common. And that is from at testing library react. And then we'll set up our first test. So I'll make a test here. And what I will name this is just something simple like should render. And then from here, we can render and we'll use that button. And in this case, the button actually doesn't take children like normal prop, it takes a label for the text. So we're going to pass in a label here. And I'll say like, click me. Cool. So I want to immediately know if that even causes an error. So I'm going to flip over to my tests. And I can see now that I have a new test that's passing. Cool. So it renders fine. And actually just show you that. Let's say that we deleted this, and we just saved it like that, we would immediately get an error here, but it's just a console dot error. It's not an actual test failure error, just so that you know. All right, so let's go back to that. Now, we're going to write our first expect here. And we'll say we want to use screen. And we'll say we want to use screen. And I'm going to do get by role, explain this in just a moment. And I'm going to do button, good old get by role button. And then we're going to say to have text content, and finish that. And let's first do it just click to see what happens there. And then I'll go over this. So we're going to get a failure here. But you can see that it gives us this nice message expected element to have text content click, but instead got click me. So you can see it's taking click literally. And I just want to show that because what you can do, if you aren't familiar, is you can put this in a regular expression and use case insensitivity. And that will get you what you want, basically. You could also make it click me if you want to be a little more specific, and that's fine too. Okay, so a couple things to really briefly unpack here. The screen, if you're not familiar with it, it is the new recommended way in testing library to basically do all of the get bys and query bys and all that type of stuff. You might be familiar with destructing off of the render, pulling off that get by, and it's recommended that you don't do that anymore. And you use screen and just pull it here. So and that's really nice, because then you don't have to constantly update this variable over and over and over for every single test. When you have like 10 different tests pulling that off, you just get it all from screen. So I kind of like that. Okay, so now we have a button test working, we just have an initial test, we can tab over here and see that that's good. Now what would be interesting, don't you think, is if we could use our stories as the test. Perhaps that's why you're here. It's a really interesting idea to me, because something that can happen at a larger scale product is that when you're working on a project and it gets bigger and you get more and more tests and more and more functionalities added, it's actually easy for your stories and your tests to fragment a little bit. And your stories won't show everything that your tests are testing and vice versa. And this can be a little bit confusing for your users sometimes, and it's just easy to happen. There's some other reasons that I like it that I'll actually show you by actually showing an example when we get to the carousel. But for now, that's kind of the gist of why I think it's an interesting idea, is just to kind of keep those synced up. So let's try it out. If we pop over to story here, you can see that we have a primary story with the component story format. And so I will just say, all right, well, let's pull in that primary from button.stories. And that's obviously going to fail our tests. I'm not even going to bother to look at that just yet. And then we'll replace this with primary, which this might be a little bit weird to you at first, because, you know, it's not actually the syntax for a button. But it's not actually that bad when you get used to it. And you'll see in a moment, because when you have multiple tests, you know exactly which one it is. Now this part, what I'm doing is I'm going to, it's kind of like passing on props, dot dot dot props. But in this instance, what we're doing is we're taking that primary, you know, function that we have here. And what we're going to do with this component, and we're going to get the args property from it, which you can also see down here and spread those out. And why it's args, if you don't know, is that Storybook is supporting more than just React, they're supporting Vue and all these other things, they're quite ambitious, or even vanilla JavaScript. And so args is just kind of a generic term there. So if you're used to it in React, this is kind of like dot dot dot props. So we're going to spread all those out, save that, see what we get. Now, we're almost there. But you can see that we had different text in our story. So you know, we've made it fail to show that. And so what we could do is pop over here. And let's say, we just want to look for button. Cool. And if you didn't catch that, that's right here, this label button. Sweet. So that was pretty easy, right? We now have a test that's reflecting our main component, or our first main story for this component. So in order to better showcase the usefulness of the next couple of tests, what I'm going to do is I'm going to pop back over to my terminal here, and shut this down, I'm going to run yarn test dash dash coverage to get a coverage report. Now you see that at first glance, it looks like we have 100% coverage, but that's actually not true. Because it's looking at button dot stories dot j s x, because by default, just is only really going to run tests that are being imported. So components are files that are being imported into tests, I should say. And so we need to do a tiny bit of extra configuration in our Create React app to fix that. So I'm going to go over to package JSON, we will add a jest property, you could also do this with a jest config. And what I'll do here is I'm going to do collect coverage from, so I can override that, this is going to be an array. And in this array, we're going to put root dir, and we'll do slash source slash components, slash star star slash star, and then dot j s comma j s x. So the reason that I'm doing this here is because we want to, for my purposes, I only want to test things in the components directory from this point forward. And of course, you could add extra customization if you want to be doing that for different folders or make it a little more complicated.", "metadata": {"title": "Using Storybook stories with Testing Library", "url": "https://www.youtube.com/watch?v=k6NG96awIJ0"}}, {"page_content": "And a final note, I actually don't know if this root dir is necessary here. This is really common in the docs, but I've seen people do it without it, just starting it like source. So if anyone knows if that's actually required or if it's a different operating system thing, you know, feel free to drop a comment. So here, what I need to do next is I need to say no node modules. We don't want to be testing node modules in case we happen to have any that do. Right now, I don't believe I do. And that's because we're overriding the default settings that create react app comes with that it's ignoring. And so we're going to have to add that back in, I believe. So then, lastly, we don't want to run it on any of our stories. So we'll do js, jsx. And that should be it. Now we're almost there. Pop over here, run test coverage again. And you'll see now we're not testing anything at all. That's kind of interesting, right? So we're definitely not testing the story, which is good, but it's not pulling in all of our files. So we can come back here. And we'll make a new test script. And this is because watch mode behaves a little bit funky. With coverage, I've actually had a lot of problems with coverage and watch mode in general. So I always just run it without watch mode normally. And that resolves it for me. And then plus, what this will do is this will set it up to where if we ever use continuous integration, we're not going to want watch mode in that anyway. So we can use this script for that. So I'm going to say test dash dash watch all equals false, and then dash dash coverage. So that'll be our script now. And then now we can just run yarn test colon coverage. Of course, you can name that whatever you like. And there you go. You can see that our button and our carousel are now being tested against. And I like this because now it really is blatant about like, you don't have tests for these things. It doesn't just show me the things that I've already started a test for. So the thing that we want to point out here now that we've done all that is that we only have 50% branch coverage for our button. So let's take a look at that. We can go into our coverage report, l curve report, this is generated out when you run a coverage. And you're going to want to be able to open this in the browser. So how I'm going to do that is, since I'm on Windows, I'm going to reveal it in Explorer, swap that over, and then just double click this and open it up. And then here, we can click through this nice little UI. So we go to index js, you'll see for this button that this yellow is saying that we have not covered it. So when we look for the mode, and when we look for mode, and we're going to set that to here as a class name, we're basing that off of primary that's coming in. And one of the cases is we aren't passing primary for any of our tests right now. And the other one is that the style tag is adding a background color prop if it happens to have one, it runs writes that as a rule. And we're not testing for that either. So one of these we actually have a story for and one of them we don't yet. So let's rectify that. And actually coming back over here and close that, come back to our button, just to show that you know, this is the primary. And this is the story that doesn't pass in primary that we're going to test first. So let's close this, we're not going to need this or this anymore. But what we can do is really simply just kind of clone this test here, and then come up here and this is going to be as simple as just pulling in the secondary story. And then we'll replace this. Of course, I could replace them all at the same time. I'm being a noob. And then here, we probably have the same text, so we should be fine. Let's go back over to terminal. And we'll start up our tests again. And that seems to pass. So then, just to make sure, I'm going to, you know, change this and see if the second one Oh, actually, we have them on the same name. So let's change that to should render secondary button. And we'll make this should render primary button. Whoopsie daisy. Okay, and there you go. So on our secondary test, it can't find button because I typoed it. So here, make that pass again. And we're good. And it was that easy. Just pulling in that story. That's pretty sweet. So next, let's actually make a story for this new prop variant that we're going to test. Now I have a quick disclaimer here. So when you are writing these tests and writing these stories, I personally don't think it's reasonable to try to cover every single prop combination scenario that you're going to have in your stories or in your tests. Really, the point of tests in general is to raise confidence in your project, and not to create a bunch of noise to where you ignore things. And that will happen really quickly if you try to test everything, and it'll waste a lot of your time. So that's from my personal experience. I think that you should though, have a story and a test for every either explicit state or primary functionality that a component has. And so in this case, maybe primary or just the color in general, we can click this little cool little control in storybook and move it around. And that's good enough for us. Maybe that's fine. But if it is a primary functionality of our button, and people are going to commonly use it, then you kind of have to make a judgment on whether you think you should have a story representing that and that you want to, you know, make sure that you catch that if any bugs are introduced. So we're going to assume for this purpose that background color is really important to us. So let's make a quick copy of this story. And we'll make it called custom color. And I'm not going to put size small, I'm going to change this to just say custom color just for testing purposes. And then I'm going to pass background color. Thank you for helping me there. And I'm going to make it coral. Coral. And let's see if that comes in. Yeah, we've got that already. Very nice. So now let's write a test for it. So going back to our test. Now we of course we can pull in this custom color. And then jump down here, we can use the same test idea for now. And then should render, let's do a custom color. And then of course we can change this to be a custom color. And we'll do the same thing here just so we can see the test failing if it tries to pass button. I'm a big fan of the fail then pass methodology. Red, green, refactor and all that. Okay, yeah. So it's looking for a button and it received custom color. Perfect. It looks like we're getting the right information. So now we can just write custom or we could write custom color if we think that that's what we want to test for. And we're passing. So now let's make this test a little bit more useful here. So I think in this situation what we might want to do is expect and then we'll just use screen.getByRoll again. Oops, getByRoll, sorry. And we'll do button. But what we're going to do here is we're going to do is to have style. So this allows you to pass in one or multiple CSS properties or declarations here. So I will do background color. And let's make it fail real quick by passing it red. Must be an HTML element or an SVG element. That doesn't look right. So I must have done something wrong here. Oh, getAllByRoll. Aha. There we go. Perfect. So it expected red but it got coral. That's what we want. So there's a couple ways we could accomplish this now. We could say let's do coral here. Okay. I'm going to scroll down just so my head's not in the way. So we could just pass in coral and that's going to pass for us. And I don't know if that way is better or this way is better. This one feels a little bit better to me personally. But what we could do is actually change this to be, oops, to be a interpolated string. And then we'll take off of custom color, the dot background color property and test against that. And oops, I need to put args in there so we can actually see it failing there. That's good. Always nice to make sure that it does. Whoopsie daisy. And there we go. Now let's see if we satisfied our coverage report. So let's close that out and we are in test coverage. And then we can see that we are at 100% now, which is pretty cool for that button. And we will go back to our browser and look at that. And now if I reload, boom, we have covered 100% of this component just like that. A quick note about this to have style rule here. This is a bit of a contrived example here. And in most situations you probably aren't going to have your styles being written out directly to your HTML. And so this wouldn't really work for you necessarily without some sort of snapshot serializer. And that's how I'd use it, especially in a lot of situations I'm using CSS and JS. And so that'd be the time where if I were to...", "metadata": {"title": "Using Storybook stories with Testing Library", "url": "https://www.youtube.com/watch?v=k6NG96awIJ0"}}, {"page_content": "were testing any styles, that's how I'd do it. Just a quick note there. So, so far, I think we can start to see that there's a little bit of potential here with using these story tests, right? We got this nice little feedback loop to where we know that our tests are testing the things that our visual documentation is showing. And this will even give you a little bit more confidence when, let's say, you are using your storybook not just for yourself, but also perhaps you have developers that are consuming your components or your library or whatever, your design system. And sometimes maybe designers will be looking at it or stakeholders or whatever. And now you are testing, you know, those same things back and forth. And we saw how with the coverage report, it kind of alerted us to a potential weakness that we might have in our stories or that we're representing and vice versa for our tests. And that's pretty cool. Now let's move on to a little bit more of a featureful component and some more fun tests. So I'm going to start testing the carousel at this point. I'll make a new file here, carousel.test.jsx. And then we can import, and in this case, I'll go look it up for us. It's going to be from./.carousel-stories. So let's open that up, stories. And you can see that we just have this one story template that's called default, and it passes in this array for the prop slides of swashbuckling with code. So let's go back and pull that in here and see if it would help us here. Yeah, it does. That's really cool. And then we can assume that we're also going to need render and screen from, oops, at testing library react. We'll write our first test. I'm going to use my little snippet. And this one will be just should render. We'll do a simple one first. And I'll call render and call our carousel. You're familiar with this at this point. And, oh, in this case, it's actually default though, right? So then we'll do... default.args. And that really should be it. So we'll save that. Do we have our test running? I don't believe so. Nope, not yet. Okay, now we have button and we have a carousel. Let's go back here. And then I'm going to test. Let's just do a snapshot test. Actually don't know if there is a new better way to do container here. So if you happen to know, let me know. So we'll do expect container and I'm going to do our first child because I want to get rid of that first div for my snapshot and we'll do to match snapshot. And we will see that a snapshot was indeed written. So you can't really write a snapshot without talking about it really briefly that it's a bit of a hot topic. Some people have some great arguments against it. They have great arguments for it. Now for my purposes, I find it to still be a useful tool, though I do see a lot of merit in the negative arguments, especially when they are about it creating a lot of noise. So I'm just putting it here to show that you can do it and I'm going to show a little quick thing about kind of what makes it nice in some way. But I particularly find snapshots useful still for snapshot serializers for CSS and JS. I kind of mentioned a little bit before. I think it's really nice when you have a bunch of components that are using other components, you know, you have this atomic structure and a change in one might give you some changes in others that you didn't really expect. And sometimes the serialized snapshots can catch that. Of course, if you can test that in a better way, great, but you know, do whichever you like, of course. So what I like about this is if we go to the carousel and we let's say we just make a little class name blooper here. Our snapshot is going to tell us right away that that's changed. And did we mean to do that? Okay, so that's pretty normal. It's pretty expected, but it's also going to do it in here. So let's say someone messed up the data here, just a little minor blip, and then it's going to cause the same effect here where the actual thing that's rendered out doesn't match. And this has now told us that our story is a little bit different as well, which is like we talked about that nice little feedback loop of our tests kind of catching errors that are in our stories now as well. Now, this is just a minor example. Of course, it would catch much more meaningful bugs in a lot of situations, but just to show that. So let's test some functionality, shall we? I'll write another test here, and this one I'll do should switch slides when clicked. And we're going to start off by doing our normal render here with default. And in this case, it's going to be the same thing. We don't even need a new story at all. What we're actually trying to mimic here. What am I missing? Ah, yes. What we're trying to mimic here is if we go over to our storybook. This is kind of a neat idea here because before we were testing just kind of static states in the stories, and that was great. But now we have tested the static state of this carousel, how it's first rendered, but we know that we can also click it. And in the storybook, that just simply happens. And now we can write some tests to simulate a person interacting with our component and, of course, interacting with our story here. The beauty of this is that we don't even really need to look at the code. We generally know how it functions. And what we can do is we can, let's see, first we're going to grab, let's do carousel container. Screen. And then I'm going to do get by test ID in this situation. Carousel container. Now test by, get by test ID is very useful. It's usually last resort. In this case, I don't actually know what the right role or semantics for a carousel tag are. I tried to look it up. But, you know, you shouldn't let the test be the proper testing methodology or where it's be a barrier to you writing tests. You know, you want to make sure that you actually can write the test and just use whatever works for now. And then come back to it once you find out a more proper way to do that. But if anyone knows that, please let me know in the comments if you have an idea of what the right role or how the right way to grab a carousel or a slider is. So moving on, we're going to do, first we're going to say grab all slides as they are always in the DOM. So in this case, the first slide, because of the way this is using grid with the hidden attribute, it's actually not rendering only one at a time. It's rendering them all and then just hiding them, which is kind of neat. So we'll do screen.getByText. And we're going to look for case insensitive swashbuckling. So that'll be our first test here. And it's still passing, which is great. And this screen.getByText, if you don't know, is actually a test in itself. Usually you want to be a little more explicit, like using an expect around it like we did before. But this alone will fail, you know, if we can't get it. So it is a test. You can see that. Unable to find element with the text. But we're going to use that in just a moment. So let's move on. So I'm just going to copy this a couple times. We're going to check for the second slide being in the DOM. We're going to check for the third slide being in the DOM. And then here, this is just width and this is just code. So we're just checking that each of those exist. Yes, they do. Awesome. Now we're going to start using them. So we'll say the first slide is visible by default. And we'll do expect and we'll just check that the first slide to be visible. This is actually one of the most common things that you're going to use for something being there or not. If you hover over it, you'll see that it covers all of these different scenarios. Display none, opacity zero, hidden collapse. It's even nice for the details. HTML attribute, if you ever use that, it's kind of like an accordion. But it doesn't actually remove the things from the HTML, so they're still there. And so in this case, what visible will check for all of that, which is really, really cool. Also, fantastic documentation on this. It's really awesome that they give you this from a nice little hover. So that will be visible. Now check this out. First, let's say, well, actually, let's say, what if we were to put not to be visible just to see. Is that test passing or failing? Yep, it's working correctly. Beautiful. So now, what if we do second slide to be visible? Okay. Okay, so in this instance, our second slide is not visible, which we haven't clicked at all or anything like that. So that's what we expect. We'll do the same thing with the third slide, but then we'll make this dot not to be visible and check. Okay, well, what about the third slide? You can see here it says expect third slide is the one that it's hitting, and it says element is not visible. So we'll put the dot not here. Perfect. Are they passing? Yes, they are. Glorious. So now that we have the kind of starter test.\n\nState here, let's do an action. So in order to do an action here, we're going to want to pull in something new. We're going to user event, and then we'll do from, and that'll be at testing library user event. Now, I actually wasn't familiar with that until really recently. So this is the new best practice way that the testing library documentation recommends using if you're used to fire event, this is replacing that. And it's really nice, actually, I've used it, I've swapped out a bunch of tests on my work project. And I really like the way they do the dot type event, it makes it to where you can type a series of keys as sort of a string, and then you can insert a backspace or an enter or anything, kind of all in one command. And it just feels a little bit more natural, like actual user input. So this isn't going to be too much different, though. If you're used to fire event, it's going to be the same here, we're just going to do user event dot click. And then we'll click the character cell container that we grabbed. So when we click that, we expect the slides to change. And so what we should do at this point is essentially grab all of these and paste them down here again. And we should probably write a nice little comment here to say after clicking once, only the second slide is visible. That makes sense. And of course, let's make sure we save this should fail. It does fail. Glorious. Oh, what I do. And then we'll just swap this to be okay, so the first one's now hidden. Come over here. And whoops, that one should be visible. Awesome. So that's a pretty good complete test just to test that the click itself is working. I think. Let's dive over here and see how our coverage is looking. yarn test, colon, coverage. And it looks like we've covered all of the generic usability for our button. And for our carousel. This brings me to another point here that I really like about this paradigm of using our stories for our tests. So you might not be familiar with this if you haven't gotten into this position before. But you'll notice that my story has this data that's being passed in right now it's really simple. You know, it could be as complex as you like. We have a whole bunch of JSON from an API or something like that. What I end up having to do a lot with my tests is I have to write dummy data for them. That's what I call it. And so I'm basically, you know, mocking some sort of simulated data from the API, because I don't want to test actually hitting the API every single time in my unit tests. And that caused me a problem of getting pretty out of sync with my stories at points where I'd essentially be, you know, copy pasting a bunch of information back and forth until, you know, I, in hindsight, it was really obvious, but decided to move that into a file that they could both share. Now, because of my convenient folder structure, where I have everything all in one component folder, I could just put it right here in a little dummy data thing. And I could, by default, add a rule to ignore all dummy data in my tests and stuff like that. It'd be a little bit more cumbersome to import that if my folder structure was all over the place. But really, this problem is kind of crazy at scale. Because, you know, if you don't find a solution for it, you're, it's very easy to get out of date, as you add new features to your components, you know, your storybook won't immediately be representing that possibly, or your test won't or etc. And so I really like this about this is, I could still make that abstracted file if I like, or I could put it here. But either way, I'm just going to import it into the story here. And then because my tests are derived from that story, they're always in sync with whatever data it's using. And I think that's really fantastic. Now, if I were to continue testing at this point, what I would probably write next for functionality is make sure that my carousel properly loops back around to the beginning, when we click it multiple times. So in this case, we click it a few times and check that just the first slide was shown. But I'm not going to bore you with that. I think that you could see how that could play out. But I hope that this example here has shown that, you know, we can take a story and elaborate on that and build some more functionality based testing around that. And kind of extending the nature of that either way. So this really lends itself to work very well, this paradigm of using your stories and deriving those tests from those stories. So I'm rather fond of it at this point. And I hope this video was useful for you to kind of showcase that paradigm. You got to give props to the storybook team. It's really awesome, all the stuff they're constantly pumping out and keeping up to date in this really fast moving ecosystem. So if you're a fan of storybook, like I am, obviously, and testing in general, especially with Jest, feel free to head over to my channel. I'm going to have some more videos on storybook and Jest coming out pretty soon. And I hope to see you over there. And once again, I hope this was useful for you. And if you have any feedback, go ahead and leave it in the comments. Take care.", "metadata": {"title": "Using Storybook stories with Testing Library", "url": "https://www.youtube.com/watch?v=k6NG96awIJ0"}}, {"page_content": "Hello and welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and in this episode, we're going to be covering a bunch of different ways to get CSS working in Webpack. We're going to start by creating a Webpack project and then getting CSS imports to work right away. Then we'll add some spicy Sass support, as well as source maps so that you can see your original code in the browser. I'll show development and production builds with minifications so that your users can download less and have a faster experience overall. We'll cover inline styles being injected into the document by our JavaScript bundle, as well as an alternative creating an actual CSS file from our output. In the last segment, we'll add post-CSS so that we can modify and extend our final CSS output. That'll allow us to do some pretty cool stuff like auto-prefixing, polyfilling, or fallbacks for cross-browser support. And then we'll read from a browser-list-rc-config file in case the defaults that post-CSS give you are not covering enough browsers for your user demographic. Finally, we'll top it all off with a quick addition of Tailwind CSS just to show how easily we can add things to our pipelines now that it's all set up. My goal with this video is for you to walk away with some confidence in the multitude of different flavors that you can set up for CSS inside Webpack. Alright, time to code! We're going to start with creating a project here, and I'm going to be cruising through this until we get to the CSS-specific details, but I do want to show you me setting it up from scratch just so that you know. But if you're interested in me going through each package that is required for Webpack for a basic setup to work with Babel, and going through all of the different snippets of code in detail, I have a video that's better suited to that that I'll link in the description in a pop-up, so feel free to check that out if you are interested in that. But let's move on here. So let's create that directory. I'm going to name mine Webpack-styles. You can name it whatever you like. And then we'll cd into that directory. And from there, we're going to init up an npm project or package json. Dash y is to say yes to all the answers, so you can just skip answering them individually. And then we already know that we're going to use Webpack, so we'll just add that as a dev dependency. We're going to do Webpack, and then if you use Webpack and you're going to run the commands for it, you need Webpack-cli. Those go together. Now that that's finished, we can open this in our favorite editor, whichever you prefer. Mine opened in a different window, so I'll bring that over here. And we can see what we have here is a package json with just these two packages, so that's good. And then what we need next is we want to create a source folder with an index.js. And if you select to create that as a file in VS Code, it'll actually create the whole path for you, just so that you know. In this file, what we can do is we can just make a variable real quick. So we'll say const headline equals welcome to the web page or something dumb like that. Now, with Webpack, you don't need a config if you are going to use the defaults, which is the source index.js as the entry point. So that's why I've placed it there. And if we come back to our terminal, we can run npx webpack. And if you're unfamiliar with that, npx is a way to go and get the most recent or current version of a package and run it, or it'll use your local one if you have that set up. So you can see that this built properly. We do get this warning that tells us that the mode option has not been set, and that's expected. We are going to be building in production by default, which means that you'll have everything minified and mangled and all that good stuff. Now, if we go back to our code, we'll see that it has created this dist folder and a main.js. And you can see that it's empty, which might surprise you if you're not super familiar with Webpack. But all you need to know is that in the end, if it's for a production build, it's only going to put into the final output file what it actually needs to run. So what we can do here is say document.querySelector, because we're not going to be running this in the browser. We can find the first h1 tag, and then we can do, no, I don't want text content. Thank you. I want inner text. And we can set that equal to headline. So now if we go back, we run our mpxWebpack again, and we come back here, we can see that our main.js has built out that script. It's put it all together. Notice that it didn't need to keep the variable or anything like that. So just a real quick rundown of that. Now let's get on to adding some styles. So we'll create our CSS file here, and I'm just going to call it style.css. It doesn't really matter because we're going to import it by name. So here we'll just set some basic styles here. I'm going to do background color. Hey, why'd you go away? We're going to make that salmon, and then we're going to make the default color of everything moccasin for fun. And then we're going to take the h1 tag that we're going to create, and we're going to do fz for the shorthand, and I think we'll do 68 pixels. And then from there, we'll just say, can I do tac here? Yeah, nice. Cool. So text align center. And then we can go over to our index file, and we'll just simply import that. We don't need to actually name it because we are just trying to raw load all those CSS variables. We're not going to use that variable or anything like that, or those CSS styles, I should say. So we can just say style.css, and that will load our styles onto the page here. And that will make a little bit more sense, if that's confusing to you, once I actually render it out. So just bear with me for a moment. So if we go back to terminal once again, we go to build. We can see that we're getting an error, and you want to look here first at the side of the error where the file, which file it happened in, which is style.css. It tells us that it's an unexpected token, and it says, and it gives us this little hint that I think could be a little bit better, honestly, but at least it points us in the right direction. It says that you need an appropriate loader to handle this file, and that is true. And you can see that it's getting hung up on basically CSS syntax because it's not JavaScript in this case. So let's add those loaders. So we're going to need CSS loader, so that's going to be our loader to tell Webpack how to deal with this type of syntax or file. And then we're also going to use style loader because with CSS loader, that will build it, but it won't give us a way to really output it. So style loader is a way to inject inline styles onto the page. And I will show you how to create a CSS file separately afterward, but we're going to stick with style loader for now because that's a pretty big norm. So now that we've done that, we need to actually set it up in our Webpack config. So this is when you do actually need a Webpack config. So webpackconfig.js is what we're going to create, and then the normal format for this is you're going to have a module exports, which is going to be an object. And in here, you're going to have a property called rules, which is going to be an array of rules, and each one of those is typically going to be an object. And you can think of this as like each one is a rule to tell Webpack how to process a certain type of file. So to tell it what type of file, you use the test property, and typically you're going to use a regular expression. I don't even know if it takes another format, so I'm making a regular expression that's case insensitive here, and then I'm going to do CSS, and I'm going to say it ends in CSS. But we can do a little escape this dot here just to say I'm looking for anything that ends in a dot CSS. Cool. And then from there, you're going to use the use, use the use, and what that does is it makes it so you're saying, how do you want me to handle this? Like what is going to actually handle this type of file? So we'll say CSS loader is what we're using, and I'll show you that just working first, and then we'll add style loader. So that will actually get us past this error. I like to do a little bit of a red-green approach too whenever I'm demoing stuff. Red-green just means that I want it to fail first, and then I want to fix it. It's kind of like a test-driven development methodology so that you can just see what's the minimum that's needed to run something. So here we ran Webpack, and it says invalid configuration object. Webpack has initialized using a configuration object that does not match the API scheme. Okay, so, ooh, you know what? That's great. It's not rules. Yes, it is rules. Oh, ha-ha. You know what it actually is here? I'll leave this mistaken because this is funny. So it's module first is the first thing that we need. There's a module key that has rules, and that's how you're going to handle each of those. Let's try to run that one more time. There you go. Beautiful. So now it will build and everything, and let's actually take a quick look at our output here. We can see that it now has this big old minified bit with a lot more code. So you can see it is putting in a bunch of code that essentially is it. Can we prettify this? Let's see. Format. There you go. So we'll just format that real quick so that you can see the final production version of it, and you can see there's a bunch of JavaScript that's been added, and it's essentially like how to deal with all of this CSS, but you can see the CSS inlined as a string here. You don't need to understand how all this works. I just think it's a good idea to get a little bit of exposure early on so it's not so intimidating or anxiety of what's going on under the hood, and then you can kind of build up as you go, you know, taking a look at each of these things. So don't think that I know how all this code works. I do not, but it's nice to every now and then when you have a little bit of extra brain power come and take a look at each piece and get a little bit more familiar one step at a time. That's just my two cents on it. Okay, so we can see that that's working, and like I said, this does actually work.", "metadata": {"title": "Webpack 5 CSS Walkthrough: Sass, PostCSS and more!", "url": "https://www.youtube.com/watch?v=SH6Y_MQzFVw"}}, {"page_content": "I'm going to output it, but it doesn't give us a way to put it on the page. And so that's where we'll add a style loader in front of that there, and that will do it for us. And in order to show that, we'll actually need an index HTML file. I'm going to manually create this in the distribution folder, and the reason I'm doing that is just for demo purposes. It is a common practice in some of them. Sometimes you'll just generate out your HTML files, and a lot of times you won't write your own HTML. If you're using Vue or React or any sort of utility library or framework, it's probably going to be processing all of your HTML for you. You'll just have the starter file. And so this is what it'll look like here. I'll just use this little snippet here. We'll make a title, why not? It's just Webpack CSS examples or style examples. And then here, this is where you'd normally have your div with an ID of root, but we'll make a container class, and then we will make an h1 tag. And in that h1 tag, I'm just going to do some nonsense here. Doesn't matter what, because our script is going to override that, and that's how we'll test that our script's actually running. But in order to get the script here, we will say script, and you can use this snippet for source, and then we'll say, oh, yeah, let's go grab our main JS and run that. So I could set up a dev server at this point, but for this demo, we're just going to raw load this index HTML in the browser. So I'm going to do reveal in Explorer, and then I'll just pop this open here. And here you can see it loaded up. I'm on WSL, so it's got this funky little thing in front of it on Windows. You can see it running our script, but not loading our styles yet. And I believe that's because we didn't rebuild after I added the style loader in. So yeah, cool. So let's go back to the terminal, and we'll run npx webpack again, and we're going to add a build script for that right after this. And so now that that's there, we should reload this, and every time, there we go. So we can see that our styles came in, and if you're curious where those styles come from exactly, you can check in the head, and what it's done is it's injected the style tag at the top of the head, and that's how it works. So you can also inspect just as a side note. You can scroll down here to the H1, and you can't see this because my head is in the way, but there we go. That work? So here, with the style tag here, you can click on this style tag, and it'll jump you up here. So let me actually show you that again. If you go to the H1, you can click on this, and it'll take you up to that tag. Cool. All right, now that wasn't too hard, right? So next what we'll do is we'll add SAS or SCSS to it. So let's start from a code-first approach here, and then we'll add in the terminal the things that we need. So we want to now have access to SCSS, so we can rename this file to be SCSS, and that means that wherever we import it in this script, we also want to change that to SCSS. And if we try to run this in the terminal, of course, this isn't going to work. So yeah, you can see that we're getting the same errors before. It doesn't know how to process it, just because of the file extension. And that's really because in our webpack config, we only told it to look for this type of file. So we, of course, could add this SCSS, and then that will work. But let's make that work, and then I'll show you the next step. But we want to go to package.json real quick, since we're doing this a bunch. I'm going to add a build script here, and then I'm going to just make webpack as the thing. And I'm also going to add a build watch. You can name them whatever you like. And this is going to be a webpack, and then dash dash watch here. So the first thing that I'm going to do is run over and show you that if I do run build, it's the same thing as our mpx webpack, and that's just a little more normal, because you're going to be reusing this script all the time, and you want it to be able to build on your server that ever compiles it. And you can see that it actually builds now, but we're not using any SCSS. So that's not really that great of a win. So let's do something here. Let's create a variable. We're going to name it light text, and then we'll make that our moccasin. Can't type for a moment. And then down on the color, what we'll use here is we'll just be able to do light text. And then we can also scope this underneath this here, because that is another functionality of SAS. I'm just throwing in a couple things that would normally cause our CSS to fail. So we haven't actually added any loaders in yet. So just really quickly, if we just do npm run build, it will build, surprisingly. But then when we go back to the browser, you can see that it's just tried to load in this non-viable syntax that it can't read here. I wonder if we get a console error from that. No, we don't. OK, so let's add our loaders in now. So in order to get SAS working, we're going to need to install SAS, which you can also do with Dart if you like. I'm doing node SAS here. And then we're going to do SAS dash loader. And that's actually all we need. Pretty cool, right? And then come over to here. And if we go to our webpack config, we can tack on the end of this. We can do a SAS loader. And that's all we need. So now let's do npm run build colon watch. And then we'll go over to the browser. And we reload. And it's working again. And you can see that our output is just a regular old CSS, even though it's inlined here like this. It doesn't have those variables or anything. So in the end, it's compiled SAS into CSS. And that's how that works. And now that we have watch open, I can show you I could make a colon root tag here and then say that I want a main BG. I'm going to use a CSS variable here just to show this. And I'm going to make this that salmon that we made before. And then for the background color, I'll do var. And then we'll use that main BG. And all I have to do is save that. And then if I come back over to here, it'll still work. And in fact, let's actually change it to something. So let's do medium purple or something like that. Come back over here, reload. There you go. Now, you can use webpack dev server if you want to get that live reloading. But we're not going to cover that in this video here. So let's revert that back here. So now, what if you wanted to process both regular CSS files and SAS files for some reason? Or you want to handle both types of syntax, SAS and SCSS, or whatever. If you want a global fix here, let me just show you this. So if I add, let's just do a woof.css page and pretend in it, I'm just going to make up a rule that the regular font size is like 18 pixels or something like that. It doesn't really matter. The point here is that what I want to do is go to my index.js and I want to try and import that. And if I try to import woof.css, we have set it to where it will only look for SCSS here. And we want it to be able to find both. So if I come over here, I'm going to shut this down real quick. And then I'm just going to run npm run build. You can see that has a failure as expected. And that's going to be the same error. And so let me show you how you can do this real quick. It's pretty simple. What you can do is you can say, all right, let's start at the top here. I want to wrap this whole part because I know it's always going to end in an SS for CSS or SCSS. And I can actually say it either needs to be SC or it needs to be C at that point. And then if I run a build here, that will run now. And if I wanted to be able to support, let's say, SASS as well, I can add a bracket here, which is interesting. And what that will do, it'll say it's got to start with an S if it's going to be on this side of the pipe. And it could be an A or C here. And then otherwise, it's going to start with a C. And then SS. So that's just breaking down the regular expression that you might see sometimes in case you're unfamiliar with that type of stuff. So that'll make this work pretty robustly for all different types. So next, let's show creating an actual CSS file in here rather than just doing the inline styles. So just a quick note on that. When you're using Webpack, very commonly, it's used for single page apps nowadays. And that would be the standard format for injecting that. You have one entry point here. And it's OK to just have your styles inlined here. Or you could have separate files if you like. That's fine as well for CSS files. But Webpack also does support multiple entry points in the config. And I'm not going to cover that. But I just want you to know that if you set up your entry points in here, you can point to multiple different JS files. And then you can import them individually. So you could have an about page. And that about page loads an about.js script. And that script loads the about.css file or whatever. So just so that you know, it doesn't all have to be through this one entry point. I'm just showing you the most common way to do this. So what we're going to need next is we want to add a new package here, which is going to be mini-css-extract-plugin. I always forget the name of that one. And this used to be the extract-text-plugin, if you're familiar with that at all. But since, I think, Webpack 4, they've switched that over.", "metadata": {"title": "Webpack 5 CSS Walkthrough: Sass, PostCSS and more!", "url": "https://www.youtube.com/watch?v=SH6Y_MQzFVw"}}, {"page_content": "And so this is going to be our first plugin. So we're actually going to need to bring it in. And it's common to use this uppercase, but I don't really know why, probably because it's like a class or something. And then we're going to do extract-plugin, and that's equal to a require statement here. And then that's going to be this mini-css-extract-plugin. And then you need an extra property here. You're going to do plugins, and you, from there, will new up this constructor here. If you don't know what that means, don't worry about that. It's just the syntax. And I think you can pass some options here, but I never really need to. So from there, you're almost done, except you're going to swap out your style loader. And instead, you're going to do mini-extract-plugin.loader and pass that in. And that's the whole setup for it. So now what you'll see is, next time I build, we're going to have a actual CSS file here, instead of the injected styles. See, it created this right here. And you can see it's all minified and beautiful. And then if we go over to the browser, you can see that we don't have it yet, because we haven't imported it. And so what we'll need to do is just run it like a regular CSS file at this point. So we could just say, OK, let's make a link that is a CSS type. And then that will just point to main.css. And you can see, without any configuration, it just, by default, chose main.css to be the output there, which is pretty cool. And then now, if we go back to our browser, boom. Everything's working just like usual. And the big difference we're going to see here is that it doesn't have those styles in the head anymore. It actually is going to have a CSS file. OK, so I'll move that just a little bit so you can see. Here, this main.css is what it's going to be. So you click that, and then here you go. And you can use this little Click button to prettify it. And it's giving you the final output. Now, you don't have to output a CSS file if you don't want to. It just kind of depends on your use case. I'm just showing you the two different ways that are the most common that people want to do. So this is a pretty good segue into source maps. Because what if we have a bug in our code, and we want to know where it lines up with the original code? This is actually just the output CSS. So what we can do for that is actually pretty neat. We only need to go to our webpack config, and you can add this property called devtool. And if you set that to the string source map, that is going to generate source maps out now. So we'll rerun that build, go over to our browser, and we'll reload here. And we close that, go back to the Elements tab. And then you'll see now we actually have an SCSS link with the proper line number. So that's pretty cool. So if we click that, it will take us to the SCSS version, where in comparison, let me show you this one, the CSS version. You can see that it kept our CSS variable, but not our SAS variable. And it also doesn't have things nested the way that they are. It's the final output. Whereas, where did that go? Go back here. Whereas in this one, it will reflect our actual code and the different line numbers. It's just a lot easier once a file gets really big in order to be able to track down bugs or just to see quick references if you're trying to look something up in a file or something like that. OK, so that was pretty simple, right? Just a quick note about source maps. We should actually probably go to Webpack, Source Maps. That was a weird search. And we go to this, just so you can see. I had a hard time learning this at first or figuring out what type to use. And from what I've learned, a source map itself is the most robust one as far as it works in development and in production. And it also is the most accurate to line numbers and all that. The problem is that it's slow. And it is nice of them to put this documentation in here to show us the different speeds in this table. But I feel like it's a little bit overwhelming to look at all these and just have no idea which one to use. So the main things to think about are just whether you want a production or a development only source maps. And that's a big debate online. The main arguments, one way or another, are essentially that if you put your source maps into production, it will allow you in your production code to actually track down bugs in the final format. And that's pretty powerful and useful at times, if that's what you need. No. But some people argue that you might want to hide your code. You don't want people stealing your code. So you're going to mangle it all up and minify it and all that stuff. Or it's a security thing, security through obscurity. And I don't really have a stake in the argument either way. I think it's fine to leave it in both. And some people think that it, I used to think this, that it adds extra file size to it to have the source maps. Because if you look in your code, it does have to generate out this map file. And so that makes the user download more. But that's actually not true, as far as I've learned, is that the source maps aren't downloaded until DevTools is actually opened. So even if you look in the Network tab here, it's showing what the user normally downloads in their network experience. And that source map file is not in here. So yeah, that's not an issue. It's really just a matter of whether you want your source maps to only be in development or only in production. So that's how you can choose which type you need. But if you're not sure, just stick with source map and then deal with that later. End rant. Let's move on. So next up is going to be PostCSS. Now, if you're not familiar with PostCSS, I'll give a quick little explanation to it. So it is a way to make final modifications to your CSS output. And the most common uses that people are familiar with would be something like auto-prefixer. So when you're using modern CSS style rules and you need cross-browser support for fallbacks and stuff like that, auto-prefixer will go and add those little dash dash webkit or dash dash MS or all those flags. You can also use it for polyfills or fallbacks, in some cases. And that's what we're going to start with. So let's pop on over to a terminal. And let's just install what we need first here. So we're going to add PostCSS. And then we're going to add Post, I always want to put a hyphen there, CSS loader. And then finally, we're going to have a preset here. So we're going to do PostCSS preset env. Those are the three packages we're going to need here. And this is a really powerful step that allows you to do a lot of really cool things past the point of just writing styles in a certain way. You can do a lot of transformations and stuff. It even allows you to do linting, if you're familiar with that, with style lint and all that stuff. So in order to set that up here, what we can do is tack onto the end of this chain. You can see we're kind of composing these loaders together one after another. And it's a pretty neat format here. And so what we're going to do is PostCSS loader is going to be the last step here. And you can actually set up PostCSS loader right here. So if you're not familiar with loaders in general, you can actually open up an object at any point and then select your loader and all that stuff. And then you can pass an options config to it. But I like to keep this nice and clean and readable here. And so I'm going to do kind of what the standard convention is for PostCSS is I'm going to create a PostCSS.config.js here. And what that will allow me to do is make a sort of config object that is just related to PostCSS. And well, let me show you how to do that. And then I'll kind of explain my take on that. So we can just do a require here. And then we'll just do that Post CSS preset env. That's all we need. And actually, we need module exports equals. There we go. And that's all we're going to need. And then how this works is that there's certain plugins like Babel or PostCSS that when you pass this here, they'll by default look at the root for a config file. And so you don't need to actually pass any extra options if you want to just do that here. The reason why it's nice, and this is my take that I was talking about before, is that I kind of think of this as like modularizing your configs. Because this webpack config can get pretty big and bloated full of stuff. And I think it's nice to kind of think of it as like a series of operations that are happening. And if you want to dig into how they work, then you can go and look at this config file. And we're about to do a browsers list to show that. And that's really convenient to have as a config file here, because both Babel and PostCSS both look at that file. So if you have multiple things that use a type of config, it's nice to abstract it that way as well. That's just my preference, but you do it however you like. So what I want to show here is if we go over to our SAS styles, I'm going to start writing in a bunch of extra styles here so that we can see PostCSS in action. And I want to kind of talk about the defaults in the browsers that it hits. So first, I'm just going to add some silly stuff here. Let's say I'm actually going to move this h1 out of the body, because that was silly in the first place. But maybe we'll do like the container that I had created before. And then we'll move this up here. And then what I'll do is I'll say, let's do padding, one rem. Let's do display flex. And then perhaps we'll do really silly background linear gradient. And I'm just going to be like to top black to white. It's going to look terrible, but let's do this for speed purposes. I always do that. Want a semicolon there? Boom. OK. Cool. Woo. OK. So now that I have a few styles here that I know aren't completely.", "metadata": {"title": "Webpack 5 CSS Walkthrough: Sass, PostCSS and more!", "url": "https://www.youtube.com/watch?v=SH6Y_MQzFVw"}}, {"page_content": "Backwards compatible. I'm going to show what happens when you run them through post CSS. Now the thing that you're going to want to know here is that it's actually a lot of things that you use in CSS, the adoption rate's been a lot faster. And so it's harder and harder for me to find things that need cross-browser support or a lot of it. And so what I think the default for post-CSS is for this preset env is that it will go two browser versions back. And then if a browser has greater than 1% of traffic, then it will use that. Otherwise, it won't. And you would think that that's pretty restrictive, but most things actually work. And let me show that here. So now we can do npm run build again. Now if we open our output, this main CSS file, we move that to the side. And actually, that's not that useful to read. So let's drop that back to development mode for the first time. And so let's say development. That's what we want to set the mode to. And you'll see right here that when I rebuild that, it will output this in a more readable format. So this isn't what you'd want to serve to your users, of course. This is just for you developing. So now we can see that it has actually added from the original. Let's put these a little bit side by side. So it has this background color. And you can see that it did take out this. But it added this fallback here with the post CSS. But it didn't really change much else. It seems to be like the only fallback that it added, maybe to support CSS variables. So let's actually add a browser's list RC, which is a common thing that you'll do. In order to get a little bit more backward support, and I can show you post CSS actually working with the preset here. So we're going to say browsers list RC. And in that, what we're going to do is say last two versions. This is just the format for it. So I want to support the last two versions of every browser. And then I want to support greater than 0.5%. Oops. And that is essentially going to say if a browser has more than 0.5% of global traffic, then we will support it, which is pretty generous, honestly. And then we're going to throw an IE10 into the mix. That's what they show in some of their examples. And I think it's a good one. So this is the browser setup that we want to support. And what you're going to see now is if we go and rebuild that, I'll bring this back up, notice that we now have some auto prefixes here. This WebKit flex, MS flex, and WebKit gradient. So these are the prefixes and fallbacks that it was able to create for us. And that's how easy it is. It's pretty sweet. And so now we can say, I guess maybe if you're not familiar with this whole process, it's that it's expensive to throw prefixes and polyfills or fallback support for every single browser. It's just too much for everyone to download. And so by default, the PostCSS preset, env, is picking some what they consider to be very sane, normal amount of polyfills and presets for the browsers that people use. It's like over 90% of traffic. But if you're just in an unfortunate situation at your workplace where you need to support old browsers for some reason, maybe your clients happen to be of certain demographic that use very old browsers, you can actually come in here and say, yeah, I want my browsers list RC to say that we want to support IE 10, for example. And what's cool about that is not only will your CSS do that, but if you start doing Babel to use modern JavaScript, it will use the same config here if you have that set up. And so all your stuff will target those engines. And so that's why it's nice to create this file this way. So that was a lot of stuff. With all that said and done, we're in a pretty good spot right now. We've got a really good flexible setup. And to demo how cool our setup is real quick, just to wrap this all up, I'm going to really quickly run through how we would set up Tailwind, because that's a new and up and coming thing. And maybe in our pipeline, we decide we want to start using that. And we've actually got pretty close to having that set up. So I'm just going to really quickly speed through that. And in order to do that, so I'll show you is, let's close the CSS file. So I'm going to paste in some stuff from their docs here that they have. So this is just, oops, I lost my arrow there. Thank you. And this is just a real quick, if you're not familiar with it, I'm not going to cover the syntax here. It's just a way of using a bunch of class properties to style your stuff with very minimal CSS. Love it or hate it, it's becoming pretty popular. So now that you have Tailwind syntax here, let's actually go to our CSS file and do some of the stuff that they need there. So what you want to do is go to the top here real quick and paste these in. You can see we have this weird at Tailwind syntax. It's obviously not going to build normally for us. And then I can go to, let's say I'll go to the h1 tag, and I'll throw in a directive. And you can see that it has a real problem with this. But this actually will build once we set up the plugin, even though it's showing us a syntax error. That's just the editor not being able to recognize it. And you can use an extension to be able to read that format. So in order to do this now, actually, all we're going to need to do is npm i dash d Tailwind CSS. And then we'll pop over to our post CSS, because it is commonly set up as a post CSS config. We already have post CSS. So we can say, oh, well, I now want you to also require Tailwind CSS. And then we can go back. We can run a build here. And this one's actually going to take a bit, because it adds a ton of stuff. OK, so pop on over to here. And let's see what our final output CSS looks like. And you can see it got huge. OK, so there's a ton of stuff that it just added into here. And if we go over to our browser, I'll reload. And you can see I have this really ugly looking thing now. That's because of my background gradient and all that stuff. But you can see I have this button here and this button here. This isn't a really good way to showcase Tailwind. But I am showing, just for the point of speeding this up in brevity here, that with just a few lines, because we already had that setup and we understand our setup at this point, hopefully, we can just quickly tack onto it, oh, yeah, I want to be able to use Tailwind. So let's throw it in the pipeline. And I think that's pretty awesome. So I really hope that this has been informative for you. Please let me know in the comments if you have any suggestions for future topics or anything like that, or if you think some of the things could have been made more clear or any other general criticism. I really appreciate it. My channel is just starting out. And obviously, there's a lot of room for growth. And I've got great plans for it. So I hope you'll stick around for future videos. And I'll see you then.", "metadata": {"title": "Webpack 5 CSS Walkthrough: Sass, PostCSS and more!", "url": "https://www.youtube.com/watch?v=SH6Y_MQzFVw"}}, {"page_content": "Welcome to Swashbuckling with Code. Tonight we shall study the dark arts of necromancy. I often come across developers, whether they're experienced or newer in their careers, referring to their GitHub as a sort of graveyard for dead projects. They might not use GitHub, they might just be local projects or a different repository system, but regardless, the mood is still the same, even if they don't use those exact terms either. It's essentially, I don't finish a lot of projects that I work on, and it fills me with either persistent anxiety or anxiety at varying intervals. I think most of us can relate to this, and it certainly resonated with me when I first heard it from someone else. And it's not just a coding thing, the advice that I'm going to try and impart throughout this video is applicable to other areas of life for sure. That advice, put simply, is to embrace that graveyard, which I call coding like a necromancer. When I say embrace your graveyard of projects, it's not meant as an excuse to just not finish anything, because certainly there's a lot of value in finishing projects. In fact, a lot of the times for my projects, the last 20% of the project is actually like 50% of the work. But it is an excuse to let it go, especially if you're moving on to something else. Bad scientists and necromancers alike classically have many failed experiments before they have a success, and while it may be horrible and unethical when you're experimenting on bodies, it is not when you are experimenting on code. I myself, and I've seen this in others as well, what often sets me back the most in progressing, just in my everyday life, in my career, in the things that I want to do, is the anxiety that's caused by having all these things on my mind that I need to do or that I've never completed yet, and it's like, oh, you know, I should go back and work on this project or I should finish this project, I'd like to be done with it. What ends up happening from that is that I just don't end up doing anything at all some days. I just become overwhelmed from that. Instead, why not turn all those project corpses into fuel? Don't even give a second thought to those failed experiments, except for that you learned something from them. And now you have those discarded parts from those experiments as references for your new projects. What I mean by that, getting out of the analogy, is that you have all this code that you've worked on that's saved up to a repo, hopefully, it could be on your computer, but I hope you store it somewhere else, that you can constantly reference in anything new that you make because you're going to forget that stuff at some point or another. So you're building up this sort of library of mad scribbles that you're creating, whether some of them are successes and whether some of them are failures, it doesn't really matter because you can always continue to reference that code in the future, and that's useful in itself, aside from the fact that you clearly learned something when you were making that. And why I say embrace this graveyard, even though finishing something is very valuable, is starting over is also really valuable. Some of the best code that I've ever written is when I started over once or twice, and a lot of developers would love to be able to start a project over, but they just can't. They have to keep working in a quote-unquote legacy code base. Also, as I've observed at least, you usually have to build something wrong or incorrectly to really understand why the right way is the correct way. You'll constantly encounter tons of idioms and best practices throughout your programming career, and if you just follow those blindly, you won't really know why. And if you're like me, eventually those will pile up to where, you know, I just do this because they told me to, and that's the way it is. And you can only do so much of that before you just really don't know why you do anything, especially when someone questions you about it. So there's a lot of value in just failing, obviously. That's a common saying, and this is just another way of wording that or looking at that, I think. It's really good to create the problem and have the problem and then start over or just move on to something else. Really, my point is summed up that you learn something from that, and you should embrace that. So what coding like a necromancer means to me is treating every graveyard project in your GitHub or wherever you store it as a success. Start embracing that you just did a ton of stuff, that it doesn't matter if you finished it or not. You know, there are certain times where you want to try to push yourself to finish things, but if you're really just not feeling it, don't beat yourself up over it because there's really not much value in that. There's not much value in letting yourself get overwhelmed and just feeling bad about it or just not doing anything that day or letting it eat away at you. Look at it as all the code that you've written that you consistently are doing stuff, and eventually that's going to turn into something, a skill set, a successful project, something that you can be proud of, something that's a success. But honestly, from my perspective, it's all a success. If you're progressing, that's a success. I want to end this video by showing you a real-world, you know, personal project of mine where I've had this very same problem. It's called Parallax Fjord. It's this little project that I did, I think, about a year ago, and it's a real-world example of me never feeling accomplished, even though I should have been proud that I built this thing. Throughout the part of my career that was making websites, I always wanted to work on a parallax site. And a ton of people have done this, so it was always like a spot of sort of an embarrassment for me because I just really like animations, I like creating UI, and I just never got to do this. There was never a project that allowed me to do this. So what I set out to do was to learn how to create a parallax site, and I wanted to first try to use some frameworks or tools because I really didn't have any idea how to do it. I was like, maybe I could figure it out, but let's try to just, you know, use whatever's popular. And what I ended up doing was, as I just happened to be going through Svelte, the docs, there's a part in there where they do a cool little parallax effect, and it kind of clicked for me how easy it is to actually do this. And so, you know, we started with something that I didn't have a good mental model for how parallax really worked at all, and I started trying to use frameworks and tools, you know, as you usually do, but eventually I made my code much simpler, in my opinion, and much more understandable for me, which was the important part because I built a mental model of how to create a parallax effect. And there's varying different ones that you can create, of course. It's just the one that I made. And then I also really wanted to do like a cool sort of SVG scene where it, you know, goes under the ocean. It's not super creative or original, but I've always wanted to create something like that. I've always been inspired by those things. There was quite a bit of work that I had to figure out for, you know, how to actually output the SVGs and how to layer them, especially the clouds that kind of go off the screen and all that. And then to top it all off, I added this like tree animation that was actually really complex to, you know, make all the trees kind of sway in the breeze. I did end up having to use a library for that. And, you know, I figured out that it didn't look very lifelike when I did them all at once. So I made them like staggered. So I had to write this function to go over, you know, each of them and stagger them. And then I did it all in Svelte first, but then I actually was pretty crazy. And I went and I built it in React. And then I built it in Vue because, not that it was the most beautiful code for any of them, but I wanted to just kind of see like size comparisons for something silly like that and, you know, what all work it was. And I was just kind of looking to compare and contrast like a little niche kind of idea and which one I liked best. I was just experimenting with them all. So, you know, after a bunch of work put in of all, you know, I rebuilt this thing, you know, multiple times. To me, that should have felt like a huge success. But there's always something else, right? Like I got into this problem where like now I wanted to demo it a little", "metadata": {"title": "Succeed by coding like a Necromancer", "url": "https://www.youtube.com/watch?v=UstaGlORbtA"}}, {"page_content": "like now I wanted to demo it a little bit and show some people that I knew, but I realized they'd be looking at it on their phones and I didn't build it for phone at first. I built it for desktop. And when I brought it down to a phone, I realized like all the dimensions were all wrong and the scrolling was very different and all that stuff. So, you know, I kind of just made it work, but I wasn't super happy with it. I was like, okay, at least it's supported on the phone, but I could say it's a lot better on desktop. So, you know, that's at least a stepping stone. But that was just one more anxiety that I felt of like, you know, I didn't really finish that. And then I realized that on little slower CPUs, the frame rates would get pretty messed up. I also at first had this like cool SVG distortion filter that I was playing around with to make the water kind of wavy in front of the SVGs. And it looked really cool, but it just destroyed the frame rate. And so I was just left with this project that I couldn't really demo or show because I wasn't proud of it because the frame rate was terrible and I hadn't optimized it and figured it out despite putting a bit of time into it. And that haunted me for like months. Every time I thought about it, I didn't think of it as like, oh, I learned all this cool stuff and I kind of finished this project. It was just like, oh, it's just another project that I didn't finish and I really need to go back and do it. So I think you get the point now. And what, you know, until I reflected on this idea of treating your projects as success, even when you don't finish them, I wasn't very proud of that. And all the work that I put in was just kind of thrown away and it actually ended up serving to just give me more anxiety. But after really thinking about that, you know, it put things into perspective and it helped me re-clarify and refocus like, yeah, I did that. And now I can do something cooler next time. So that real world example was just to kind of show you on a personal level that I feel this as well, just to give a little bit more context and especially for, you know, younger, newer developers, that, you know, people that have been doing it for many years feel the exact same thing all the time. It doesn't matter how good you get or how cool is something you make. If you let yourself, you'll be disappointed in it. You'll never really feel like you accomplished that thing unless you sit back and reflect on that and let it go and move on to the next thing. This is what works for me. This is usually what makes me the happiest, makes me continue to progress and, you know, improve my craft. If it doesn't work for you, I'm sorry about that, but I hope that it will work for some of you and will be useful to you. Thanks for watching and I hope to see you in the next one.", "metadata": {"title": "Succeed by coding like a Necromancer", "url": "https://www.youtube.com/watch?v=UstaGlORbtA"}}, {"page_content": "Hello and welcome to Swashbuckling with code. I am Jimmy Cleveland, and in this episode, I'm going to be showing you bundle visualization tools, sometimes called bundle analyzers. And they are really awesome way to get a sort of visual graph of what your packages look like for your final, a bundle.js, main.js, whatever your JavaScript bundle that you're serving up to your client. So we'll start off using webpack visualizer, which is a nice little drop in web tool that just makes it really easy. As long as you have a webpack JSON output, which we'll have at the beginning of the setup. And then we're going to dive on into a webpack bundle analyzer, which is a little bit more of an industry standard tool, as far as I've seen in my experience. And I think it's really awesome. It's, it's my preferred way to do it, but we'll kind of compare both of them because I think it's nice to see them both. And what we'll do along the way is we will add a couple of different packages and we'll look and see how that grows our bundle and how importing them in different ways can drastically affect our bundle size and these visualizers make it a lot easier for us to have, you know, more visualization. And this is so that we can get a representation of the dependencies of our dependencies and all that stuff. And we get to watch and maintain our code and be a little bit better, a little bit more diligent about our bundle size growing, and then we can kind of surgically change things as they happen, rather than having this big surprise at the end of your project or in the middle of your project where your bundle has grown enormous and you don't know why and you have to track it down. So even if you are in that position, a bundle analyzers or visualizers are really useful for tracking that down. But I think at this point, just showing you we'll explain the rest. So let's get to some visualization. We're going to be starting out with a basic web pack and Babel setup. It's got Babel core preset ENV, Babel loader, web pack, web pack CLI, nothing fancy, just so that you know, let's take a look at the files that we're going to be visualizing first though. So in our source directory, we have our entry point, which is our index JS. And you don't need to be concerned with the code that's going on right here, right now. All we're really looking for is the fact that we are importing get classes, and then we call that, and then we run some code inside this file. And then in get classes, we have two destructured imports and it just console logs those as well. And if you take a look at those, they're just simply exporting a string. So this is just to get some import diversity for our bundle, which you'll get to see visualized, and that's kind of interesting. So jumping on over to our browser, you can see that we have, let's start out with web pack visualizer. We have this interesting website here that is probably the quickest to start out. And so what it tells us to do is to use web pack dash dash JSON and arrow that into stats dot JSON. Okay. So we'll make a script that does that since we're going to be using that for a while here. And we can just go into our package JSON and we'll say, let's just make it stats. And then here we'll say web pack dash dash JSON. And you actually don't have to use this arrow to send it into a file because the, this actually takes another secondary argument here. So we can just do build stats dot JSON and that'll work just fine. Okay. Go on over to back to our terminal. We'll do NPM run stats and you'll see stats are successfully stored as JSON to build stats. JSON. We go back to our code. You'll see that we now should have this build stats JSON file. Let's take a quick peek at that. Why don't we, we don't want to get too lost in the weeds here, but I think it's always good to just get a little bit of exposure and familiarity to things. So the things that we're kind of concerned with here is, um, this assets by chunk name, and you can see that we only have one chunk and the chunks are basically web packs, you know, kind of version of letting you know that it's split up your bundle into multiple files, but we only have this one bundle main JS. We're not loading extra chunks or anything like that. So that's our only one. Let me come down here. It'll say, okay, this is our asset. It tells us our size and some interesting information, and then keep coming down. There will be this chunks array of objects. And within that there's a modules. This is the part that I wanted to point out. That's kind of interesting. It goes into each module. It will tell you the name somewhere here. So barbarian JS. So it's looking like it's doing it alphabetically. This barbarian JS, it will say the issuer, which is kind of interesting because it even tells us that in node modules, Babel loader is the one that handled it, and then finally it tells us the file at the very end that was handled with it, or we could just look at the issuer name, get classes. So this is saying that get classes is the one in this case that, you know, went and got the barbarian and used it. So yeah, barbarian wizard. Why did I do that? Just for fun. There's nothing special or anything going on there. So that's it. Just a quick little dive into what this JSON file is, and you can imagine that you could do lots of cool scripting stuff with that, but what we're going to do is right click, I'm going to do reveal in Explorer for me. I'll bring that back down here to you since it went to another window. Let's resize that because we're going to have that around for a little bit here. And the reason why I'm doing this is because if I open my browser and then I want to just be able to drag this build stack, I can just drag it to drag this build stats dot JSON onto here. And it's that easy. Pretty cool, huh? So right off the bat, we're getting a 6.5 K actual and a 2.8 K raw. All right. And let's see if that lines up with our numbers, since we are pretty concerned with the build size here. Now, I believe that this is going to by default run this at dev since the way that I have it set up. So we should see that we're probably okay, 1.09 KB and then NPM run build dash dev for our main output. So I'm just looking at this main JS 1.09 KB and then here it's 6.52. So let's go back to the browser here and you can see it's 6.5. So this is our development bundle and you'd probably normally want to compare it to your production bundle. It kind of depends, but there, there are some hiccups that can happen where it won't quite separate all the files the way that you need, so I'm just going to leave it for dev for now and we'll use it to reference those numbers. But obviously you could do it in build if you're looking for a real actual, what the client's going to download. Okay. So visualizing this, we start here with this main JS 6.5 K actual. I know that's kind of tiny, but I can't really zoom too much here or else we'll we'll lose all the information that I need. Sorry. But then it says this ring around it is a hundred percent. So it's saying of this main JS file that we output a hundred percent of it was from this source and it's blue as a directory here. And then here, the index JS that goes around that is saying 87.2% of all of that source was a index JS. And that's, so that's where the bulk of our code is happening here. And then each one of these is going to be our wizard, our barbarian, tiny percent, and then get classes a little bit bigger. And that makes sense, right? We had a bunch of code and index or get classes just brought these two in. So let's build upon that by installing a package UUID, which is a nice little package that I use a lot, and it's got a really good setup. I'm going to see the benefits of that a little bit later. But the main thing here is we just want to install it and then we'll use V4, which is just like a random way to create a unique identifier. And it's pretty cool. And then we'll see what that looks like in our bundle. So back over to our terminal here. I'm going to NPM install and then we'll do UUID. And then we'll go back over to our code here. And in our code, I'm just going to use this in the wizard one, just to kind of bulk this file up and see what happens there. So we'll import and let's start with, let's actually start with UUID just straight from it, even though this isn't the way I would normally do it. And you're going to see why. So UUID here. Let's say what I want to do is append to Ravelin. So we'll just like concatenate to this and then we'll do UUID.v4. And you're going to call that. That's a function. Okay. Now we'll go back over to our code. We will run stats. So when we run our stats, we're going to be dropping this file in here again. And this is kind of annoying at first. This is just like the easy, quick way to do it. Oh yeah. Refresh this browser, sorry. You have to refresh to get it to reset there, but we will do it in an automated script way in just a little bit. Cool. Okay. Wow. That bulked up quite a bit, right? So now we have 38.3 K actual 22 K raw. Okay. So let's look at this. What does this say? Okay. So big portion is node modules now. That's that directory. And then here's our source directory in proportion. So we still have all our usual suspects here, but we're going to now we have this node modules. That's taking up a ton. So that's bloated us right. A lot. Right. And then if we do this, you ID here, that's taking up 89.7% of all of, you know, is the same, same percentage here that node modules is, and that's going to be the same moving out so we can see, we don't really care. It's just a bunch of folders climbing that way there. So then in here you can see, we have, what are the individual packages that are in those folders? Well, we have an empty five. We have a V one. We have a Shaw one with a string of five ours, and we're looking for our V4 and there it is 2.5%. So that's what we really want. Um, but then you can see along here, we're getting a bunch of stuff for the ride. There's a V5, B3. So we're just picking up a bunch of stuff. Okay. So we're going to say, we're going to pick up a bunch of stuff. So we're going to say, we're going to pick up a bunch of stuff. We're going to pick up a bunch of stuff. And then we're going to say, we're going to pick up a bunch of stuff.", "metadata": {"title": "Know your Webpack bundle better with visualization", "url": "https://www.youtube.com/watch?v=oAgHZ9zlmaY"}}, {"page_content": "So we didn't actually want those methods. So, you know, maybe we want to wonder like, what's going on here. Let's go back our code to look. Okay. So when we import UUID this way, we're actually importing the whole thing. Let me show you an interesting little thing here. If we do import all as UUID, and then let's rebuild that run stats back to here. Reload this, drop that bucko right in here. Oh, that's a little bit different. Right. And now we're down to 13.4 K. So now it's only 60% node modules and then 40% the rest of our code. And then here, I mean, this is a nice little graph here just to kind of see like, oh, okay, like proportionally. My code is actually only this, this much, but if we go back out to the packages at the end here, look at this, these are a lot bigger proportion now, and there's a lot less of them. So that's all we really had to do. So that is really cool thing that visualizing the bundle can show you. Um, obviously you could just look at the output, but it's nice to be able to see it and say, oh, okay, so that's why you import it this way. All right. Well, what will happen if let, well, let me actually show you one thing before I convert it over. So let's say we don't even use it. What happens here? Right now, if the project set up, right. Webpack should be able to detect that it's not used and not throw it in there. Okay. Even though we're importing at all, it's going to be like, well, you didn't do anything with it. Okay. So NPM run stats again. Oh yeah. I always forget this refresh and then build stats. Okay. There you go. It's back to where we were this, uh, 6.5 K and then it's just our code. It's all in source. All right. So just to show that the package is working as intended, and that's cool to get a little bit of confidence there, that that's how that's working. So finally, what I'm going to do here is instead of importing all this way, I want to see if I get the same result, um, destructing V4 off of this to see if it's properly handling ES modules when we use this, so we'll go all the way over to here and we'll say, let's just call it V4 and you could rename this like they do in their docs, but I'm not going to for our demo build. Go back over here. Reload. Kick this on over here. Build stats. And that looks the same. So 13.4 K, if you remember the number and then notice we still have the stringify, RNG, V4, et cetera. Now you might be wondering at this point why we have these other methods and I'll show that at the end of the video. Um, I think it'll be a little more relevant at that point, but for now, just know that their dependencies of this V4. Okay. So we can see that, uh, when we import it, let's go back to our code again. We destruct import it this way. It works the same as just bringing in UUID star as UUID and then calling that individual function. So that's pretty neat. Now that we have that visualize, let's try another visualizer here. Let's try, uh, using, uh, a different method. Let's try, uh, using webpack bundle analyzer, which is one that I really like and we'll compare the differences. So going back to our terminal here, we're going to install NPMI. And, uh, this is a development dependency, dev dependency, because we're just, you know, using it for visualization purposes, webpack bundle analyzer. And actually while that's going, let me make a quick note on this one. Uh, it does actually say that they have a plugin and, uh, I tried to set it up before for this video, cause I'd never used it before, but I had some trouble getting it working. Um, maybe it's just the latest webpack or whatever. So, you know, if you want to try and get that working, uh, the same way that we're about to do with bundle analyzer, you know, feel free, but just so you know, I'm just using it for this quick drop in because this other tool is my preference and it's what a lot of people use. So to set this, uh, bundle analyzer up now, we're going to go to our webpack config.json, we're going to go to the top here, we're going to say, uh, const, uh, bundle analyzer plugin is the way that they normally do it. And then, uh, that's going to be equal to a require statement. And then here we can do webpack bundle. Yeah, that one, that's the one. And this is a little bit weird, but, uh, they actually make the first thing an import here. They do it like this bundle analyzer plugin and just change it on so that that's the final thing that you get back. So that works. That's fine. That's the way they do it in their install. Actually should try out and see if I can just destruct that since it's clearly a property on this, but for now, let's just get it working first. Okay. So then, um, we need to add a plugins array here and in that plugins array, we're going to new up a bundle analyzer plugin, and we're just going to call that as a function and we need a comma here since this is a property to end that. All right. And then now the way that this works is this is now in our normal chain. So anytime that we run a webpack at all, it's going to run this analyzer plugin on every build. So just be aware of that. So we can still run our build stats dot JSON, and that'll run because let's go back to our package. Jason, that will run because it runs webpack first. All right. Now I'm going to stick with build dev still so that we have the same, like size comparison analysis. All right. So going back to here, just remember that we had 13.4 K in our dev mode, and then we'll go to our terminal and we're going to do NPM run and let's just do stats again, point on build dev would work as well. You can see that it, it shows that it started the server up. Okay. So that's kind of interesting. And what I'm going to do is I'm going to copy this because, uh, it doesn't pop up for me, WSL life, you know, but it might automatically pop up for you just so you know, and then what we can do is go over to here, paste this in and there we'll get this. Now, this might not be super visually appealing the first time that you see it. Uh, it wasn't to me, but once you kind of get used to it, it's pretty nice. Now I have this, uh, zoomed in a bit just so that you can see these numbers a little bit bigger, but it tries to keep all of these squares intact. So the, the idea here is that, uh, it's showing them as a series of kind of containers instead of that, um, you know, circular graph. I'm not sure what that kind of graph is called, but this is going to say, okay, well, all of this is under main JS. And then you can see on the right here is our source and we can hover over each little thing and see the individual file size of those pretty nicely in the path and all that stuff. If we hover the whole thing, it says 13.36, which looks like it's in line. So it's visualizing it the same way. And then over here on the left, we have all of our node module stuff. And within this folder, ESM browser under UUID, we have stringify, V4, validate, regex, all the same culprits. So that's pretty nice, huh? You can actually bring this over here and you can look at some different views, which is pretty cool. But one thing that I really like is let's say I type UUID here. It will highlight all of these individually, and you can actually pin this, um, which is pretty cool. And then normally it's not this big because it's not as zoomed, but you know, for recording purposes, it is. You can actually click on each of these things to go see them. And that will be really useful when we have a bunch more packages in here, because some of them are going to be like microscopic and hard to see in it. And it lets you zoom in and see them. If you ever get in a weird zoom mode, you just zoom all the way out and then it'll reset itself. So that's pretty cool, huh? All right. So now that we have seen that, um, what we're going to do is we're going to add another package, uh, to show how things can be a little bit tricky and how you can use these bundle analyzers or visualizations to catch some problems early. This is something that I really wish that I had done early on in my career or known about, um, is it's, it's really nice way to not just look at the file size, but to continually look at where is this file size coming from, because it lists some sub dependencies too, you might add a package and not know how big it actually is. So enough of me blabbing, let's do this. So going over to load dash is what we're going to be using next. A really, really common library. If you're not familiar with it real quick rundown, it's essentially. A utilities library for JavaScript that gives you a bunch of methods that some we don't need anymore, but a lot of them are just really nice, um, like flat map and all that stuff that we didn't used to have once upon a time. Now they have a bunch of different ways to install it. If you come down here, the default, they just say install low dash, but there's also this low dash core, low dash FP. Uh, you can individually do them. So I'm going to show a bunch of these. I don't know why they don't show low dash ES. Maybe it's a different team. Um, but we're going to be covering all of those in just a moment, or at least the ones that are pertinent to us. Okay. So come back over to the terminal here. Let's close this server down. And then what we'll do is we'll say MPMI and we'll do low dash. Oops. And let's just do low dash for now. And then we'll, we'll, we'll see the differences of the different ones. Okay. So now we're going to do is go back to our code in barbarian. We will come up here and what we're going to do is we're going to import. And then let's actually look at their, um, you know, preferred way. They have a import script here. Yeah. So they want to do underscore and then require, and in our case, we can do import. Right. So come on back here. We're going to say import. We'll do oops, underscore and from, and they just name it underscore, and then we'll do this from low dash. All right. So what we're going to do with low dash is I'm going to use the low dash get method, which is one that I still haven't been able to get away from. And I'll explain it as I go. So first we'll make an object. And this object is going to be.", "metadata": {"title": "Know your Webpack bundle better with visualization", "url": "https://www.youtube.com/watch?v=oAgHZ9zlmaY"}}, {"page_content": "Object is just going to be stupid. It's going to be a nested object. One, two, three. And what low dash get is going to do one, two, three, four. One, two, three, four. Great. So what low dash get is going to do is it's going to let us climb into this object and it will actually return undefined if it can't get all the way there. All right. So if we were to say const, you know, let's name this get wolf equals, and then we're going to do underscore, right? Dot get. Kind of weird. And then from here, what we'll do is we're going to say, okay, what do you want to get it from? The first thing you pass is the object. The second thing is the path, but it says a string. So you're going to do one dot two dot three. So let's not go all the way there. Let's say we expected, you know, actually let's do all the way there. I think this will be a little better example of it, but we'll just skip one. So this normally would throw an error. And what low dash is going to do is it's going to fail safely and return undefined. In this case, the get method. And you can actually pass a third argument just as a little bit of get knowledge here to return something else. Like let's say you want an empty object instead of undefined to what you get back or an empty string or something like that. You can do that too, which is pretty cool. So it's a very nice utility function. I like it a lot. So now we'll just console log, get wolf and I'll put a thing in front of it. I don't know if I'm actually going to print this out, but you know, I want to, I want to see if just in case. Okay. So now we're using it and let's run our bundle once again. So run stats. And then now that we're doing that, we'll come back here, go to this. We just refresh this now that we've started the server up again. And this is pretty crazy, huh? You can see that in our node modules, there is this like weird sliver here and this weird sliver here too, but look at source. And then this is our UUID. So apparently we've added something monstrously huge to our whole package and underneath node modules, which is this low dash. And it just says low dash dot JS. It doesn't say the methods or little sub dependencies or anything like that. Pretty crazy, huh? And if we look at our total size, we're now up to 545 KB up from like 13 KB. It's pretty wild. So that doesn't seem right. Right. So we know that there's a problem and we can see it pretty visually right away. And let me show you that thing I was talking about before. Now that we're in this view, if you do UUID, this is pretty cool. It will, you can do this. And unfortunately, it doesn't like, you know, change the box model or anything like that. That's probably too hard to do, but at least you can zoom in to each one and actually see them. So yeah, it's pretty cool. I like that. All right. Then you just zoom out, zoom in, zoom out. It'll figure itself out. Okay. So that clearly is not what we want. So let's do this because the other way that they recommend setting this up is instead of importing underscore from lodash, maybe what if we did the thing that we did before where it's import as. Okay. Let's run our stats again from the terminal. Sorry, got lost for a second. All right. And then from here, we will do, and actually while we're doing this on this mode, let's try this. Let's do npm run and I have this watch command to do webpack dash dash watch. And I'm pretty sure this will work. But what it should do is put this in watch mode and then start up our bundle analyzer server and then every time we save, it'll allow it to reset. I've done this with webpack dev server, but I've never done it with watch mode. Okay. So it doesn't look like that did anything at all. Right. Let's do a quick sanity check and say, all right, you know, you imported all that stuff, but, well, actually let's just delete it first because you're going to have an interesting surprise here. Okay. And then come back over here and look, this automatically updated. That's pretty cool, huh? Going back to our normal format and then we're back to 13.45 KB. So we know something's up here. So maybe let's undo all that and just import this. And actually I'm just going to comment these out for simplicity. Right. Sorry. I'm still on this different keyboard. It's kind of throwing me off a little bit. I have a split keyboard, so I apologize for the high amount of mistakes I'm making. Moving on. We're just going to import all as lodash. Okay. And then see what happens there. Look at that. Webpack can't figure it out. Like it could with UUID. Even though we imported the whole thing, you know, no matter how we do it, like if we go back up here and let's say we just do this, throw that back here. Doesn't care. It's still bringing in all lodash. So what this is, is when a library isn't properly set up to do ES modules, Webpack can't do what's known as tree shaking to throw away like dead code elimination or anything like that among some of the other bundle optimizations that it does. And so that's kind of our problem here. Now, what if we were to, I'll show you the way that they recommend to do this. If we bring these back in here and then what we'll say is we'll go to the directory and do that. So we'll say import get from lodash get. And then what we want to do down here is just get rid of this call to it and do that. What happens when we do that? Ooh, that did something. Now we have a bunch of little things. What's our size though? 62 KB. And it was like 500 something, right? So that's an improvement at least. It still seems like a lot of stuff. You can see it's pulling in all these things, but you might think, oh, maybe these are just sub dependencies. It's a lot of stuff to have sub dependencies of, but you know, maybe it is. And here's our get, which is pretty cool, but at least we're moving in the right direction. So that's a good start. So another package alternative that we can do here that's commonly recommended is to do lodash, oops, lodash es. And that stands for ES modules, ECMAScript modules, not Spanish, not espanol. And when we do npm run watch again, what we're going to do is see if we get similar or different results. So now we're at 62 KB, if you remember that, and then we come back to here. And then what we're going to do is instead of that, we'll do get it from lodash es. And well, let's try this first. Let's do it the same way. Come over to here, reload just in case. And it looks like it's the same, doesn't it? Now it's 84 KB. It's actually a little bit bigger, which is kind of crazy. But if we do this, and let's go back to here, and I'm going to wrap this. So I want to destruct this like we did with uuid and see what happens there. Same thing, didn't change. I mean, at least we can destruct and bring it in that way. So that's cool. And it's not bringing in like the whole library, which is great. So you can see that I guess the minor advantage here with lodash es is that if we just import from this directory, and we pull this off here, we at very least are getting closer to the smaller sizes, not the 500 KB of the whole library or whatever. So that's a good direction. You know, at least we can do this nice syntax here. But what I want to show you here is what if we were to go oops, what if we were to go back to this instance where we're like, hey, I just want to do like underscore again. I keep doing that. And then come over here. Ooh, look at that. It actually works now. So at least this package is in the right direction sort of, because it is making it to where we are getting that dead code elimination. We're back to our small 13.5 KB if we just import it, unlike the regular lodash, which just brought everything in. And they say it's because they have backwards ES5 browser support built into it. And I'm kind of curious, because a lot of packages do that as well, from my understanding. And, you know, they just work with imports, exports, like UUID does. So I'm not sure what the full scoop is there, but it's not working too great. So from here, what you could do, there are some other options. I don't remember if they list them right here. Oh, yeah, right here. Module formats. So they do say lodash ES. There's a Babel plugin and a lodash Webpack plugin. And I've seen some success with those. I'm not going to cover those today. It'll be a little bit more involved to do that. But I just think that's crazy. I think it's pretty nutty to have to set up a whole Babel and Webpack plugin chain for a single set of packages. That's just kind of wild. Let me show you an alternative. If you happen to be using only a few methods in lodash, like in my case, I'm just trying to use get maybe that's the only one you use. I have libraries or I have projects that are like that. So what we could do here, come back down here and say npm i and then we can just do lodash.get, which is nice of them. They've actually exported it by name that way. npm run watch again. So now what we can do is we'll go back to that get format where it's lodash and then this will be.get like so. Scroll down here, re-enable those and then let's see what happens. Come over here, reload this. Oh, look at that. So now the whole size is 37.96 KB and you can see that we're only getting this lodash get.\n\nAnd it's much smaller than it was before. You know, our other sizes we got up to like 80 KB with the lodash ES all the way to 500 plus with all of lodash. So this seems to be the best bang for buck. If you're just maybe you just have a couple of these, this is pretty nice. It's just modularized and it's a lot easier to view. So I think that you can see the value of visualization with your bundles right now. It just makes it a lot easier to kind of hone in and get a nice little mental model of what's going on under the hood here instead of just size, you know, raw size output. And I think this is fantastic. But what I want to show you now is the thing that I said that I would address in the beginning of the video where I said, OK, remember that UUID it brings in stringify, brings in range.js and all this stuff. Well, where do those come from and do we actually need those? Is this exported improperly? This is something that you can do that's kind of cool. If it's a well-made package, you can go to their GitHub repository and I invite you to do this early in your career or or later, you know, if you're in my position and, you know, it's never too late to learn is really what I'm saying. But you should go and look at packages and try to dig in and see if they follow some best practices and you can find your way there. So what I want to show is if we go to their GitHub for UUID, we go to the source folder and that's normally where their code is going to be. Right. We can look down here and we'll see that there is a V4.js. What I want to point out first is that there's this index.js. If we go to that, that's the common most entry point that would let you know that you could destruct variables. And this might be a little bit weird to you if you've never built this type of library before, but this is a pretty normal practice to say each of these files has a default export. And then we're saying take that, take that default and export it as a named variable. So what I want to do is this is a neat little GitHub feature. You can click this and see where it's used. They have a test for it, which is pretty cool. And then in this source V4, you know, this is probably a little bit small for you. I'm sorry. I can bump that up a bit. I'm going to go to the source V4 function, jump into here, and then we can see the actual function, which is really neat. It's pretty lean to randomize this, but it does rely on two packages, rng and stringify. Let's go back to here, stringify, rng. Looking familiar? All right. What about validate? What about regex? Okay. Well, go back into here. We haven't gone into those yet. Sorry, I had a weird browser hiccup there where my highlight wouldn't work and I had to hard refresh. So if we go to rng or stringify, let's start here, and then we'll say, okay, well, I just want to see the source rng, right? And then if I open that, we can see that it imports this crypto package. Okay. And you can kind of just keep going, you know, infinitely here. But in this case, I want to come back here. I want to go to stringify. I just want to check this out. Oops, did I go to the source of stringify? It should actually be that big. Yeah, it is. Cool. And then up to the top, here's this validate. Okay. You can keep going. I'm not going to get that crazy. But here finally is regex. That's where we'll stop. So you could follow the trail to see, oh, well, now I know that v4 is actually directly importing these. And so that does make sense why they came along for the ride. So the last thing I want to show you here before we wrap this up is how you can make it to where your bundle analyzer isn't running every single time. Because that was pretty annoying for me to figure out the very first time. So if you come over here to \u2011\u2011 well, let's just shut this down for now. If we come into our code and we go to our package JSON, what we can do is for this stats function, let's say that's the one I want to run it. And if you don't understand the problem, actually, real quick, if I do npm run build, like say this is what my server runs, it's still going to start up that webpack bundle analyzer. It doesn't distinguish it, which is kind of annoying at first. So what I want to do is come over here and say I'm going to make up like an environment variable. This is the way I do it. There's other ways to do it. I'm going to make a stats environment variable. Can't talk. And that's going to be set to server. All right? Now with server, if I come over here to my webpack config, what that will allow me to do is this actually takes an object. And there is a setting here called analyzer mode. Oops. Analyzer mode. Oh, look at the nice descriptions here. Thank you for whoever built this package. And then from there, what I can say is process.env.stats. And then we'll say let's set it to that. But if that doesn't exist, we will set it to disabled. And that's pretty oh, that's cool. Look at that. Is this built on TypeScript? Anyways, nice. So they give us all the options here. So you can see there's a static, server, a JSON, and a disabled. And so that's why here in the package JSON, I'm setting it to server because that's the default. You could just do static and that will put it out to a browser file, an HTML file you can just open if you prefer that. Sometimes that's nice. But here, especially for archival purposes, here what we're doing is we're saying if that's passed in, run it. Otherwise, disable this plugin. Now if we go back and do npm run build, it will not start that server up as you can see. And that's really cool. And then if we do npm run stats, it will. And come back over here, and there we go. So yeah, I think visualizers are awesome. And I hope now that you've seen them, you will find some use for them in the near future. And hopefully they can level up your game. I will see you in the next video.", "metadata": {"title": "Know your Webpack bundle better with visualization", "url": "https://www.youtube.com/watch?v=oAgHZ9zlmaY"}}, {"page_content": "Hey everyone, I have a quick bug solution for you for Webpack Dev Server, currently not working correctly in Webpack 5. So a few viewers of my videos, thankfully, have brought it to my attention that it's currently not working for them. And it was working in all of my setup videos that I did it for, but what I ended up tracking it down to and realizing was that it's an issue with Browsers List. So when you have a Browsers List, it seems to break the live reloading, and I want to show you that bug real quick. So I'm just going to run my start command, which runs Webpack Dev Server, and then here, what I'll do is I'll bring this over here and try to reload this, the server. And normally you would see live reloading here, and just to show you real quick that that does indeed not work correctly, go to the styles file here, and we'll change this to purple real quick. And then switch back over, and you can see it didn't work at all, but if I reload it will work. So let me show the solution to this, and then I'll give you a little bit of information. I've made a repo for some of the projects that I've been working on during this Webpack thing, so I'll link that in the description as a reference code. But let me show you real quick some of the solutions that I've gotten into. So this Webpack config right here, this is just a CSS project, but in general, it's caused by the existence of this Browsers List RC being there. And I guess it's kind of funny, on my work projects I have Webpack 4 still, and the Browsers List and live reloading and all that stuff works great. But I guess I haven't been using Dev Server, or I haven't added a Browsers List with my Dev Server one on Webpack 5, so it just kind of slipped past me. Sorry about that. So what you can do here, let me actually show you, if you go down to this target variable, the first solution is just to set this to web. So web is the default target here if you don't include it at all, but when you have a Browsers List or you have it in package.json, either or will break it, it switches over to that Browsers List, but it doesn't seem to be doing it correctly because I think it's the new array functionality that is allowed in the target. But just to make this a quicker video without getting into too many details, I just want to show this working for the server restarting. So if I just do that, and I do restart, that will fix it. Let me just show you that. So I reload here, you can see it says live reloading enabled, and then if we were to go back to, of course, our styles and change this to purple, and then save and switch over, it's already reloaded. Now, the problem with this that I'll show you is that setting it that way makes it completely ignore the Browsers List, which is possibly not what you want. So if I were to do npm run build now, that will build my production build, and what I want to show is that if you open IE, which is one of the things our Browsers List is supporting here, so this is my IE and then the side by side of the inspector, and IE 11 in this case, so you can see that it has this syntax error here, and this is caused by the transpiling not working correctly. So in order to fix this, there's an overall solution that you can do here in Webpack Config, sorry, my brain's all over the place today, where this is the way that I ended up doing it, and this is a pretty decent fix for now. It works for me, and then you can see if you can come up with something that might work better for your situation, but I think this is okay for now. So what I do is I create a target variable that's just like the mode one here, and then I do a check for production being the node environment, and however you want to set your environment variables, that'll work, and then if it is production, we're going to point to Browsers List as the target. Otherwise, we'll set it to web. So what that will do is when we're in development, we don't really need the fallbacks or anything like that. We're probably debbing on Chrome or Firefox or our latest browser, and so we're fine with dev server, and then when it actually builds production, it'll point it to Browsers List properly. So let me show that real quick, but what I'll need to do here is remove that and then put that back in, and then if I run a build real quick, come back over here to IE. Oh, that's so annoying that I have it split like that. If I reload here, you will see that it takes a second, but then it actually does run all of the transpiled code, and we're not going to have live reloading or anything like that here, but it's just kind of like a minor sacrifice. You're probably going to be doing all of that live reloading checking in your actual Chrome browser. So in this one, with this setting, just to finally tie this all together, I could do npm start, and I'll show that if we have the local host 8080 running here, we do have live reloading enabled still, and that's all done just as a final little reference here. The package JSON, I have it set to, if you haven't seen it from my other videos, node environment equals production webpack, and then when I am running start, that does webpack serve, and so that's why I'm manually setting production, and then that will build it out using the Browsers List. So that's the fix in general, and there's an issue here that you'll want to take a look at. I'll link this in the description as well. It's already closed, and they're planning to merge it in, and the last mention here was someone said, is there any update on this bug 14 days ago, and they said you can try it in beta, but they're working on a release coming up soon. So hopefully that'll be fixed soon. I thought maybe I wouldn't even need to make this video, but I noticed that they also said that they were going to merge the fix back in November somewhere here, so I figured just in case it takes too long, I'll make this quick video, and hopefully that will make Webpack 5 still usable for you for the time being, but I imagine that fix will come pretty quickly. So finally I have the repo here just so you can see, and this will be true for, I'll link this on my other videos, but this one is the SAS post CSS branch, which is what I'll link to, and each branch is a different Webpack configuration. So I've got a TypeScript one and a main one, et cetera. So if you want to come into here and look at the setup that I just showed, you can use this as a reference. So hopefully that solution works for you, and I'm sorry about missing that, but another day in the life of a web developer, right? So I'll see you on the next one.", "metadata": {"title": "Solution for Webpack 5 Dev Server Not Live Reloading", "url": "https://www.youtube.com/watch?v=lNkVndKCum8"}}, {"page_content": "Welcome to Swashbuckling with Code, I am Jimmy Cleveland, and today we are going to uncover the arcane mystery that is polyfills. Now you may have run into a situation where older browsers are throwing errors for newish JavaScript methods such as Object.values or Array.includes, and you're wondering, why isn't Babel preset env taking care of this like I expect it to? Or you may be unaware that this is even happening in your codebase and that you need to take extra steps in order to transpile old methods. And that's what polyfills essentially are, it's a community-written code that's written to an older spec of JavaScript for older browsers that is made to support newer and upcoming features that those browsers do not yet support. Now just know that this is a little bit more complicated of a setup, and it took me a fair amount of time when I was researching it to figure out the proper ways to do it, so I'm just hoping to pass on some of that knowledge to people that are in the same position that I was. I'm going to be starting from a basic webpack setup with Babel and preset env. If you're less familiar with that, I have a video going into more detail on how to set that up that you can check out in the notification or in the description. I'm going to show you some different options for polyfills, and at the end I'll show you a cheat code once you understand what's going on a little bit better. But otherwise I think it'll be worthwhile to you to stick around and check out the video so you can end up with a better understanding of how to accomplish Babel polyfills in webpack. Let's start out with a quick overview of the project. Now I'm going to have a link in the description for some reference code on GitHub in case you want to check that out. But to start into here, just so that you know, we have in our dev dependencies webpack, webpack CLI, we've got our Babel core, Babel preset, and Babel loader, the standard culprits. Now I've also got some scripts, and the main ones that we're going to look at right now is just build and build dev, probably just build but we'll see. And that's just going to, in production mode, run webpack and do a minified version of it, because we're going to take a look at our bundle size all the way through, since that is an important habit to be getting into. Okay, so next, webpack config, pretty straightforward. You might have seen from my other videos, we have the mode being dynamically set since to the node env. And then we're looking at all our JavaScript files, we're excluding node modules, and we're running Babel loader on them. And we have some source maps, nothing crazy there. Okay, then you have an index.js. That's pretty simple. I've kept it lean, just for this demo purpose. What we're doing is we're creating an object of a recipe. And then I'm going to show an object spread syntax that is not supported in IE 11, just to show this whole process kicking off. And this is not a method. So normally, this will polyfill, but I'm gonna show you a little gotcha that happens without a browser's list right now. But the last file, before getting into that, is just the index.html. And all it's doing is loading in our script, main.js, and running that. Okay, now if we jump over to our terminal, we can do npm run build. And you'll see that it builds successfully, just so that you know. And the 881 bytes is what we want to pay attention to. We want to keep an eye on this, just so we can see that size is going to be a factor as this process continues. And it's a good habit to always be looking at that. If you're on Linux or Mac, you can do ls-lh for longlist human readable, and then look at the dist folder, since that's our output folder here, and you can see this 881 bytes. If you're on Windows, I think you can use the dir command, but I'm not positive about that. So kicking on over here to IE, I've already loaded this once, but if I reload, you can see that we're getting a syntax error on main.js 1,4. Alright, well, let's take a quick look at our code here, and look at the main.js, and you can see 1 somewhere around here, 4, it's at the bottom here, it'll say line 1,4, I don't know if you can see that very well. But we're actually getting tripped up on an arrow function. And that's interesting, because Babel presetenv should be taking care of that, but this is the gotcha that I was talking about. What you want to do is make a new file called.browserslistrc, and then you can just put defaults in here. This is pretty weird, because if you're using Babel alone and not Webpack, I don't have this problem. It uses the browserslist defaults without having a browserslist file there, but it doesn't do that in Webpack, and I'm not sure why. But, okay, so no big deal, let's just put that there, and then if we run our build again, we're going to see a slightly different build size, 886 here versus 881, okay? And then if we were to go back to IE here, and we reload, we will see that the code actually runs here. And just a quick note on this, you can see it running, but if you do have access to IE 11, there's a weird little thing that they do where if you go, I went to emulation here in this little drop-down menu, and it defaults to 7, which are IE versions, and I do not know why that is. It confused me so much, because I'm not transpiling to IE 7, and I don't want to support that, but that's what it starts out as. So just a quick note there. Now, if we go back over to our code here, if we go to main.js, and let's actually format that just so that you can see it, list it out, you'll see there's a bunch of code that's been put in here pretty much to cover this function. Let's put it down here. There's this R function that we're doing for our object spread, and this is all minified and mangled, and that's why it only says R, but that's essentially what this is doing for us, and that's why that's allowing it to run. So that's just that gotcha for you real quick, and nothing crazy. It's just, yeah, it threw me for a loop the first time. I thought you should know about it, and we're going to need a browsers list moving forward, so there you go. Now, a pretty cool little trick here is that you can go into your terminal and do npx browsers list, and if you do that, it will actually read your config and tell you all the browsers you're supporting. So if you want a little sanity check there. Now, there is another little gotcha here that if you do this in just like a random directory or whatever, it's going to list out the browsers list defaults. So if you want to make sure that your browsers list config is working, try doing something like this, you know, IE 11 or whatever, and that's all we're targeting, and you'll see that that's all it prints out. Cool? Okay. So that's all there is to that. Just wanted to show you that. So we're just going to leave defaults. We don't need anything custom for this one, but, you know, that's a whole other topic. So next what I'm going to do here, I am going to add a method that I know is not going to be supported here. So what I'll do is I will make another console.log, okay? And I'm just going to put es8 object.values example. I just happen to know it comes from es8 here. And then we'll just do object.values, run that method on our newly created thing, the gauntlets recipe here, okay? And so now when I run npm build, where's that? You'll see that we get 994 bytes, so it's going up a little bit in size just because we added those files. But then if we kick on over to IE, I have these windows split, it's really annoying, but it's a nightmare to deal with there in Spectre otherwise. So if I reload this, we're going to get a new error, and it says object doesn't support property or method values. And that's unfortunate, and that's because this is actually a method that requires a polyfill. So let me show you the first way to fix that, and then I'll kind of explain why you need to do this. So if we jump back over to our terminal, what you're going to want to do is npm i dash s for save. We don't want a development save dependencies, we want regular dependencies here. And then we're going to do core dash js, and we can just do the newest version. That's what I'm going to do here. And then what we can do is pop on over to our code, and at the top here, we know that we need this specific method. So we can actually just import it from core js. So we can do core js, and then it's going to be slash modules, and then it's going to be es, and there's even es next in here if you're using some future proposal stuff, just so you know. But you can do es, and then we're looking for the object. It's really nice how they've written this out. And then from there, what object are we looking for? Well, it's the values method, right? Okay. So we're just straight up importing that. And then we will npm run build. And you can see we now have 9.13 KB. We went from 944 bytes to 913 KB. It's a pretty significant jump for something so small. You might be surprised at that. So then we go back over here to IE, and from here, I will reload, and our code should work. I don't know why it takes a while, but it does. Cool. So there it is working great. You know, if you're curious about Chrome, it's also working, and you can see this 9.3 KB. So yeah, we were getting close to 1,000 bytes, and now we're at, you know, over 9,000 bytes. So hopefully that illustrates to you a little bit of the why or clues you into that. Because a lot of people, when they set up preset env, I know that I was one of them, from Babel or Babel, whatever your preference of pronunciation. It seems like it should just do all the things, right? Like it targets the default browsers that it decides it's going to, and then it transpiles all your code to old JS.", "metadata": {"title": "How to get polyfills with Babel 7 and Webpack", "url": "https://www.youtube.com/watch?v=YXtQms2msZQ"}}, {"page_content": "And, you know, then you go to run it and it doesn't work, and it's very confusing. And that's because they're opting out of that as the default, because there is a lot of file size increase that's going to happen. This is just one method. Imagine if you were using a bunch of methods. It can get pretty crazy, and you're going to see that. So the reason is the one of the reasons, at least, I think it's the main one, is that the size can get nuts, and they want you to have to opt into that so you aren't just exploding, you know, your users' download sizes. All right, so that was the leanest way to accomplish what we want. Let me show you another example to kind of build on this, though. Now, if you happen to want to do some async await, for example, this is kind of a strange one. It's different than a lot of the other things that you have to do, because normally you just import, you know, whatever method that you need from core.js modules, and you'll be good to go. But in this case, what I'm going to show you is that I just taken the example from MDN, where they just wrote a quick async function here. It's going to await this resolve that creates a promise, does a set timeout and all that nonsense, and then it calls a sync call. Okay, so we're just trying to get some async await funness in here. Now, let's pop back over to the terminal once again. We're always popping. I don't know why it's pop. I just like it. And then we're going to run a build. And you know, 9.84 KB, not a huge increase for what we're doing. But then let's reload this. So yeah, regenerator runtime is undefined. What a weird error. I've gotten this in the past, just like trying to do NPM installs and like what on earth is that? You know, once upon a time when I didn't know what it is, and now I do. So let me show you that. So we're gonna want to do here is you're going to want to install. And this is going to be saved as well. And the reason is because these are actually getting bundled into your final output. That's why these are saved and not dev dependencies. So you're going to want to do regenerator runtime. All right. While it's installing, well, it's already done. It's pretty fast. We'll go back over to our code here. And at the top here, you're going to import regenerator runtime and it's slash runtime here. It's kind of weird. All right. One more time. Run a build. Let's go back to IE. We'll reload this here. And this time it should work. Oh, no, it doesn't work. That's right, because we need promise as well. I'll add that and I'll then I'll show you the code. So in this case, we actually already have the package we need. All we need to do is say import and then we're going to do core JS modules. Yes, dot promise. It's pretty straightforward, right? And notice that our I almost forgot our bytes here. 16 KB. We are up and climbing with all these things that we're importing. Now we're all the way up to 26 KB. So you can see how adding one feature after another is starting to bloat up our builds. And that's just something you have to be aware of. You know, you want to start early paying attention to that because it'll sneak up on you. Okay, there you go. Boom, calling and resolved. Isn't that awesome? So we've got it working now. And let's take a look at our code, the output code here. So if we go to our main JS, who is getting nutty, I might have to build dev on this one. I don't know if this is going to work quite right. Otherwise. Yeah, let's do that. Let's do that. So I'm going to do NPM run build dash dev just so it's a little more readable. And that's you can see the difference here between running production minified. You've never never looked at that. And running a development build. Whoo, big old difference there. Alright, so go back to main JS. And I guess I need to close that because I formatted it. So wants to save me for myself, I guess. And here's what's interesting. There should be a async generator right here. And you we don't need to get too nuts into this. It's just from what I've learned is that a sync way is not itself. I don't know I'm saying async, async away, you can say it either way, I guess. Async away is not built on generators like in the actual way that it is in the modern JavaScript versions. But the way that they transpile it is through generators actually. And so that's why you need that regenerator runtime, because that adds all of the generator fallback code and you need that and then it's still using promises. So you need the promises as well. And that's why we need all that stuff. Whoo. Okay. So yeah, so this is great. And it's kind of cool that it's lean. You know, we just have them at our entry point right here. We could if we only use it in one file, we could import them there. Or we could import whatever ones we want here at the root. But it's gonna get pretty hard to maintain this and really annoying to constantly do that back and forth. And so we've got some other options for accomplishing this. So the first thing that we could do is if we we want to keep our regenerator runtime, but let's say we're not worried about all of the different methods that we don't want to import them individually, we're just going to import all of core j s. Let's see what that looks like. Doing a real naive move here. 176 k B. Yeah. And that was you know, 120 was from the dev. This is this is minified. So 26 k B. We've jumped all the way up to 176 k B. That's a pretty good jump there. So that doesn't seem like the option that we want, because we don't want to be super lazy. I guess we could and just fill all the things. But that's getting a bit wild. And I think we should be a little more respectful to our users. This is where Babel can start having our back. So if we go to the Babel RC file, and this is going to be a little bit weird, but you actually want to put a another set of array brackets here. This is just how the syntax works. Because we want to add a config object here now. And so this config object is going to have what I'm going to do is I'm going to throw debug true on because I think this is a cool little hack you can do to get some nice output. But the thing that we're wanting here is use built ins. And we're wanting the entry property this time. Okay, so let's run that. npm run build. We got a bunch of output and we got some errors. Okay. So this is a lot of stuff. Let me actually. Okay, so coming up to the top, they actually give us a clue here at the top of what our error is going to be caused by in this situation. Let's say we noticed that you're using use built ins option without declaring a core js version. Now they assume so if I didn't install core j s, this would work at two because they assume two, but three is a little bit better for various reasons. It's a little more modularized modularized as far as I've read, and we're using that newer version. Okay. And so what we need to do is go back to our code and put this simple little change and say, Okay, core j s is at three. And this is a JSON. So Oh, God, I don't have that anymore. core j s. There you go. So we just need to set it to whatever version that we have installed. And if you don't know, you just go into your dependencies here. And here you go. So you can just set it to all of three, I think you can set it to the exact version as well. But I just do it as three there. Okay, let's try and run that again. And then we'll look at our output again. But the camera on the build, you can see as we're doing this, that's why it's getting all of these errors here is it couldn't resolve from two. So 153 kb. Well, that's not as small as we had before, unfortunately. But it is a little bit smaller than let's see if we can find that old one here is before that error. 176 kb that we had before. And what's essentially happened here, as far as I understand, because this is not my preferred way of doing this. But when you use the entry, what it's going to do is it's going to look at your your browsers list setup or whatever your target configs are. And it's going to polyfill for all of the things that it would need from that. So it's taking that core j s import that we had, and then it's going to output all of that, all the different various polyfills for well, let's look npx browsers list for every one of these browsers that it needs to support. But there is a better way that we can do this with this really cool cheat code feature that I'm going to show you here. This is what I usually use in my setups. And if you've if you're used to this in the past, or you come up in the docs with it, let me actually show you this before I get into this. It used to be called Babel polyfill, there was this plugin at Babel slash polyfill. And that was the way that you used to do it. And that's what I'm used to. But now, as of Babel 740, it says this package has been deprecated in favor of directly including core j s slash stable, regenerator, runtime, etc, as needed, and then it shows that. So you could, you know, do just core j s or slash stable here. So just just so that you know, this is the new best practice. And I think that it was mostly because they do not support proposals anymore. And I think they used to and core j s.\n\ncorejs3 did some cool stuff when they upgraded from two and the upgrade path wasn't straightforward. So they they decided to just do it this way for support. So coming back over to here in our config, what we can do is go to our Babel RC. And here's our little cheat code here. What we're going to do is change this to usage. And now when you do usage, you actually do not want to import over here in index js. You don't want to import any of these things anymore. Okay. And then if we go back and do npm run build, boom, pretty cool. So now look at that, we're back down to 27, four kb. All right. That's pretty awesome. So what this has done, this is the reason that I'm doing debug here is that this really nice thing will tell you, this is the plugins that are just being used, you can kind of skip that for now. But it's nice to know. And the main part that I'm looking at here is using polyfills with usage option. I don't know why that was hard to say usage option. And then here, it tells you the file that it found some methods added following core j s polyfills. And then here you can see defined property to string values and got our promise, and then some web timers. So it found all the things that it felt like it needed, and it polyfilled them. So yeah, we're still down quite a bit, especially compared to the 170 kb. So I think that this is a pretty reasonable approach. And it's pretty cool that it just does it for you. So why it's called usage is it actually looks at your usage of each thing, pretty straightforward. But it was a bit confusing to me when I first read it at the entry is saying, Hey, where's my where's the entry point here, we're going to import them there. And I'm gonna look for that. But usage is a fancy one that will go and look at each of your things. Well, actually, let me show you this pretty cool thing real quick. So if I were to create a new file, and we'll call it includes example, j s, not the greatest name, we're going to export default includes or actually, we'll do a function includes example, that is going to take in two arguments is going to take in an array, and then like a target that you're looking for. All right. And then we'll just console dot log pretty straightforward, our dot includes since that is a newer method. And we'll say does it include the target? All right, come back over to here, in our index j s. And let's import that. So we're going to import. And then we can call it whatever we want. But we'll call it includes example, just to stick with it. From dot slash includes example. And then we're just going to run that immediately. So we'll say, let's call includes example. And we're gonna write an array on the fly here. And I'll just pass it, you know, like a, b, c, pretty boring stuff. And then we'll say, does this contain B? All right. So then we'll go back to here and we'll run it. You're gonna see something pretty sweet. Now when we look at the using polyfills with usage option, you can see that it looked in the index j s and found the same things. And then it went over here. And it said, Oh, well, I added these polyfills, radar includes and string dot includes here. Pretty cool, right? So it's going into each file, and it's telling you, hey, I found this method in this file. So I went in ahead and I added that for you. Pretty cool. So let's see if that runs in IE. Now, if we have backward support, we should see that at the top here. True, it did include it. All right. And this whole usage thing, I believe that this is a might be specific to webpacker bundlers, but I'm not sure. But they say in their docs that it takes advantage of the fact that a bundler is not going to load the same polyfill multiple times. And so that's why they can do that. And it's pretty sweet, because otherwise, you know, if you had the same method in a bunch of different files, that those might get duplicated every time it needs to polyfill them. So this is neat. And it's really cool little cheat code here that I like to call it, or you just throw that in and it goes and it looks for old polyfills and it bundles them all together. All right. And did we check our size on that last one? Yeah, 29 kb. So we're up and climbing. So I hope that one, I just wanted to instill that habit of like looking at your bundle size is really good, really valuable. And I wish I was a lot more focused on that when I was newer as a developer. But it also is really good to understand why polyfills are included, because we started out in the bytes range of our code. And now we're we're up to 29 kb. And that's pretty insane. And we're only using a few methods, even with this awesome cheat code usage, you could see it could get pretty big pretty fast. Now if you just a little note, if you want to use like super cutting edge new features that aren't stable, and their proposal JavaScript features, there are some additional steps that you'll need to do. You can look that up in the Babel docs, but I'm not going to cover that today. All right, well, I think that covers it pretty well. Hopefully this is a little bit less magic to you. It's still gonna be magic. Of course, there's there's a lot going on here. But you can kind of get a glimpse into what's going on. And I think that's kind of fun. For me, it gives me a little bit less anxiety, especially when I see these errors, like cannot find regenerator runtime. And I'm like, what in the world is that and I have to go search about it. And now I know what it is and what it's used for. And I know that it's involved with a single weight, and maybe other things. And that's cool. And so just little by little, we start to kind of get do delving under the hood, we can see that core j s if you ever see that pop up, you now know what that's used for, for these polyfills and all that type of stuff and how Babel uses it. And I think that's pretty awesome. So I hope you walked away with some sweet learnings from all that. And I will catch you on the next video, hopefully.", "metadata": {"title": "How to get polyfills with Babel 7 and Webpack", "url": "https://www.youtube.com/watch?v=YXtQms2msZQ"}}, {"page_content": "Hello and welcome to Swashbuckling with Code, I'm Jimmy Cleveland, and this video is all about Parcel, which is a popular JavaScript bundling tool. Now before I get into a brief description of what Parcel is and what it can do for you, I want to acknowledge that this is a pretty lengthy video, as you've probably seen, and that might be daunting to some people, or you may just be wondering, you know, why should you spend your time on it. So I do want to start out by pointing out that I do have timestamps for this video, and they're going to be covering each of the steps of the build that I'm putting together. And the nature of the video is that I'm going to start from kind of a bare-bones approach, I'm going to put each piece of Parcel together with some really common setups, which I'll cover in just a moment of all the different things that we're going to go over. But at each of those phases, I'm going to show kind of what Parcel's doing for you, what magic it's doing under the hood, kind of comparing and contrasting that to other bundlers such as Webpack, which I've covered previously in a few videos. I also make commits throughout the video, and the final repository will be uploaded, and it'll be in the description, in case, you know, you are jumping around to any different timestamps, kind of choosing your own adventure, and you want to reference the code at that point. The end state of the repo will be at the very end of the video. So you might have heard of Parcel, and you might be wondering what it is. So I'll give a brief description here. It's a JavaScript bundling tool, which is very similar to something like Rollup or Webpack, you might consider it a competitor to those. And the thing that it does that stands out is its innovations in sort of magically doing things for you. They commonly call it a zero configuration bundler, which has some debate on whether it's actually a zero config or not. But for most people's setups, the Parcel team claims that there's no configuration required, which is pretty appealing when you're contrasting that to something like Webpack, which obviously requires a kind of legendary amount of configuration that's very daunting for people. Now, if you're not really familiar with any of those, I'll just say that it's a way to use sort of modern JavaScript and have transpiling benefits so that you can get kind of cross browser support. It's a way to do work with frameworks like Viewer, React, or Svelte, or any of those, as well as even supporting TypeScript. I think Parcel is a great fit for newer JavaScript developers in particular, new developers in general, because contrasting that to Webpack, I don't think they should spend a lot of time learning how to configure everything and get wild with all this configuration before they just focus on making things and getting things done and learning how to actually build things. Webpack to me is something that you kind of graduate to when you need more customization and more fine-grained control. That's just personally my experience with it. Parcel is also great for experienced developers. I like it a lot as a sort of prototyping tool. When an idea hasn't really proven itself to be worthy of working on for a long time, it's just so fast to set up and have a lot of conveniences and you can kind of just get going and start working, getting things done. But there are also teams that use it for enterprise-level apps, so I just want to throw that out there as well. So let me briefly just kind of go over the list of what we're going to cover in this. A lot of those will be broken up into the timestamps that I mentioned previously, and then we'll jump into the video. So as I said before, we're going to be setting up a minimal project from scratch with Parcel, so that's where we'll start, kind of what entry points you need, what are the minimum files you need to just kind of get going, and what that output looks like right away. Along the way, I'm going to be showing when Parcel can sort of magically find dependencies for us and add them to our Node modules and to our package JSON without any configuration or manual package installs, which is really awesome. And we'll be covering Vue, React, Svelte, TypeScript, modern JS features like conditional chaining and fallbacks for those, also using a browsers list to customize those fallbacks for cross-browser support, importing images in JavaScript, which is a lot of times something you have to set up, SAS, stylus, styled components, pug, and multiple entry points as well. And a final note is that this entire project is showing many different ways that you can set up Parcel. It's not necessarily meant to be a realistic app, but it is demoing it from the perspective of creating a web app, like a single page app or a multiple entry point app. So now that you're equipped with an overview of what the entire video is going to be covering, let's start coding. All right, let's kick this off by creating our directory for this new project. I'm just going to call it Parcel. We're going to cd into that directory and then I'm just going to open it in code, my editor of choice. Let me bring that down here. Okay, close that. And we have this empty project. So what I'm going to do first is I'm going to create a source directory and I'm going to create an index.html in there. And then while I'm at it, I'm also going to create an index.js file. Okay, you don't have to put this in source, it's just what I'm going to do to save myself some time down the road. In our JS file, we're going to do something really simple. We're just going to console.log and I'll just say is work and I'll save that. And then I'm going to go over here to HTML and I'll just use the bang.mp shortcut and come down here and we'll say parcel example is the title. And then in this content I'll just put h1 parcel example just so we can see that. And then I'm also going to point to that script. So this is the minimum necessary for parcel to run. You need an entry point, which is an HTML entry point that you're going to point it at, and then it also needs to, you know, load in a script of course. So from there we'll just say dot slash index.js since it's in the same directory there. And that'll be it. So the next thing I'm going to do is I'm going to jump back over to the terminal. And rather than installing this locally, what I'm going to do is I'm going to say npx and we can just do parcel bundler and then we'll point it at our index.html. So if you're not familiar, npx is a way to kind of download a single time this npm package and run it. So at this point it says, oh you know what that needs to be source index.html you silly goose. So that's good to know that that tells you that no entries were found. We'll run that and you can see that it has built and is already serving us this server, which is really nice. So I'll click that and go to it and there we go. I'm going to inspect this and you can see my console log is working. So pretty simple, but just to show that's how easy it is to set up, you know, very very minimal config. Now this is a server with hmr which is hot module replacement, but we do have to enable that, which we'll do in just a moment. For now I want to show you, if we come over here into our directory, you'll see that we have this dist folder and this cache folder now. Interesting, huh? So the dist is just the output as you would imagine, but one thing that you want to pay attention to, while this is the same index.html file for the most part, you can see that this script has automatically pointed it to the built version of our javascript, which is going to be right here. And this javascript file, this is our bundle, is actually has a ton of stuff in it now. If we were to search really quickly for console.log is work, you can see that's there, that's the only code that we have. And obviously this is a bit of scaffolding for, you know, the future and all the other things that it's going to do, so it's a lot bigger than just our minimal one. But that's the gist of it. So that's really cool that, you know, right off the bat this index.html thing just takes care of that for us. We don't need any sort of plugins or anything like that. It'll just output it and point it to all the right files that it has for its entry point. Oh, I also should point out that you get source maps right out of the bat, which we'll see like a little more featureful in a moment, but just check this out when you look at this console.log in our browser. We'll", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "look at this console.log in our browser. We'll bump that up a tiny bit more, I'm sure that's fine for now, but we'll probably want that in the future. This has this, where is it telling us? Oh, well, it's source index.js. Even though that's not the script that our server's, you know, loading, it's the source map telling us that. This is the actual full one. So that's pretty cool. So next we're going to enable HMR just to show that real quick. And I'll briefly talk about that. So this is our actual original index file, and just minus that for a moment. So here, in order to showcase that, what I'm going to do is I'm going to just add a simple little input field here, you know, type equals text or whatever doesn't matter, and just to kind of showcase the difference between hot module replacement and not. So HMR is sort of like live reloading, if you're familiar with that, where every time you save your document, you're going to, so it's commonly called hot reloading as well, by the way, HMR, but you know, with live reloading, every time you save the document is refreshed. And so the, that's great, but the problem with that compared to hot reloading is that you lose all of your kind of local app state or your app state in general. So where that's really useful is like, let's say you're kind of designing this component, and you're fiddling around with like some state that it takes a user a few clicks, or you're filling out a form or something like that. Every time you save, it's going to refresh that state. So I'm going to show that real quick. So we can show the comparison here. So right now, if I were to type, you know, whatever here in this silly, small little input, it's kind of small for you, but bear with me for a second, it's going to go away. What if I were to go and change my JavaScript in any way? So let's go, it's going to be hard to alt tab here, but let's go back to this index.js here. And then we'll just say, we'll change this to, it does indeed work. Now what's going to happen when I save this is that page is going to be reloaded really fast. Unfortunately, I can't tab to it fast enough to show you, I guess I could split it, but this, this little spinner will turn to an X just really briefly, but notice that our text is gone here. So just taking that away. So let's kind of show a contrast to that real quick. You know, it's probably worth showing, honestly. This should be good enough, even though it'll be hard to read here. So if I do this, and then I'm going to change this to whatever as well, as soon as I save that, see that blinks and then it goes away. So what we can do now, we're losing real estate here, is we can simply just in this script, in this entry point, we can say if module.hot, so it'll check for that, and then it'll say module.hot.except, there you go. And then when we save that, that's going to give us hot reloading. And so now, I don't believe we have to restart the server, but change things. We save, you'll see that this console was cleared. That's an HMR runtime, so that's a good indicator that it's working correctly. So now, if I type whatever in here, and then I also, you know, do some nonsense here, and I save, you'll see that my new log is there, but I didn't lose this state. And that's going to be true for like everything. What's really cool is like CSS will kind of be able to be injected. It uses like web sockets under the hood, but I'm not very knowledgeable about that, so I don't really want to speak to that. But yeah, you can think of it that way, that that's kind of like when you change your CSS and your dev tools, how the browser doesn't need to reload. Well, it's the same thing going to be with JavaScript and CSS now. The browser doesn't need to reload every time you're changing that, which is really neat. Now, let's actually install Parcel and run our scripts locally from some package.json stuff. So we're going to do, I guess we'll probably need an init, won't we? Did we already make a package? Nope, we didn't. So we'll do npm init dash y, just to skip all the questions, that's dash yes. And now I'm going to do npm i dash d, and we'll do the same thing, parcel bundler. So now we're just installing it locally, which is kind of the recommended way, you know, rather than relying on a global one. If you want to use the global one, that's fine, but typically you install it locally in your project so you can run all the commands. So now we'll pop back over to here, and we'll open our package.json right here. And in our package.json, we're not going to be doing any testing here, so I'm just going to make a script, and I'll make a dev script because that's what they do in the docs. Actually, you know what, that's going to bug me, so I'm going to make it start because it's just easier to type. Maybe I'll make both. And this one, all I have to do is run that same command that I ran at the beginning, just parcel and then point it at your entry point. Really simple and straightforward. Now we're going to run a build script as well at some point, and this parcel build index.html, that's all you do. So you're just going to tack on build onto the command, and that's going to build you a production version of your site, which is really sweet. And a quick note, you know, keep an eye on this parcel version that I'm using, because, you know, if you're watching this video in the future and it bumps and you have any sort of issues, typically that's the first place you want to look is make sure the versions are all the same. And I'll have a repo with this code up in the description of this video for those that, you know, want to reference it while following along, or it'll be the end state of the video basically. So if you just want to look at any of the code and see if you missed up any syntax or just want to reference it, it'll be there. Okay, so let's make sure our scripts run, right? Come back over to here, and the first thing I'm going to do is I'm going to do npm run build, and we can see we had no, you know, I did the same thing again. I don't know why I did that. Source. Source. The original docs have it in the root, and that was what was in my brain. Sorry. So npm run build, and voila! And it's pretty cool. It tells you how long it took to build, and the size of them right here. You'll notice that our bundle size is already 1.17 kb, which is actually probably a little bit bigger than webpack would be at this size, but I don't really think that has, you know, scalability problems to any extent. You know, I would keep an eye on that, but it's going to be, you know, as the app grows, it's going to need a lot of that code anyways. And then I'll do npm start. Start my server up, and there you go. We're back and running again. We can reload, and we can see everything is nice. Now something I want to show from that real briefly is if you go to our dist folder now, make this a little bit bigger, you'll see that here we have multiple files here. The same thing. If we go to index.html, it's only importing this one, but you'll see that there's this file, which looks a little bit different than before, right? And then there's this file, and each of them have their own map, and this is the one that we saw before. Well, that's because Parcel does not clean right out of the bat. It doesn't delete the dist folder every time you run, and it doesn't seem to have a command to do that from what I've seen. So, you know, you might want to add to your package.json, you know, whatever your operating system command for, like, let's say building or something you could do. You could do it on both, you know, rmrf dist or something like that. But the thing about that is, typically, it's not really that much of a problem because the server is only going to be running at one time. It's going to be running this one command, so there's not going to be that issue when you're actually deploying it. And if you're running it locally, you know, you can either delete it manually or you can put your own command for that. So I'm not going to do that. I just wanted to let you know about that. So for now, I'm just going to, you know, get rid of that. And I'm actually curious. I have the server running, so I wonder if I, like, save or something that's", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "wonder if I, like, save or something that's going to rebuild. It doesn't seem like it. I go to the index.html, save. Ah. Worth a try, worth a try, right? So let's restart that again. Built the bundle, reload the page, everything's working, and our dist is back to just having that single file, that single JavaScript file. So I think this is a pretty good time to set up a git repo and commit our changes real quick before we start doing some bundle stuff. And that'll actually help us track what parcel is changing in the package.json for us because it does that, and it's actually pretty neat, but, you know, a little magical. So we're going to do a.git ignore really simply, and we'll say node modules, of course, and we're actually going to ignore dist as well as.cache. Now, this.cache directory, I don't really know a ton about that other than it's what Parcel uses to keep the builds quick. So, you know, standard caching type stuff. I'm sure it's not standard. I'm sure it's very fancy, but you get the point. So then we'll go back over to the terminal here and git init, git add dash a, and git commit dash m, and we'll just make this, you know, initial, partial, parcel setup. I want to say parcel there so bad. So, you know, if you're using the the repo from the description, then you can go to look at any of the commits if you want to see that timestamp, but there's the name. So now that we have, you know, our git setup, so we have a fallback, a commit to fallback to, what I'm going to do is I'm actually going to do npm run build one more time just so that you have the data right in front of you. And just remember that this is this size. We'll come right back and look at it. 1.17 kb for our bundle. And let's compare this to webpack just to see. So we can actually just really quickly do webpack cli, and then we just say, okay, well, the mode is equal to production just to get that, you know, bundling normally. It does that by default, but it yells at you. So I'm going to add the flag. And here you can see this main.js is the bundle, and it says it's only 36 bytes. And let's actually look at the code just to see, you know, what it output here. Go to main.js. This is from webpack. Look how lean that is. It really just found, you know, that that was just a console log and nothing extra. So, you know, this isn't to hate on parcel or anything like that. Like, you know, you know, parcel 2 is coming out and has a bunch of advancements. This is webpack 5, so it's kind of the latest and greatest here. But as of right now, webpack is actually building a much leaner bundle just from this minimal example, which is interesting because a lot of people that do bundle comparisons, typically they're doing webpack 4 and parcel, but they show that parcels bundles are actually smaller and faster. So who knows? Everything changes at scale. I'm not trying to start a war between them or anything like that. I'm really just trying to, you know, give you the tools to show, okay, like, this is kind of how we can, you know, make sure to keep an eye on these things as we're progressing forward in the project and keep an eye on our bundle size. Okay, so I am going to wipe out that disk one more time because I don't care about any of that stuff right now. So some common confusion that comes up is that with, we are obviously building an app, you know, we're not building libraries right now, and a really common pattern for webpack and parcel is to build a single page app where you have the single entry point and then all of your routing is going to be done through JavaScript, whether that's React Router if you're using Router or any of the other frameworks ways of routing. A question that comes up a lot when I was doing webpack videos is, you know, how do you do multiple pages? Well, typically in a single page app that's going to be handled all through, you know, your JavaScript, but if you do want to do multiple entry points, you totally can. So I want to show that right off the bat. So in source, I'm going to make this folder now, a new folder here, and I'm going to name it just pages, and I'm going to move this index.html into that folder there, and I'm going to copy it. I think that'll maybe be slightly faster, and I'm going to rename this to about.html. And so in this about.html, well actually let's make a link to that just so we can go there really easily. So we'll do an a tag and then we'll just say slash about.html. Now this is an important thing. About us, or you know, whatever. I don't know why I picked that name. This is a very important thing. The dot html is required here. You're not going to get the pretty URLs from this, and I actually haven't figured out an easy way to do that with Parcel. There is a plugin that someone's made, but it didn't really have that many downloads, so I decided not to include it in the video. So if anyone knows how to handle this, I'm not really sure outside of, you know, on your server kind of hard setting that, but you know, obviously when you're running your dev server, you still have to have this. So it's kind of weird. If you don't know what I mean, I just mean that you can't type like this, which is commonly called a pretty URL. So we have to include the dot html. That's the point. And if we go over to our about html, let's just change this to the h1 to be, you know, about us, and you know, it'll have an a tag that goes back to slash index dot html, and then that will just say home. They're both going to import the same script for right now, just to get it running. And I'll get rid of that input, because we don't really need that input anymore, do we? Oh, and I almost forgot, we will need to actually move the directory up one, because our index.js, we put this in the pages folder, and we need to go up one. Very easy to forget that. I think that should be good. So let's npm start, start the server up. Let's see. Oh, you know what, we need to change our script. Haha, it's not good. So when we come into package.json, you know, we told it it's in source index html as the entry point. We want multiple entry points now, right? So we need to say source pages slash star. So we can use this pattern to say anything, start on html. We can say anything here that says source pages start on html, any of the html files and pages. Pages do the same thing, star dot html. Let's try that again. And that's how I built. So we'll come over here, we'll reload the page. You can see our console log still reporting. And now we have this about us page, which is kind of weird, because we went to the root. I've had this a couple of times, and it's pretty strange. Now we're at index html, it's like if you go to the root, it just like finds the first page in there, I guess. But now we're going between index html and about us. Let me see if we go to the root again, what it does. Yeah, I guess it just finds the first page. That's interesting. So I'm not going to get into fixing that on the server. I just want to show, you know, multiple entry points pretty easily. And the thing that you'll want to see right here is when we go to the about us page, it has the exact same JavaScript, right? And most of the time when you're doing multiple entry points, that's not what you want. So we'll just really briefly, you know, make another file here and source new file and do about.js console.log. The about page. Okay, go back over here. And that should have already reloaded for us. Oh, it didn't. Oh, we need to change our entry. I'm making all sorts of mistakes today. Go to about html. And then here we want to change our index to be about.js. Come back over here and it is already live reloaded for us. In this case, it's not hot reloading because I didn't put that hot tag. Keep that in mind. So that's really easy, right? Multiple entry points that are using their own JavaScript files. You'll see some crazy stuff that we can do with that in just a bit. Let's make another commit super fast. I'm just going to add all this stuff and then we'll say add multiple entry points. That's where we're at. The next thing I want to show is really cool. It is that you can have modern JavaScript features without any configuration as well. So let's do this. We're going to make an object here. Then in that object, I'm just going", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "object here. Then in that object, I'm just going to make up some properties. I'll say A is for Apple Crisp, the light, and then B is going to be butter cream, and C is actually going to be a nested object for my purposes. So then we'll just chain it on. Cheese Danish. Beautiful. Then we're going to console log that. So first, we'll just log the normal, .c,.cd. So we're doing a regular chain. These are properties that all exist. I'm not to the super features yet. If we go back to home, you'll see, I'm just going to get rid of this log because it's silly, but you can see we're logging out. Cheese Danish. Not surprising. But if you go into dist and we're going to look at the source file here, and let's take a look at our console.logs. Can't type. You'll see that the code is very normal. Keep an eye on this. This console log right here, object C.cd, nothing fancy, no fancy transpiling or anything. Now, if we go back to, and I'm going to get rid of this one just to keep it clear. If we go back here and let's say we want to log that out, but we also wanted to log out something that did not exist. Let's say object.f.fa or something. I don't know why the letters I chose are what they are, but they are what they are. Now, I'm going to do this cool thing called conditional chaining of this question mark. I'll explain this in just a moment if you haven't seen this before. So what this is going to do is normally when we, I guess I should have showed that first. Normally, when we try to access this, we're going to get an error. I will show it first, why not? Because this property doesn't exist and we're trying to access something on undefined, which is obviously a big JavaScript no-no. But what this conditional operator here does is it falls back safely, and it says, does this exist? Okay, then does this exist? If anything in that chain doesn't, then it will just come back as undefined. So first, let's show the error. Uncaught type error cannot read property fa of undefined. Then I'm going to go back to having conditional there, and look at that. We got a safe fallback, undefined. Now, let me show you why I was having you glimpse that before in here. Notice that now, we're in our bundle, and this console log is pretty crazy. So this is transpiling an action. It's taking modern JavaScript features and using Babel, and making some cross-browser safe, browsers that don't have this feature yet, just without any configuration at all. That's really nice. I got to hand it to them for that one. That's really cool. Just because I am a sucker for being thorough, what I'm going to do is I'm going to copy-paste this, because you might not know that this works just fine in Chrome. Just paste that in and run the code. It works fine, right? What it's doing this for is something like IE, which dreadfully open. Gosh, every single time. Go away, so bad. I'm going to go to about blank, so I don't have to look at that. Okay, then how do I do this again? It's been so long. F12, developer tools. If you have to deal with this every day, I'm very sorry. I can paste this code in here, run it, and you can see that we get this syntax error when we try to paste that code, right? Now, if we go back to... I know I say it right, like you can answer me. We go back to this, and we... Oh, no. There we go again. So much pain. Okay, there we go. So we're running our server, which is running our transpiled code, and that was the point I was trying to show, is that this code runs correctly in IE11. So like I said, no configuration, and you've got some awesome cross-browser support. Now I'll purge that from my memory. So because I'm going to make some changes right here, I'm going to do one more commit, because I want you to see the diff here. So I'm just going to say show modern JS transpiling for that checkpoint. Okay, so for a quick reference, our package JSON here just has this one dev dependency that we've manually installed, the parcel bundler, okay? Now what we're going to do is we're going to add some SAS just to get straight to it. So in my source, I'm going to add a new folder. I'm going to say that this is a styles folder, why not? And I'm going to add a new file, and then I'm going to call this index.scss. And to save you some time, I will paste this in. So what we have in here is we're just using this main BG here with bisque is the color, lovely color, and then we're going to combine that with chocolate for a delicacy to remember. Now this chocolate is using a SAS variable just to show that we can. I just want to point out that you probably wouldn't have a lot of value from SAS variables when you have CSS variables, but you might still like them. So, you know, you do you. And then we also have some nesting here that's going on. Just, you know, the usual SAS stuff that you'd like. Now what I want to show with this is that I'm going to save this file, but it hasn't been imported yet at all, okay? So the only file change we have is this. But what I will do is I will go into, go away, I'll go into my index.js file, and we're going to import that in JavaScript. So we're just going to import, and then this is typically how you do it. You're going to go to styles and then index, oops, index.scss. I don't know why VS Code could never autocomplete CSS for me. I'm going to save that. And you saw on the left here, maybe, that something changed, right? And if we go over to this, a few things have actually changed. And I wish I could have Alt-Tabbed to show you fast enough, but behind the scenes, the server here, went and ran some stuff real quick, and actually went and downloaded SAS for us, added it to our package.json. Isn't that wild? So let's see if that did anything. Whoa, right? Pretty cool. So this is our page as before, and it's got all these styles already there. If we inspect this, we can see, this might be a little big for me, but for your sake, I'll bear with it. But the body, and this Chrome does this cool thing now where it like shows us flex box. It's kind of hard to see that you're hovering over it. So I've added flex for demonstration purposes to this. And you can see here that the background has been set there, and it's already like, you know, turned that SCSS into CSS. And that's why we just have this color chocolate here. We're using a CSS variable, but this was a SAS variable and it's been converted. Even though we're looking at the CSS, notice that it says index SCSS. And that's what I was pointing out before is, it has source maps built in without any special config property, which isn't that hard to set up in Webpack or anything like that, but it's kind of cool that it just comes right out the bat, right out the box. I mean, so here we can see the original color was set to this text color and all that good stuff. Not gonna go over source maps too much here. You know, it's just a way to see the original code if you aren't familiar with that so that we can troubleshoot easily in our own code. So it was that easy. We didn't even have to install SAS. I just made a SAS file and imported it and it worked. I'll also show you really briefly that say, you didn't want to install it or import it in your JavaScript. You can actually do the same thing in your index HTML with a link tag here. So if we did, you know, link CSS, we could then point to a.slash, where are we at? ..slash styles and then index.css. And actually let me comment that out just so you can see there's no styles. Come back here, come back in, and you've got styles again. Pretty cool, right? And I guess I could have just showed you that the link is here, but check this out. See how that name is different? It's doing all of the stuff behind the scenes for us. It's automatically building all those links for us and saying, okay, yeah, you imported this in the HTML file. And I know that when I get output that HTML file, I need to reconnect that up to the bundled version, which is gonna be minified in a production environment. So there's a lot of awesome magic behind the scenes going on that I wanted to point out. So I'm gonna put that back where it was. So I would prefer to do it here, but just know you can do that. Now, while all of those magical things do come with it that", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "all of those magical things do come with it that we've shown, one thing that it does not start with is browser prefixes. So if you go over to this, I was gonna show Flexbox to show that, but actually now that I think about it, I think that Flexbox might be supported in a wide enough browsers that the default, can I use browser list is going to be a little bit more is going to not auto prefix it. So to make sure, let's use a super modern feature here. So I'm gonna go into my index SAS file and for the H1, I'll add this line, these three lines, I should say, I'll put a break here. So we're gonna do a fun effect here and we're using this background clip, which is very modern. And to show you that actually, we can go to can I use here and there's this background clip text just to show that. And then when you hover over Chrome, you can see, whoops, right here. You can see it is supported, but it's kind of tiny for you, only with the dash webkit prefix. That's perfect, we need a vendor prefix to test that. And you'll see when we come over to our styles here that this doesn't really quite look right, or maybe you like that, but it's not what I'm intending. So let's set up some PostCSS to get that working. So I'll start by creating a new file and say postcss.config.js. This is where you normally dump all of your PostCSS config stuff, of course. And I'm gonna do module.exports equals object and we're gonna put a plugins key here. And this is just a pretty normal thing if you set up PostCSS is one of the main ones that you usually do. And I like to do PostCSS preset-env, which if you're familiar with auto-prefixer, this actually comes with it. It's a bunch of presets that they recommend. Now, when I save that, this is one of those times where nothing magical has really happened here. We still just have parcel, bundler and sass as our changes and nothing new besides that. I guess something that I kind of don't like here is while all this stuff is really magical and cool that it's auto doing all this stuff for us, right now we're trying to require something that the PostCSS preset-env and because we're so used to everything kind of handling it for us, it's kind of weird when we don't really get any sort of feedback here that that thing doesn't exist. It might be a lot to ask for though. So, whatever, you figure it out. So I'm gonna add that real quick. I'll do PostCSS preset-env. Now I'm not gonna actually add PostCSS, which would normally have to combine with it. And before I install that, I'm gonna show you that's because if you go to our node modules here, and I'll actually just do slash PostCSS, you'll see that we actually already have PostCSS. That just comes installed with parcel. And I've tested that out. It comes like with just plain old parcel, not any other additions to it. So they already have a bunch of stuff that they're including to kind of cover this, but they don't happen to have this preset. And I'm assuming that this is because, you know, bundle size, browser prefixes can add the bundle size. So maybe they opted to say that you should have to opt into that. So this is kind of the first sort of config that we're really having to do. And it's worth pointing out because there's a, it's a really hot topic. What is zero configuration in this world? You know, the parcel team has stated that, you know, they see it as, you know, the majority of use cases, not needing any configuration files consists of or accounts for zero config. And some people are absolute in that. And they're saying, no, if you have to do any config, it's not zero config. I don't really think it's that cut and dry. To me, you're setting up, you know, config for your own stuff. You're not having to configure, you know, right now, any of the Babel stuff or any of that stuff in this. I want to opt into kind of customizing that my own way. And I know parcel two is actually setting it up to where they're going to have a config file. So keep an eye out for that. So let's see, now that I've installed post-CSS preset ENV, if I just, oops, I just run start, we'll see if it does anything. Look at that, it just worked. Isn't that beautiful? So now we have this nice gradient behind our text. And if we scroll down here, we will see, oops, I'll be on the H1. You'll see that this linear gradient here, not the linear gradient, what am I thinking? The background clip, background clip added this vendor prefix for us, WebKit background clip. So that wasn't too hard, but let's take it one step further with the fact that on our body, we had this flex right here and it doesn't have a fallback for that. And maybe I want support for that. So what I'm going to do is also add a, let's go down to here. In the root, I'm going to add a.browserslistrc, okay? A dot is important, or you can do config file with JS. And I'm going to do last two versions, pretty standard here. I could do one or whatever, greater than 0.5%. I'm just kind of pulling these common numbers out of my head. And then IE11, that's the important part. So I'm going to save that. And then I'll come back over to here and we'll see if it worked. And you'll notice that that didn't do anything, okay? And so what you could do is you, or you might think is you could just like rerun the server. This is a common thing to see if it added that. And notice that, I just noticed my head might be in the way sometimes. Whoops, sorry. It looks like it's okay. Well, it wasn't in the way of that link, but move this over a bit. So this display flex still doesn't have any new WebKit properties. And I know that it should when it's trying to support IE11. So this brings me to something that's kind of a weird little quirk that I've found. It seems like saving this or saving any of like the entry points doesn't really get it to rebuild, but saving this post CSS config actually got it to rebuild for me. And check that out. I just saved that. I know you couldn't really see it, but I pressed Control S. And now I have all of these vendor prefixes and that'll just be that way from now on. It's like the caching is, might be a little too aggressive. It doesn't really know to check that unless you save post CSS config. So there's a little gotcha for you and a solution for it. So restarting the server isn't enough. You have to actually go and save the post CSS config file, which is weird because I added a browser's list file, you know, whatever. So let's top this section off by adding CSS modules because I had a little bit of a gotcha there too. And, you know, that's a common paradigm that people like to use. So let's show how to do it. Now with post CSS modules, what we're gonna do is I will add an additional H2 here just to get targeted. And then I'll say CSS module example. And then in my index.js, I'm just gonna be really silly and say, let's store the H2 as document.querySelector. We're just gonna grab an H2. And then we will say H2.classList.add. And, you know, normally I could add whatever I want here and show that that class was added just to make sure that, you know, we know it's working. And then what I'll do is I'll make a file that is called CSS modules.js or CSS. Let's call it modules.styles. And I'm just gonna make an H2, actually I'll make a class, I'll make a heading. And then I'll say Z32 and color is rosy brown. That's all I need. And then I will import that, but, you know, we import that as like styles or something that we wanna name it. And we'll go up, it's in this directory, isn't it? Styles slash module styles.css. And then I can just pass that class in here, styles.heading. Okay, now I'll just really briefly go over this if you're not familiar with it, you know, not the purpose of the video to explain every single thing in there, but really briefly, I can spend a moment. It's what you're doing here is you are making a regular CSS file, but with CSS modules, what happens is when you import it, you can actually access all of these different like properties on it. And you normally, you wouldn't do it in this way. This is a very silly way. It's just a quick way to demo it, but you would do it in like, let's say React, you know, you could import it and put it on your JSX, for example. And that will automatically hash the class name. So you don't have any scope conflicts", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "class name. So you don't have any scope conflicts and you can reuse the same class names over and over at like a component level scope. That's as much as I'm gonna go into it. But what I want to show here is that, you know, when I reload this, I just get undefined. It's a class name. So, you know, that's not that surprising. Can't automatically figure out every single thing we want to do. So I will npm i dash d post CSS modules. That's the plugin that you usually have to use for post CSS to use modules. That's a common way to do CSS modules. npm start, server backup. Saw it doing some module style stuff. Let's reload. And notice it didn't do anything. This is where the gotcha is gonna kick in. So the docs tell you that you need to go into post CSS config, and I'll actually show you this in the docs in just a moment, and say modules true. And that's all you need, right? Then when I reload here, it doesn't seem to have done anything. It doesn't update that. And if I restart the server, reload, still not doing anything. Sometimes you have to, like I said, you have to save this post CSS, which should have done it. There you go. One of the saves will trigger it. It's a lot easier to see when you have it in two separate windows, I'm sorry. And you'll see that you get this crazy error, post CSS eight for end users. And post CSS plugin, post CSS modules requires post CSS eight. It's a lot of saying post CSS. And I'll just show that in the docs so you know that I'm not crazy. If we go to CSS, what is it? Modules true. Oh, here it is. I don't know why I didn't find that when I searched it. Oh, because I had quotes around it. Duh. This is JSON. So yeah, modules true right here. Kinda tiny there. That's what they want you to have, but it actually breaks your stuff, unfortunately. And that's because it's not necessarily Parcel's fault here. Go back to that error so you can see while I'm talking about it. So the issue here, I've actually seen this on view forms for view three as well. Post CSS moved to post CSS eight, which was obviously a breaking change to move from seven. And a lot of the plugins that you install, like CSS modules by default are now paired with eight, but Parcel automatically installing post CSS for us installs seven. So I tried to manually install eight, but then it causes more problems with some of its backwards compatibility. It's a real nightmare. So the easiest way to get around this right now for me is to say npm i dash d and post CSS modules. What we got, really quickly, what we got when we installed modules was four. And we want version, you know, any three. So I'll do caret three at caret three. Okay. Now I'll do npm start again, and I've installed that. Let's see if it just works. I might have to save it again. And there you go. Look, I've got my color, my rosy brown. And then here's what you really wanna look at is this hashed class name. So once you know it, it's a really easy fix, but it was very annoying to figure out. Blah. So we've run into one of our first hiccups, obviously with sort of a zero config thing, but I don't really wanna hold that against you for that one, because like I said, Vue 3 has problems with it as well, though they do a bunch of auto-magical config stuff as well. It just seems to kind of be an ecosystem type thing where certain things are moving forward. And it would have been a lot easier, I think if I was, you know, in something where I'm installing every single thing, like I was in a web pack project, because I would actually be choosing to install post CSS and all my other stuff wouldn't rely on that different version, but not that big a deal in the end. So let's commit and move on from this one. We did a bunch of stuff here. We added a browser's list, and then we also did post CSS, and we added our Sass. We did all of that. So let's just say add Sass, post CSS, browser's list, CSS modules is too long of a commit name, but it's fine. There you go. So I think next ought to be TypeScript. I just want to show that my server is still indeed running. There you go. And coming on back to our code, what we're gonna do here is I'm going to change the index HTML to point to index.ts now. I'm gonna have to change... oh no, that one has its own, so I'll just change this one. And when I save that, it's going to get unhappy because that doesn't exist. So let me actually... I'll probably get mad either way, so I'll just save it. I'm gonna rename this to a TS file, and when I go into that TS file, you can see this is just VS Code. If you ever name something.ts, it's gonna automatically start giving you TypeScript hinting. But what we want to see is did it build? So we'll need to restart that because we changed some paths that didn't exist. That's fine. And look at that. It says installing TypeScript. Interesting, huh? And if we go to our package.json again, look at that. So it has now added TypeScript automatically for us. So if we go back over to our index.ts file, and I guess I should have showed that, you know, the server is actually running again here. We're still getting our cheese danish lovely console log. But one thing that's really cool is notice this little hint here. So it says property f does not exist. So it, you know, it's automatically detecting that in our object, and we're getting some very nice feedback. Lovely TypeScript. And this one, of course, does. This is, you know, something that you'd commonly deal with, you know, in the ecosystem. And then this error is just that CSS, whenever you import in TypeScript, it gets really mad unless you have type definitions for that. And there's a way to set that up, but I'm not gonna go over that. That's out of the scope of this video. But you'll notice something important here. There are these different errors in TypeScript, and particularly this one, and it's still built just fine. Hmm. Well, that's because parcel under the hood uses Babel to compile TypeScript and not the TypeScript compiler. And because of that, Babel essentially does not do type checking. The phrasing for that people debate. What it essentially means is that it's not gonna fail your build when types fail. It just, it's really just taking TypeScript and transpiling it to JavaScript and not doing any checks on the types at all. So this is hotly debated in the community in general for TypeScript, but particularly in parcel TypeScript. There's a whole bunch of GitHub issues where people are very angry about it, and understandably so. So parcel has kind of made this assumption for you, at least in parcel one, where they're kind of assuming you're treating it, I guess you would kind of say like a linter, where your editor is providing all of the type hints for you, and you, if you want to actually fail a build, you can fail it in your continuous integration, through PRs or something like that, so people can't merge code. I'll just show you a real kind of brief example. So you, because you have TypeScript, you could do something like tsc dash dash no emit and and or whatever, depending on your operating system. You have to do this a little bit differently in Windows. But this would make it to where when we go to build, well let's just show it, you know, why talk about it when I can show it, npm run build. It's gonna give you this type failure right here, and it's just gonna immediately fail. Oh, actually, tsconfig. Good thing I did that. So in order to run that command, you will need to at least have a tsconfig.json or whatever you want. You don't actually have to have anything in that, which is kind of funny. I'll just run a build, and now you can see it failing on this module.hot, except here. And it also failed, it should have failed on the other ones. Oh, there they are. Yeah. So your stuff won't build, and so you could do that. But really, that's not great when you're, you know, running a server and automatically changing every save and all that good stuff. It's only gonna run right at the beginning of that. So a lot of people are pretty upset about this, understandably, because, you know, the community of TypeScript, you know, wants that reliability for TypeScript to fail. It needs to be an absolute source of truth that's like, hey, if I clone this down and I run it and it builds, then I know it's good, because TypeScript. So I have not used TypeScript very much with Parcel for these reasons. When I went to set", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "Parcel for these reasons. When I went to set it up, I found all these things, and it was kind of turned me away from it. So maybe some people have found some workarounds that I don't know about. You shouldn't take, you know, my word is law here. This is just my experience for it. And it's kind of the downside is that, you know, the way that a lot of these frameworks add TypeScript support is just through the Babel or Babel, however you want to pronounce it, transpiling, which is cool because it's fast, but it kind of sucks because it doesn't actually do proper type checking. So this might be a deal breaker for you. For me it is. If I'm gonna do a TypeScript project, I'm probably gonna do Webpack still. Maybe it's not a deal breaker for you, and maybe you're fine with just VS Code, giving you the hints. The problem with VS Code, of course, or any editor, is that it's only going to show you the files that you see. It's not going to show you all the files in the entire project unless you had them all open. I think you've had enough of that rant. I just wanted to give you some context around kind of, you know, what's going on with that because it is one of the first kind of limitations that I've hit with Parcel. It doesn't mean that I wouldn't use it for other things, it's just currently I wouldn't use it for Webpack. And I also want to put it out there that the Parcel team knows about this and is said that they are working on changing the way that they're doing it based on community feedback and stuff. So, you know, keep an eye out for some changes there. Maybe it'll be Parcel too. You know, with all that kind of, I guess, that sort of negativity aside, we did get TypeScript up and running and compiling at least pretty quickly. So that's pretty nice if you're just wanting to dabble in it and, like I said, if you're satisfied with the way it is, then that's pretty cool. So we'll just we'll check this off as add TypeScript. And wasn't that neat that we just renamed the file TS and it automatically went and downloaded or installed TypeScript for us? Super crazy. Now here's where the fun begins. So we're gonna add Vue to our app now. And I should put a disclaimer out, this is gonna be Vue 2. It's at the time of the recording. Vue 3 is out, but it's on the next branch and support for it kind of iffy in different areas, especially with the PostCSS bugs that I had before in Parcel. So I'm just gonna do Vue 2 for now. And probably most people would be the most familiar with that as of this point. So what I'm gonna do is I'm going to create a Vue folder separately here. Look at that nice little icon they gave me, that's cute. And then I'm gonna make a index.js file and I will also, I'll just go ahead and make the app.vue file. We're just gonna make it a real simple, sort of like a Vue starter here. So this part I'll just do, you know, we're gonna import Vue from Vue. And I haven't installed it yet, keep in mind. And I'm gonna import app from the app.vue is what we named it. And then we'll just do, you know, the normal Vue. We're gonna render. I actually don't know what H stands for in this context. I've seen it put as like create element. I'm not really sure what that is, but whatever. This is the way that the build tool does it. Then we're gonna target root, right? Yeah, let's do root. So we're gonna mount it to root. I'll save that. And then for the app.vue I'm just gonna paste in some code to save you some time. I should have done that for the other one, but. Okay. Alright, so we've got a few things going on. I'm just gonna really quickly go through this. If you're not familiar with Vue, that's perfectly fine. I'm not gonna go into every little detail. It's gonna be a quick overview. Mm-hmm. And with, if you are familiar with Vue, then you should be able to decently follow along. But I do want to go through it to show you all the crazy stuff that's kind of going on here. So to start, we obviously, we're making our Vue app, and then we're going to render the app there. Doesn't have to be uppercase. I almost messed up. Someone else probably saw that. There you go. It was like so obvious. We're gonna render this app. This is just a normal format for it. And then we have this template. And you'll notice that we're using language pug for it. So this is pug syntax. And I actually like pug a lot. I used to use it a bunch, but whenever I'm doing Vue, I kind of like it. And we're gonna have this counter variable that you can see. And then we're just making a quick list. And actually, I am not going to be able to have this just yet, but maybe I should show it. I'll do, I'll delete it for now. Because I will actually mess it up. So we have a template, language pug. Then we move on, and we have a script. And notice we're using TypeScript. And we are, of course, getting the hinting here. I have purposely said this counter. I've set it to be a string, but it's obviously a number. So it's mad. And then here, just really brief, you know, data. We're gonna return counter. That's what we're rendering up here. And then we have a mounted set interval where it's just gonna count. Very simple. And then finally down here, we're using stylus. So I'm kind of just trying to get crazy. And we're using scope styles. And so I'm setting this up to where it's not just view, but it's also got pug, and it's got stylus, and it's got TypeScript, you know, all built into it. And we're just setting up some basic styles. This is stylus, if you've never seen it before. It's similar to Sass. Okay, so now that I've saved that, let's actually take our pages. We're gonna take our about one, and we're gonna commandeer that. We're gonna set that to view, since we're not doing anything nutty there. And I guess I need to update the link to be view. And then here, this is an index HTML, I'm gonna say, go to the view app. Yeah. And in view, we're gonna need an element of root to grab and kind of, you know, inject all of our view app into. We'll have a link to home still. Why not? And then this should say, view app goes here. And then this about JS, we're gonna go into the view folder and do index JS. And let's see if our server held up through all that. Probably not. I wasn't even running. Oh, well. See, it says, it really briefly said installing view. I don't know if you can see that, but I'll show you. Installing pug, installing stylus, hot reloading. Hmm. So let's open our browser and take a gander here. We have this link now, go to view app. Ooh, and it almost works, but the styles aren't working. But the code is. Don't worry, I expected that. I'm gonna show you why. So you can see that it's counting, which is pretty cool, right? Now, you might think that the styles aren't working because stylus or something like that. I mean, my syntax is weird and you wouldn't be crazy for thinking so, but it's not true. This is a really annoying gotcha that I ran into. And you know, I'm in a kind of crazy world of combining a bunch of stuff, but if you go into post CSS config, remember how we add to add modules true for that CSS modules? That actually breaks view and it's a known issue. So I'm gonna get rid of that and that's because they handle, like, they're scoping their own way, I guess. I'm not really sure. But when you just, like I said before, sometimes you save it, it doesn't work. So what I found you have to do to kind of get it to bust the cache is close the server, reopen the server, and then we'll just go into the entry point and we'll save. And I think that typically does it. No? Save post CSS config. There we go. Save that post CSS config, that's the secret. And there our styles are all working. We've got this lovely counter going on and we have a view app. So yeah, that CSS modules can't have that modules true in post CSS config if you're doing view. And you probably wouldn't anyways because you'd be doing it the view way. So I'm not gonna fault them for that one, but that gave me a lot of aches. But pretty cool, right? So we've got our, you know, our variables, bg styles, dark slate gray, text aquamarine, and then we're", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "slate gray, text aquamarine, and then we're using them here just to kind of show stylus in action. And just a real quick hit on this again, notice that this is an error in TypeScript, but it's still building just fine. Just to reiterate that in view it's using TypeScript, but it still has the same problem. Still transpiling with Babel. Oh, and how could I forget? Let's go back to the package JSON here. Let's actually do the diff and show that again. Now this one's pretty wild. So you can see that it's, you saw it adding stylus and pug if you glimpse that really quickly. But you'll also notice that it, oh I don't want to open that. Go back here. Dependencies has been added and that's because view should be a dependency. I don't really know that view hot reload API should be a dependency, but they've chosen to put it there. But view typically should. And then this view template compiler and view component compiler, these were all added and put appropriately in dev dependencies along with everything else. I messed that up. Oh really you're gonna edit that for me, huh? So yeah, that's pretty cool. Once again, I'm really blown away by the the magic of Parcel and how, you know, just this one file having these references to these things it was able to pick all that up and just go ahead and install all those dependencies. Just fire away. I'll wrap this one up by showing that our post CSS stuff is actually still working in view though, which is good. So if we were to inspect this, we should see... let's do the... where's this container right here? Notice that we have these webkit properties here still for Flexbox. So it is showing that post CSS is still working. And even though it's annoying for me, I'm going to show you by fiddling with this again. So I'll go to post CSS config and I'll just make this an empty object, right? And I don't know if I have to restart the server for that. I do. So we'll do the old restart the server, go back into the code, save post CSS config just to make sure, and then reload this. And you'll see that those are all gone now. The webkit prefixes are not there anymore. So just to show that, you know, out-of-the-box view isn't coming with that, we added that with post CSS and the auto-prefixer. So let me throw that back in there real quick. Shut down the server, restart. It'll get real mad when you do that. As you can see, it dumped a bunch of logs out. And make sure that that's working again. I got to go back in here and save after. It's real tricky. You get some finicky behavior, but here you go. Okay, well I think that wraps up a view for us. Let us segue by going back and putting this line in here that I had before. This React app. Now we're gonna drop that in our project. Let's commit this real quick. And actually, ooh, I need that to not be there during this commit because it'll actually break the build. I don't know if you got to see that. Let me show you. See, it actually tries to look up this page's React.html because we had a link to it, which is kind of cool that it's letting us know that. But it will actually break your stuff. So I'll take that out while I commit this. Add view. And I guess I'll put pug stylus because they came along for the ride. Oh, let me undo that commit real quick. Do last commit. Thought I added them all. I guess I just barely changed that, didn't I? Yeah, that looks right. Cool. Okay, now let's put it back in. Boom. React time. So for this we're gonna do much the same. We will copy this view.html file. I'm just gonna paste it in there. I'm gonna rename it to react.html. And then here in the file, please go over to the file, we'll change this text, of course, to say React app goes here. We're gonna have pretty much all the same stuff except we're now going to look in the React folder for the index.js and we're going to make it a JSX file just to show that that works without any configuration because typically in Webpack you have to set up your resolvers for that. So that will have us coming over here and building a new folder and we're gonna make this folder react, of course, and add a file in there index.jsx. And then this is just your standard, I'll write this out real quick, import react from react. You could do it with star as react. That's how I should be doing it but I haven't updated my snippets. And then I, why didn't you do that? I'm going to go react dom and I haven't installed any of it again yet. No React installations yet. We're gonna have an app so we'll import app from dot slash app dot JSX. Well it'll be shorthanded. And then we're gonna render and let's render that app. And we'll do document dot. We'll use get element by ID this time here. And we're gonna get the ID of root. And because we don't have an app yet let's make that and app dot JSX. And I'm just gonna use a snippet real quick to get this done real fast. We're not gonna pass it anything. We'll just have a div and then we'll have an h2 because we already have an h1 on the page. And I will make that is react running. It's not really running, it just isn't rendering. Should be what it is but. Now is our server still running here? It usually won't be able to hold up to me changing file names around. So I'll restart that and you should see it installing React. Doing some extra stuff too. React dom. Hmm. Okay. Let's reload this and we're on the view one and we made this link to React. And React is running! At least it's rendering. Right? Let's make sure by adding some state real quick. It's one thing to transpile JSX but so what I'll do is I'll just I'll do IMRUS. Get that going there. We'll make that here and we just call it use state why not. And I'll start it off as false. And then what I'll do is I'll be really silly and on an h2 I will put an on click. And this on click is just gonna be an anonymous function and we're going to set state and we'll set that to the opposite of what our state is and then we'll change this to say oops. Huh that shortcut doesn't work. That's so sad. We'll change this to say what is state. What is state? And then we'll render the state and but we need to turn it into a string because otherwise it will just you know false out and be nothing. Really simple app here right? Let's go back here and see. We've got reactivity. It's like hard to do that without dragging. Now we come back to our code. You know the package.json you already saw it doing this but isn't that neat in the dependencies it is thrown in here react and react-dom. So it's done that for us as well. I'm kind of beating a dead horse at this point aren't I? But I I really think it's worth mentioning how each of these different frameworks it they've taken the time to handle and install things for you and quite frankly that's amazing. So I think the next thing that I'd want to you know make sure works is images because typically there's some configuration to do that in any sort of bundler right like especially JavaScript or rollup. It's not super hard but you know you're gonna need them. So I'm just gonna copy some images in here and all I've got is just a few different logos all right and what I'm gonna do is I'm just gonna straight up import this and say let's call this SWC logo from and we'll do dot dot slash images slash and it never auto completes these for me unfortunately but we'll do this logo dot JPG and then we'll just drop an image tag here and for the source we will make it point why did it not backspace both quotes rude. SWC logo. I'll get rid of that and I don't care about the alt tag right now obviously. Let's see if that loaded. Boom! No config. Just got images working from imports. Okay so that was a JPG. Let's just really quickly change that to a PNG and see how that behaves and oh my goodness that is big. Let's go down here and set the width just to be lazy and set that to like 800 and there you go. So you got a PNG loading right but can I do SVGs? Spoiler again. All right that looks the same right? So let's inspect it and look it's output this little file here dot SVG. So I guess that's a point to leave a quick note here is these are all image sources which is super cool that they work but actually rendering SVG code like the SVG XML code into the DOM so that you can change it with CSS selectors and", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "so that you can change it with CSS selectors and stuff like that is always problematic for me and in a lot of frameworks especially I've had a lot of problems with it with React. You usually have to have some sort of package that converts it to React component and the syntax isn't quite the same as JSX etc etc. I've also had the same problems with Parcel. I had a hard time finding out how to like directly render it because if I just render you know SWC logo right now it's just gonna be text it's just the path. So if anyone knows like an easy way to do that that would be awesome if you could leave a comment on that because I always struggle to find a good way to render out my SVGs. You get it. You get it. So bam bam boom there you go images. Cool. Let's make a commit. Add React images. React in images. That was it. Now this really surprised me actually. Now this is cool. So that we have all the great flavors of CSS going we've got styles, we've got sass, we've got CSS, we've got CSS modules. We're gonna put style components in here now. And so what I'm gonna do is I'm going to import style components from here and then I'm going to create a style component and I'm gonna call it container. It's just a div, nothing crazy. And I'll put one thing on it for now just so we've got it. I'll do display flex right. I'm gonna save that. Oh I caught it. You can see it redoing some fancy stuff. And before I go over to the page, let's see, look at that. My mind was blown on that one. The React thing, the view thing, those were all really cool. But wow, like just an import of style components and you just detected that and installed it for me? That's cool. So let's change this to a container. If you aren't familiar with style components, I won't spend much time on that, but they're a CSS and JS type of format if you've ever heard that form. It basically takes every sort of set of styles and turns them into a component so that all the styles are scoped to that component. Also a very hotly debated thing, but I like them so go away. So here we'll do, you know, I'm gonna type this out just so you can see. So we can do flex direction column. I thought you could do FTC there. Can you do DF or display flex? Or is that, I'm just curious now, DF. Oh you have to do DFL. Yeah, okay. Anyways, I wanted to show this real quick that you'll notice that I have syntax highlighting in here and also I'm getting like emmet completion. You know, I can go PIC, place, it doesn't have that one. Let me show you another one. Let's do BGC for background color. We're gonna do midnight blue. Then we'll do color is cornflower blue. And then we'll do FFSS. This is really cool one that I like. If you ever just want to do a quick sans serif FFSS. And so what I'm showing here is that this is Emmet, if you're not familiar with it. I have to do control space for that one for some reason. And this works inside style components if you have, I believe you have to have a VS Code plugin. So you can actually do P40 here. And I've made you watch me type this up long enough so I'll really quickly do it. But what I wanted to show was style components. There's this plugin, VS Code style components. And this gives you syntax highlighting and kind of treats it as a language so that you can get the CSS auto completion for IntelliSense and all that stuff. So you're gonna want that if you're ever using style components in VS Code. All right, let's finish this up super fast. Not much left. I will do FC 64 here. And then we just need to do an a tag and then we're good. 28. Forgot what I did. And the color will be Alice blue, just so it stands out. Keeps with our blue color theme. All right, that's that. Now let's head on over to here. And yeah, look at that. Not the most beautiful, but it's all right. So this is just to showcase here really that, you know, we've got these hashed class names from style components. It just works. And usually style components works pretty easy because it's just JavaScript. But it's worth showing. And it's got all of these vendor prefixes. These actually aren't coming from PostCSS. Style components comes with them. So if you didn't have PostCSS installed, these would, you know, be here automatically. But I'm not going to waste your time showing you that. So let's add a quick link here. We'll do it above the image so we don't have to scroll down. So here I'll just do an anchor tag. And we'll go we're going to go to view.html just so we can bounce around. Go to the view app. And then I guess we also want slash index.html. Home. And isn't this cool? Like you've really easily between that beautiful gradient, you've really easily between all of this are just jumping around between all of these different React apps through multiple entry points are different JavaScript frameworks with a React app with a view app. Sorry, I was reading the text and it got in my head. You go to React app, you go to the view app, you go to the home. And that's really neat. It was pretty easy to set all this stuff up and a lot of it was real magical. So wild. I think that's pretty good. Let's commit that for a moment. So we'll say add React. Or no, we added style components, we already added React, right? Now it's really briefly, this will be fast, but I want people to know how to do this. Let's change it to TypeScript, React TypeScript. So all we need to do here is rename these files TSX. And then we'll rename this. Now, if you didn't have TypeScript already set up, it would actually detect this and it would automatically install it just so you know, and that's really cool. The index or the React HTML, we're going to have to change that to TSX. Okay. So there is one thing that you have to do here. Let's go back to index TSS. And you'll notice when you go into this, VS Code is actually telling you cannot use JSX without the dash dash JSX flag. Now that's because you have this empty TSS TS config. And when we, where's my, thought I had it on my clipboard. When you paste this, you need compiler options JSX React in order for that to work. Now, that's all you need. You go back to app, it's working fine. This will still be an error because that whole, you know, when you're importing images or CSS, it doesn't know what type that is. But it is now working and running. So let's make sure we change the file name. So of course, we have to restart the server. What did I mess up? app JSX. Oh, that's weird. It's app dot TSX. It should, it doesn't need the extension. It'll get mad if you do that. It sorted itself out. It was really weird. I just guess I just have to save the file again. It is I think it's just really aggressively caching this stuff to save build time, which sometimes is annoying. But I think you can disable that. Anyways, there we go. Reload the page, go to the React app. Oh, and our apps broken. That's not Bono. Oh, I think I might not have saved that. That's probably why I didn't update. Oh, I'm sorry about that. So here we go. Everything's working just fine. And we still have state and all that beautiful stuff. So that puts us done with that. But you you might want to see just really briefly, you know, some of the actual React TypeScript stuff working. So this will be super fast. I'll say typography equals a function that takes children. And it spreads its props because we're going to need the action off of that. And maybe you want to send class names or whatever. And then here we'll do an h2. Spread props onto it. Normally, you shouldn't do this. But if you're doing a component library, you might. It's getting a little long there, isn't it? No, you won't format that for me. Can you do jerk? Okay, so we have this typography. And now we're going to swap out this h2 for that. I don't know why I didn't change both my tags. And you'll see that we get a TypeScript error here. And it'll say property children is missing in type and then it's got the type whoops, on click any etc. And that's because you know, you need to do something like this, however you want to do it. React.fc to say it's a functional component. And there you go. So I just want to show that TypeScript, you know, working in IntelliSense, they're same thing as before, it's Babel.", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "they're same thing as before, it's Babel. So it's not actually going to fail to build, you get it. So there you have it, TypeScript and React. So let's add all this stuff here. We had to change this ts config. That was pretty much the only thing and I wanted you to see that. So that you know that that is a minimum requirement. Add TypeScript and React. Okay, and I think a great way to wrap this up is to add Svelte to top it all off here. So we will go through this process real quick. We're going to copy the React page, we're going to paste that, we're going to rename it Svelte.html, you can name it whatever you want, of course. And we'll go up here. Svelte app goes here. I probably could just change that one word, huh? Stop being dumb. And here we might as well put some links. And we'll say we want to go to React app. I'm going to be lazy and just put view app, whatever. React view. We still got our root. I don't think we're going to need that, actually. I'll leave it anyways, though. And then here we're going to go to Svelte. And this is going to be index. And don't forget that's just a JS file coming up. And then we can go over here to our sidebar. And I will create at the source level a new folder. And this folder is going to be Svelte. Svelte. It's hard to type. Index.js. Did I put that in the right spot? Yeah, I did. And then I also need to add another file here. And that's going to be app.svelte. We're just going to use the same pattern. And this stuff I will paste for you to make it a little bit faster. Okay, so we're going to be importing the app. This is just a normal way to set up a Svelte app. We just target document.body. And the only difference is we're passing a prop here with the name Svelte. Then in our app Svelte, we will paste all of this code in here. And it should install that automatically. It might have. Let's check our package.json to see if it updated. It did not. Ah, yes, that's right. So let me very first go over really briefly the code in here so you can see what it's doing. And then I'm going to show you how Svelte takes a tiny bit more setup. Not much. But there is another gotcha. So we have a script tag. This is the normal business. We're exporting let name. And that is how Svelte is going to bind to that name or be able to pass that prop in. We have a count. We have a handle click. Nothing crazy. We have some styles, which Svelte does scope as well. And then we have this HTML here. And we just have an on click handle. And then you can see we're going to do this cute little logic you don't really need to pay too much attention to. But it's basically just to say how many times the click was counted and to have a little face. And you'll see it in a moment. And then we have our RLR links. Right. And I guess that's I don't know why I put those in here. I shouldn't even have those in here. I should have them in here. I'm a dummy. And what's kind of cool, I just want to show this is like, let's say that you got rid of the button. You'll actually get some nice little helper stuff from Svelte automatically just because VS Code and it will tell you that this thing is unused. And I really like that about Svelte. It's really dope. OK, so it's not working. Right. And I'll just let you know, even if we restart it, it's not going to make a difference. OK, this is one of the ones that, well, go over here. NPM start. It ran some stuff. You know, don't take my word for it. I'll just show you that. Right. I thought I put a link to Svelte. Now, let me do that real fast. React. Why can't I type that? Such a weird word. Svelte app. See, the monkey learned. Now go to the Svelte app real quick and you can see it's not loading. All right. So what's going on here is we actually do have to install this one. It doesn't auto detect it. And I might know why, but we want to add Svelte and then we need to add this parcel plugin Svelte and then also a parcel bundler. I think it's just parcel bundler. Not sure why. So we're going to install that and I will briefly show you in the docs. If you come over to Svelte. There we go. They tell you to install these as well. Parcel bundle or parcel plugin Svelte and then parcel bundler. Now, when I run this, though, it's going to get upset. I'll just briefly tell you that this. So what this is, is it's kind of a funny predicament. This also took me a little bit to figure out. So this is that the parcel plugin Svelte, the maintainer, I believe, didn't tag the newest version that fixes this error. And it's from many months ago. And so even if you do. So I'll do npm i dash d. Parcel plugin Svelte. And I'll do at latest. OK, I want to show that when I do that and I go to my package JSON. Parcel plugin Svelte is at 406 currently and multiple people prodded them to update the tag because they actually took the time and fixed the bug, but they didn't. The package is up on npm, but it doesn't show up. So you actually have to type it in manually and say 4.0.8. And there you go. That's that. And then when we do npm start. This was from an update to Svelte. I shouldn't say recent because it was like six months ago. So that ran. Go back over to here. And there we go. Now it's working. So, you know, before I move on, I don't want to, you know, be crapping all over this open source dev. Obviously, he's doing it for free. We should be grateful for his work. But it wasn't annoyance that I ran into just because they hadn't taken the time to tag it. But, you know, life happens. Who knows what's going on in his life. So thank you for all the work you do. Nameless soldier. So, oh, hi, Svelte. Here we go. And you can see we have this very upset face because we haven't clicked the button yet. Click the button. There's now a jolly face. Click there. There you go. You got a Svelte app. You've got a React app. You've got, you know, a Vue app. You can click things. All the different things, all sorts of setup and configuration in this. And I was actually going to show Tailwind with it, but there are more of those post CSS 8 difficulties that, like I said, the Vue 3 community had problems with it as well, and they had it with Tailwind, and that's how I learned about it. So I decided it would just, you know, lengthen the video too much, and I think you get the gist. I'll link this in the description just so you know. But how you get it working is there's this post CSS 7 compatibility build that Tailwind has because they talk all about it in this little article here. Like I said, I'll link it. And so it's a known issue. It's not necessarily Parcel's fault here. Like I said, Vue has the problem as well, and I'm sure other things do. So I won't go through setting that up. I'll just give you the link. And with that, I think we can call it here. I think we've seen a lot of the power of Parcel and how cool it is. And I know Parcel 2 is somewhere around the corner. I thought about waiting for it, but, you know, it was in alpha for like a year and beta in half a year. It's been a really long time. They've been doing a ton of cool work for it. There's all sorts of stuff to be excited about. But if you want to get in and use Parcel right now, you can see that it's pretty dang cool. I know we really breezed through a lot of content there really quickly, but I hope it showcased a lot of the really cool functionalities of Parcel, and maybe you'll be interested in using it for any of your projects. I haven't actually used it as an entire, like, enterprise project yet, but I'm really wanting to try that. But I use it for development stuff all the time because it's just really fast to set up, and I think it can get you really far. So, you know, you might not want to worry about setting up all the cool, crazy webpack stuff if you just want to kind of get going and start working on stuff right now. And, you know, if you have problems down the line, you can convert it to something else later. But I think it's really worth using.", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}, {"page_content": "else later. But I think it's really worth using. I hope you enjoyed this video, and I hope to see you in the next video.", "metadata": {"title": "Parcel JS Setups Walkthrough and Review", "url": "https://www.youtube.com/watch?v=D3EZ9dvjuHI"}}]