

Welcome to another exciting episode of Swashbuckling with Code. I'm your host, Jimmy Cleveland, and in this episode, we are going to cover git bisect, a mysterious command with many arcane abilities. So this is actually a really cool command that I learned about randomly in a Twitter thread. I'll show you that thread. It was kind of interesting. And what it is, it's a troubleshooting technique to locate errors that can be tricky to track down. It has a lot of uses, but it's really, really powerful once you add it to your toolkit. So I've actually set up a nice little git repository, which I will link in the description, that you can use to try the command out. And I think it's a good way to kind of introduce you to some of the different ways to use it. So let's get to that. Git Bisect All right, well, let's start out with the repository. So here it is. I will link it in the description. And I have this git bisect practice example readme that tells you the commands that you can run. I tell you the good commit to start on. That will make more sense once we get into it. And let me actually show you the tweets that led me to this. So Dan Abramov, you know him, you love him. He hates that you love him. But he made this interesting little tweet one night, April 7th here. I don't know, this was this year? I don't even know. I can't keep track of a time anymore. But bisecting is one of the most effective ways to debug problems. I'm not going to read this whole thing out loud. I'll link these in the description as well. But this kind of led to a really interesting discussion. And I was trying to figure out, what is he talking about with bisecting? He kind of clued me into it with understanding the layers and their order and how to cut them in half. That's really what clued me in. And so as I was reading down, I'll go down here. Someone said, you know, what does bisecting mean? Thank you for asking that. Walston, interesting. And think of binary search, but for debugging. So yeah, this is, I have this technique that I've used for a while. It's kind of a brute force technique. And what it essentially is, is that I call it a binary search. And this is what clued me into this. I was like, oh, I think that they're talking about this thing that I do. I didn't know this was like a named thing. So binary search is essentially if you have like a sorted list, you like cut it in half. And you see if the thing is at the left or the right. And then you know, you if you know, it's not on one side, you know, it's on the other, then you cut that in half, and you cut that in half, and so on, so forth. So it's an O log n really efficient way to do that. So what I actually do, it's a silly name for it. But if I know my code base well enough, I can comment out half the code or half the imports or, you know, any sort of situation like that. And, you know, this is when I'm like, I can't intuit my way toward finding a problem. It's just like, okay, I'm really, really stuck. And I just I have to figure out where is this bug coming from? It's not making any sense. So I comment out half of it or delete half of it. And I see when the code runs, if the bug surfaces, and if it doesn't, and I comment out the other half, etc, etc. Or if it does, doesn't matter. So then you can keep commenting that in half and half and half until you get to a reasonable point where you can kind of guess and locate exactly where that is. And it's actually a really strong troubleshooting method if you're just out of options. So this was really interesting. For him to say this, you can bisect commits to find a bug by finding a commit where it doesn't repro. So like reproduce here. Check the commit halfway between master and that one. So I'm going to show you that. So it'll make a little more sense. And I'll come back to this last tweet after I show you the manual way. So let me jump over to the code. So you don't need to know a lot about this code. But I'll show you the minimum points that you'll want to know for this repo just to kind of follow along on the example. So it has an index, JS. And all that does is really import this invoice printer. And when you run that, it's going to take some data from these JSON files and run it through this printer function that does some stuff and output an invoice, essentially. And I also, in this instance, I have a test that I've written for it. It's an inline snapshot test. So it's a really minimal test. And the idea behind this repo was that, let me show you in the history here. So if I go back to the beginning, you can press J to go down if you're ever doing Git log. But also if you know Vim at all, Vim shortcuts, you can do shift G and that will go to the bottom. So down here, you can see initial working commit with test. And then I have these refactor, refactor, refactor, refactor. And you can see I'm using these names like extract function to amount for previous. That means extract function, replace temp with query. I've got all these names. Some of these names might ring a bell for you because what I was doing is I was rereading Martin Fowler's book, Refactoring, because he made a new edition that he rewrote all the examples in JavaScript, which is really cool. So I was going back through it. And I read it a while ago and I mostly understood it, but there's still a lot that I could learn from it. And so as I was doing that, I thought it'd be cool to follow along with the examples with a test suite and do them myself because, you know, he mentions that's one of the important factors of having confidence in refactoring is having a test suite. So that's just some side knowledge on kind of like what's with the naming conventions and what's going on. This is an example actually from that book. Yeah. So I'll link that as well. Okay. So that's what's going on here. And if we quit out of this and we go node index.js, you will see that it prints out this invoice. Okay. Now, if I run npm t, which is the same thing as running npm test, I will run my test suite and you'll notice that we get a fail. Okay. And this is a really, I really like this example because it's a very subtle thing. It's just some math got off in the middle of it. And so this math here is causing a failure. And if you're not familiar with inline snapshots, they're really cool. I mean, snapshots in general are really cool. An inline one is nice because it will generate it out into the file. So if you just want to look at the output real quick, it's really cool. And all it does is it just takes an input. And in this case, we run the function and then we pass in the invoices and then it essentially runs the code and then captures that output. And then each the test will compare it to the passing version of it. And it'll tell you if it's different at all. And it'll give you this nice little formatted. This has actually come a long way. This is a just snapshot and just the formatting is really nice. So now that we've seen that it fails, let's take a look at this. What if I were to check out my initial commit, the very first commit, I'll check that out. And then I will run node index dot JS first. And you can see like, if you didn't have tests, you're going to gloss over this eventually, if you're doing a bunch of refactors, especially if you get fatigued, it's you could definitely miss like a small number difference like this or a text or something like that missing. And that's why it's really nice to have a solid test suite here or something because here you can see the original one passed. So somewhere along the way, I screwed up, right? And so if I get checkout master, again, we can look at the whole get log. And you'll notice that somewhere down the line here, I have this commit that says, I introduced a bug here. So this is the place where I purposefully put it in the middle of the commits to showcase this ability. So now let me get to the actual point of this video, which is get bisecting. So here's how it works. You are going to let me show you this again, you're going to want to find the good commit that you know, and it'll be a little bit faster if you can find a more recent one. So if you just like, you run into a bug, and you go back like five commits, and you're like, I swear this used to be good. You check it out, you run it, it runs well. So you would say, okay, this is the good commit. So in this case, I'm gonna go back to the very beginning, we're gonna say like, I do not know where this is, I'm just going to start from the beginning. Okay. So I'm going to start a bisect by saying get bisect start. Now, when I start this bisect, what I need to do is say get bisect. And I need to tell it the bad commit and the good commit. So bad, typically, you just write it like this without a commit, because it's probably going to be the one you're on, but you could pass one in. So that's the bad one. I'm going to say get bisect good. When did this code last work the way that we expect? Well, I pasted in the very first commit number, boom, and the bisect has begun. So now it'll say, okay, we are on this commit now. And we have five revisions left to test after this. So roughly three steps. So if we say refactor, change function declaration, okay. So now I'm on this commit, and I need to tell it, is this a good one? Or is this a bad one? So if I do node index.js, we'll see that it's 47. Okay. And if you don't remember if that was bad or good, because, you know, it's math, and maybe we don't know, we can run the test in this case.

We had a test, and it passed. So that's kind of cool. We can say, okay, this was a good commit. So 47, good, right? Git bisect, and then we'll say good. Okay. And now if we run npmt again, whoops, npmt, this one failed. So if we were just to run it manually, we would see it's 137. So 137 is the number that we don't want in this situation. Now, at this point, it might seem a little bit silly to you if you're thinking about it, because you're like, well, you had tests. So how did this even get in? Well, in this example, I'm going to show you a little bit more legit one after this. But in this example, I'm just kind of trying to show you, you know, how the thing works and trying to reaffirm that whether it was a good or a bad commit, and to show how easy it could be to miss it. But this could happen in a real scenario, if you don't have continuous integration up, and you know, you aren't manually running your automatically running your tests, every time you do pull request or something like that, it could get in some way there. So this is if you did have tests, it'd be a pretty cool way to run it. But you can also eyeball it, right? So this was a bad commit. Okay, so we'll say git bisect bad. And then notice it says, all right, there's zero revisions left to test after this. So it's chopping it in half, it's saying, okay, you know, I looked, I looked at the first, you know, 10 commands, and then, you know, you said it was good there. And I looked at the previous 10 commits, and then you said it wasn't good there. So I'm going to go, you know, in those previous 10 commits and through those bad ones and see, okay, if I chop that in half, how much closer do we get? Hopefully, you're kind of following along there. But on this one, we will say, okay, node index dot j s. And we see it's 47. I'll just do this just to confirm it. But we know that's the good one. So we'll say git bisect good. And you can see that only in a few moves, it found the bug. That's pretty cool. So, you know, if you had a bunch of commits to go through, this can really speed that up. This is pretty awesome. It found this commit, you know, let's read the message here. This commit is the first bad commit. And it, you know, here's the message. So I know to reaffirm like, oh, yeah, that is the one. Pretty cool, right? And if we do get I think if you do get log, it will show you I think there's a bisect log, too. But you'll notice that all these refs have bisect. And so this is kind of neat. This is showing me all of my commits here. And it's saying these are the ones that it actually ran bisect on and what I said whether they were good or bad. So before you quit the bisect, you can do this as a reference and be like, okay, this one was good. This was bad. Yeah, that looks right. So now I can say, get bisect, reset. And we're done. You can go and you can find that commit. And you can fix the original broken commit. Okay. So now I'm going to show you something really cool. On top of that, it gets even cooler. Alright, so as I was reading this, I found this beautiful individual here, who he was commenting on the thread and mentioned this, you know, want to really cook with fire, you can write a bash script that will exit nonzero for bad commit and automate this process further with get bisect run that test. And then so if you're a node user, in this case, this is what stood out for me, get bisect run npm test. I was like, there's no, there's no way that that there's no way that that can work the way that I that I thought it would, or that I'm thinking it will. I was really in disbelief. I was like, that sounds so cool. I need to try it out right now. And that's where I started setting up this, this example for so we're on master right now. Let's do this. So I'm going to go to the bottom, grab that commit again, in case I lost it, get bisect start. So like say get bisect bad, the one we're on is bad. Get bisect. Good. That's this one. Okay, we've begun the bisect. Now I can say get bisect run npm t. Is that not the sickest? That is so sick. So yeah, it just ran through each one and just automatically determined whether it was bad or good based on a test failure state. So cool. So thank you. I'm going to link those tweets. So you can give them some love if you want. But this is really, really sweet. This is such an amazing technique. I've actually used it a few times since I learned about this in my real project. And it's worked out extremely well. Just in general, get bisecting really powerful technique when you can recognize it takes a little bit for you to notice, oh, is this a bisect, you know, situation. But some of my teammates as well have picked up on that and come up with some really cool times to use it that have saved us some time. So we're about done here. But I want to show you for all those who were kind of like, well, what you already have a test, like, what's the point of this? Okay. So I have made painstakingly a repo, that's a clone of the previous one that I have stripped out the the tests. Okay. So now, I'll open the code here to show you, I guess I could just, you know, list it out, right? There's no test here. Okay. And if I do ll, you can see that there isn't an invoice printer test. And to show you this, I'm going to go get log, I'll go to the bottom again. And we'll say get bisect start, get bisect, we're on the bad one right now. You know, actually, let me show you node index.js 137. Okay. So get bisect, bad, get bisect, good. Boom. And the bisect has started right now go get bisect run npm T. And they're all going to fail, because I just don't have a test. Okay, so that's not going to work. So check this out. This is this idea, I'll do reset that I've had. And I've gotten it to work once, but it's kind of hard to come up with a situation for it. But I had this crazy idea where I was like, well, what if you write a test at your current position on master where it's bad, that you know, what's what's causing it to fail, you can't always do this. But if you know what's causing it to fail, then you should be able to write a test that is supposed to pass, since you know, the correct output that you're looking for, but it doesn't. Okay. So we already have such a test. So in this, let's see, where's our other test? Let's see, where's our other one, we're gonna copy this test. Let's pretend that I just wrote this from scratch. And then I'm going to paste this right here. All right. So now, just to shortcut this, I already set up the just environment and everything. I just didn't have any tests. So now on master, what I'll do is I'll run npm T. And you can see that's failing. Okay. Now I'm not committing this. This is the important part. I'm not going to commit this, I'm going to leave it untracked. And you know, when you're using Git, and you check out different commits, it will like keep your floating ones as long as like they're not conflicting with something else, the staged commits or so what we'll do are the untracked files is we'll leave that there. And we're going to do the same thing now. So get log, go grab that commit. I don't know if there's a faster way to do that. I wish you could say just like go to the beginning of history, but I'm too dumb to know how to do that. Sorry. So get bisect start, you could probably make shortcuts to speed this up. If you do this a bunch, get bisect, we are on a bad one. Let's say this is the good one. Control shift B. And now we'll say get bisect run npm T will work. Look at that. It found it. So this is really cool. Like, you never had a test in the entire suite, but you went and you wrote one and it retroactively worked. Because as you check out each one, and you run the test, it can still verify, okay, does it match like the current expected output, you know, in this case, it's a snapshot that I already had that snapshot state. But if you, you know, just wrote and said, I expect this string to equal this, then it will test that over and over and over. snapshots are kind of a tricky situation for that they probably won't work as well. Because, you know, they're, they're outputting it versus the current state. So you might run into some conflicts. I can't really explain that. But I foresee some trouble happening there. So this is a really powerful technique. Overall, I think it's it's really cool. And I hope that you will find some use for it. And, you know, let me know in the comments if or on Twitter or anything like that, my information will be down in the description, if you run into a situation where it helps you out. So thank you for watching, and good luck with that.