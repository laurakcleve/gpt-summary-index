

Welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and in this episode, we're going to be talking about Webpack. In particular, we're going to be starting a new project and setting up Webpack because I want to show you just how easy it can be to go from zero to having modern JavaScript transpiling for cross-browser support, as well as obviously all the good module bundling stuff that comes with Webpack. Now, the reason I picked this topic is because I've noticed quite a bit of anxiety around the idea of Webpack configs and getting it to work, and I think a lot of that stems from, I myself have had it in the past, I think that stems from all of the awesome tools like the view starters or create React app or that type of thing that give you a working Webpack setup right from the beginning. And that's awesome until you get down the line and you need some customization that it makes it a little more difficult to add, or especially if you just want to start all over, you don't really know what you're doing. So that is why I picked this because I think that Webpack is a little bit misunderstood because you always end up seeing a really, really advanced custom setup that's just crazy to follow. But it's actually quite simple to set up on your own and to add the pieces one by one and understand the basics of a standard Webpack config. And that's what I want to show you here. So we're going to be diving into all that. If you are unfamiliar with Webpack in general, just a real quick intro to it. In the past, there's been this long series of problems with JavaScript in the browser as far as having to load your scripts, load them in the right order to avoid name collisions, to deal with minification, bundling and all that type of stuff, and not just having one, you know, giant file, all that type of stuff. And over the evolution of time, Webpack has kind of proven itself to be the champion amongst that. There's been some awesome developments along the way that led to it. But at this point in time, if you want to break your JavaScript up into multiple files, and you want to have it, you know, bundle them efficiently into one file to serve so that not only is it fast, because there's that only that one file to download, but it also goes and builds this dependency graph of all the different imports, you can use the import, export or require common JS versus ES module syntax, as long as as well as getting all of the code splitting, and tree shaking and all that cool modern stuff. So there's a whole lot to distill there. That's as much as I want to talk about that for now. Because if you're here, hopefully, it's because you're just looking for how can I get this thing set up? And how can I understand this thing a little bit better? So I think we should just jump right into that. All right, let's kick this off with a simple project here. So we'll start off by making a directory. And we're just going to call that webpack, maybe setup, go into that directory. And then we can create an index dot j s file. Now you could create this with your ID or however you like, of course, we're going to start off with an npm init dash y, since we know that we're going to have some packages here dash y to say yes to all the flags or questions that pop up. And after that, I think what we'll do is we'll touch an index dot html as well. And then we will open our editor in this directory. Let me bring that down here. And here you go. So with our index j s, we'll start off just doing a real simple, you know, console dot log here. And we'll just say, ran from index dot j s, oops. And in the index html here, we can put use the bang emmet abbreviation to just create an HTML document. And then from here, well, let's actually go into this and say webpack testing, why not. And then we just want to create a script that is a type of source. And that source is going to point to our index j s file. And that's it. Okay. So I just always like to get everything just running first, and then kind of do it incrementally as we go along. And then we'll add our webpack once we need it. So to start with this, we will reveal this and explore for me. You know, I'll just open that up here. Might as well. So we're opening this HTML file in the browser. And if we go to the inspector and go to the console, we'll see that we had this ran from index j s, bump it up a little bit, since we really don't need a lot of space here. Okay. So obviously, our thing is working, no surprise there. Now, now let's do the first thing that's going to make it to where it will not work that will need webpack for which is, we want to import a file. So let's say we're going to import. Oh, I don't know, we're going to make, let's make a, a wizard here from slash wizard. That probably should just be default, but whatever, who cares. And then in this file, or in our directory, we'll do when wizard.js. And the wizard will export. And then we'll just say const wizard equals and let's just give it a name. Not really thinking about anything special here. It's just for demo purposes. And we just want to import that wizard. And then let's say, after we said ran from index j s, we'll console dot log that wizard. All right. Now, if we were to refresh this, you can see cannot use import statement outside a module. So we'd have to use a module type script import, which is pretty atypical to use as of right now, just due to support and everything like that from what I've seen. So we want a way to bundle this all together into into one file so that the the browser knows that it could just load this one script, and everything will be in order and have the proper scopes. And in fact, let's do one more example here. So we'll say, let's we'll import two things. So we'll have a barbarian. And if when you're importing, you don't have to put the dot j s extension just so you know. So we'll have this barbarian here. And then we will do barbarian dot j s export const barbarian equals huel mar. And there you go. Okay, and then we'll just console like that and console log this and this will be barbarian. Now obviously, that's not going to work. All right, same thing. So this is where we'll first introduce webpack. So we will go back to our terminal. And in our terminal, what we can do is npm i for install, so you can type out install if you like, and then I'm going to do dash uppercase D. This is the equivalent to install dash dash dev. But what we want to do is npm i dash D webpack. And you need webpack CLI whenever you're going to run webpack in this way. I don't know what happened there. The first command just hung. That was pretty weird. Okay. So we've installed webpack and webpack CLI now. And from this point on, really, all we need to do is put things in the right directories. Because what a lot of people don't know, or at least the people that I've anecdotally encountered, is that you don't need any configuration since webpack for to run it with a real basic setup, which is pretty cool. So what you can do, this shouldn't work, but until we change our folder directories, but you could do npx webpack here. And that will use npx to go and grab it's basically a an npm addition to grab the latest version of webpack or use your local one if you have it. In this case, it can't resolve dot slash source. So it's kind of pointing you to the problem, it'd be cool if they had a little bit better error message there, but it's in their docs. So what they want us to do is create a source folder, put our index JS in that folder, okay, update imports. Actually, we want to do all of our stuff in here. So might as well just put them all in here for now. Go to wizard, move that into source. And now we go back and index everything should work fine. So now we can run npx webpack. And you'll see that it ran. Pretty cool, huh? So it created this asset main JS. And what we're going to do is we're going to see that right here in the dist folder. So it's automatically set up to look in the source directory for this index JS and output to a main JS here. And here we have the file. So let's take a quick look at that real quick. And it's kind of interesting, huh? It's got use strict, so it automatically enables strict mode, which it does quite a few things. But that's essentially that it's going to make a lot of things that didn't used to cause errors in JavaScript now cause errors. Because down the road, you'll have more headaches if you don't know the errors up front. It does more than that. But that's the main thing. And then we've got a console log. And you can see they're using this comma between each one, which is interesting. So they're going to console log this console log this console like this. So you see, there's no like imports or anything like that, right? Like it doesn't have any concept, it doesn't even create those variables that we did. All it does is it takes all those files, puts it together. And it's like, what's the end result of this running, which is pretty cool. It's pretty lean. And you saw that it came minified. This semi colon just has to do with this whole wrapping this.

Entire expression here thing. Don't worry too much about that. This is a function, obviously an arrow function that is then going to get called immediately after this is what's known as an iffy or an immediately invoked functional expression. So and that's that. Now we just need to put it in index HTML. We're good to go. So the index HTML we're actually going to put into our dist folder here so we can just relatively reference this. And we'll pretend that this is like this is our public or our distribution. These are the files that we're going to load up somewhere eventually. And so now instead of index JS, we'll just do main dot JS because that's our end result here. And if I were to open this up, in fact, I need to reveal this and open it again because it's changed directories for me. Inspect this over the console. And there you go. Just refreshing. You can see that it runs pretty cool. So what this has given us is, you know, module bundling right out the bat with zero configuration, which is really cool. We can use our imports. You can use require common JS or imports or anything like that. And that's pretty neat. Now, one thing I want to show you that was really interesting to me when I was messing around and looking at it. And I just really recommend like you don't need to get crazy getting into, you know, looking at your bundles all the time, but it's kind of nice to remove a little bit of that magic and see what's kind of going on under the hood and have some idea there. Right. Like we might not even know that this is causing a. Whoa, where did I go? That this is using a an arrow function on the output. So this actually wouldn't run on some older browsers, which some people might expect it to. But without Babel and without some settings, it's not going to. Now, something that's interesting here real quick is that I'm going to create a another file here and we'll just call this like, I don't know, get classes or something like that. And what I'm going to do is I'm going to create a function called get classes, and that is going to in here. We're going to get those imports from here and then we will paste those here and then we'll go over here and steal these buckaroos and paste those in here. So this is pretty silly, right? I'm just moving it into a function and then I'm going to do export default get classes. So now I've got this module that's whole purpose is to just import these two and then console log them. Now, what's interesting about this, though, to me is that if you were to import and we can call this whatever we want now, but we'll keep the name get classes from get classes and then we run it, get classes. What's going to happen here now, we need to bundle every time and at this point, we'll want to actually add a script because you might as well. And we'll have a build script and that is going to run Webpack, our local version of Webpack. So we don't have to use the NPX command to type it out anymore, though you could if you wished. So now we just do NPM run build. Oops, I didn't mean to not put a space there. It's going to build just fine. And then if we go back to our browser here, we reload. You'll see that this is the same and that shouldn't be too much of a surprise. But this might be. So if I click if you miss that, if I go to the console and I see where this ran from, I can just click main JS and go to the source. I can click this little pretty print here and take a look at it. And this will be nicer than going in and reformatting. Every single time in our editor, because this will stay this way if I reload. So you'll see that our output here is actually the same as before. That's kind of interesting, huh? So we've got these two variables that we're creating, and then we have a whole function that we're importing that imports those two things. And really, Webpack here doesn't care. It's just like, well, in the end, this is really all you need. So this is kind of neat, but also might be a surprise. You might expect to see some of those functions or variables or something created in here. And that's not what goes on. So I just want to show you that real quick. So that's the first step of having Webpack set up. It's pretty simple. If you just want the bundle import functionality and nothing special like that. There you go. That's all there is to it. Now, next, what we're going to want to do is add some Babel, Babel, whatever your preference, transpiling, because we want our code to work in a little bit older browsers. And so we're going to want to put that in the pipeline, which is just one of the default things that you're going to want to do when you're setting up a Webpack. OK, so in order to do that, we there's a couple different ways we can do it, but we're just going to opt for simplicity here. Simplicity sake, we want to come over here and say, OK, I want to now install and we're going to need Babel slash core. And we're going to need at Babel slash what we need. Preset ENV. Yes. And finally, we're also going to want Babel loader. Now, this is our first loader, and this is what Webpack uses to figure out how to handle certain operations. There's like file loaders in case you need to load your CSS and your JS or your images in your in your JS and all that stuff. But just so you that, you know, that's what loaders are a common terminology in Webpack. So we'll install this first and we need the Babel core for obvious reasons. That's the core. But we also need the preset ENV. And what that's going to do, it's pretty cool, is it's going to figure out automatically it has some default settings of what the kind of latest browser support, how much backwards compatibility we should have. That's sort of reasonable based on usage statistics in the Web. It's the best way to think about it simply. So if we come back to here, we can now create a new file called Webpack dot config dot JS. With that Webpack config, what we can do is start our module dot exports. Now, you do need module exports here. I believe there's a way to set this up to use, you know, the ES import export type syntax. But since you're not like by default running, you know, your your Webpack or your Babel on your actual this Webpack file, it's an entry point. I just stick to the module dot exports format. I have seen that you can do it other ways, but I'm not knowledgeable enough to know that part. So I just stick to this. It's pretty simple. OK, now from the beginning, what we want, we actually don't need an entry and an output, which you'll commonly see. And we'll add that in afterward. I just want to show the minimum thing that you need here. So you're going to need a module, right? And then your module is going to have a set of rules. OK, and those rules are an array of objects. And then at this point, you're just going to want to write a test. And the test that you're doing is essentially saying, like, what kind of files do I want to run this against? So in our case, we're going to escape the JS is a regular expression. And we actually want the dollar here and put that there. And so we're saying, you know, any file that ends in a dot JS, the dollar is just saying ending in. And then we want to exclude our node modules. We don't want to be running our transpiling on other people's stuff that we are importing any package or anything like that. And then this use object is a way to say, OK, well, what loader do you want to use to accomplish this? This is just a normal module and web pack. You do the same syntax for other loaders. And we want the Babel loader that we installed. OK, so it's maybe worth commenting here that without additional settings, this will reference a dot Babel, RC or any of the other Babel extensions. So you totally can just put your Babel preset ENV right here after this. But since you're almost always going to want to start doing a little bit more maintenance in the Babel RC file to tell it how to behave, you're going to want to create one ahead of time. You might as well just start there. And then all you need to do in this is pretty simple. You can just say presets. What presets do we need? Well, we need at Babel slash preset dash ENV. Sorry, my brain left me for a moment. OK, and that's that. So what this will do is web pack is going to say, hey, whenever I encounter any JS files, except for node modules, I will use the loader Babel loader, which knows to go and look at this. So that's going to use our Babel core with our Babel preset ENV, which is going to just kind of give us some standards to transpile to. Now, when we go back and we run NPM run build. We're going to see that the output is a little bit different, possibly. We might actually need some some things to make it different. Nope, it's the same at this point. There's nothing that really needs to be transpiled for the latest browsers. This arrow function used to for preset ENV, but we've moved to the point where it's so highly adopted that we don't need to transpile that for most browsers anymore. If you're using old, you know, or if you're trying to support really old browsers, then you would. And we'll dabble on that in a moment.

Okay. So at this point, you've got your web pack all set up and it's pretty simplistic. And let's add some other things into it to kind of show that, uh, we have this Babel support actually working. Right. So we'll leave this, like we ran from index. We did the get classes. Everything's working great. Um, but now let's do like const object and we're going to make this object. So hard to come up with names. I'll just do like a simple, like alpha bees, Bravo. Okay. And then what I'll do here as I'll say, const new object equals dot, dot, dot object and C let's append Charlie here. Good old Charlie. And then we'll console dot log that new object. So we're going to use the spread operator, which is newer and just take our old object and turn it into the new one with C concatenated onto that. Okay. And at this point we should see some, uh, actual transpiling going on here. So the difference between compiling and transpiling is just that, uh, compiling is actually compiling to either a different type of language or yeah, that's the gist of it, but transpiling is kind of to the same language, but an older version of it. So it's adding backwards compatibility. Just a real quick one there. Okay. So we've run the build and we come back here and actually let's just use the browser here to reload this. And you'll see that we have, uh, all of this lovely code that it's added. It's a whole bunch here. You can see it still has our console logs. And at the end, it has this interesting little, like our function, uh, that, the, you know, this looks like an object assign or something like that. It's taking an object and then it's taking, um, this, it starts with an empty one, it has this new one. And then it adds onto it, the C Charlie, and you can go up here and see that there's a function are defined and we don't really need to dig into what all it's doing, but we can see it's doing some get own property descriptors and defined property and all that type of stuff. So there's a lot going on here that we would have to write to get this functionality and some older browsers that don't have, uh, you know, just default spread syntax, um, just to do that safely, kind of crazy, huh? There's a lot of stuff going on under the hood, but it's that simple. Just set that up. It's really neat. So coming back over to here, let's just kind of do this one thing at a time here. We've got this mode, right? And, uh, by default, it starts off at production and we're going to set it to, uh, this has to be a string, right? Yeah. Development. And just to show that before we run it, this, this is a like minified and mangled mangled means it takes all of the variable names and turns them into like one letter definitions to make it even smaller. So it's just kind of compressing it as tight as it can. No white space on one line, all that that's production mode. And the default starts like that. And that's why it was like that when we just ran it without any config file. Now we're going to change it to development. And when we do development, you'll see that when we run the build here, what did I do wrong? Invalid configuration object webhack has been initialized using a configuration object that does not match the API schema. Mode. Oh, I did it under module. I'm an idiot. Sorry. So, uh, yeah, that that's a, that's a root level property. Silly me. All right. And then we go to the domain again. You'll see, Whoa, it's got all these comments now. So it's, it's tried to give us a lot more information on what's going on. And this will allow for cool sorts of things, uh, like source maps, which we're going to add next. So if we were to reload this in the browser, once again, we'll see that it's a completely different whole nonsense setup, which is kind of cool because it does tell us, you know, some extra information and it gives us these little, um, where are they like source barbarian JS. It's telling us like where each of these files. What came from where the methods came from and all that stuff. Sweet. So next, okay. Now what we want is we're probably going to want to do a little bit of like source maps, so this is another root level rule. We don't need another module at this point. Uh, what we want is just this dev tool and we want to do source map. And I don't believe we need a package for that. We need, do need a comma here and we'll come over to here. We run it again and we're going to get kind of an auto builder in just a moment. Um, so we can just watch these files, but for now we're just kind of, you know, keeping it lean and we're going to do a little bit of a backup. You know, keeping it lean. All right. So it's made all these things and you can see now, uh, let's see if it says it here. It doesn't say anything about source maps. Let's go check it out though. So reload this and the difference here should be, let's see, main JS formatted. So. Oh no, it actually is working. I'm just being silly. No. Oh, it swapped over on me. That was weird. I must not have refreshed on this page or something. So you can see that, uh, it now tells us where these things are coming from. Get classes, get classes. It's pretty neat. Um, so if we were to click this here, it will take us to the actual file so we can see the code, not the, uh, you know, main that's been put everything together. So this, this main still exists and it's all inclusive. It's the only thing that the browser is actually running, but it sends along this little file here, main JS map. And what this is, is a way for it to map between the relationships between our all bundled code and the individual functions. And this helps us troubleshoot. So when we're in dev mode, we probably want source maps and that will allow us to troubleshoot bugs and errors and all that stuff much more easily. And we get that so easily by just adding dev tool source map. Now, at this point, we are pretty tired of running NPM run build over and over again. So let's get some developer experience up in here. And it's neat about webpack is it actually comes with a dash dash, whoops, dash dash watch flag. And what that is going to do is make it to our, let's show that what I'll do is I'll actually use the VS code terminal here. We'll run build. Um, and that's just so that I don't have to alt tab and you can see it. So it's run and you can see it's still just watching files for updates. Now let's, uh, we back here, we type this in with a lowercase and let's just change it to an uppercase, very minor change. Save that. You can see it recompiled that file. Pretty cool. Right? And, uh, we could go find that if we were, you know, we don't believe it. Oh, well, it's right there. Nice. Uh, wizard, rap one, all uppercase. So there you go. Now let's take it a step further though. What we can do is say we actually want to, uh, start up our own little server here. So we'll make a dev server property here, and that has a content base and you got to tell it like where to look for your stuff. And we would tell it, look in that disc directory. All right. Cause that's the default here. Right. And from that point on, we need to actually shut this down here. And, uh, I guess I could do it there, but what we want is to add, uh, another thing, web pack dev server. So this nice little package, we'll make it to where we can actually open up a server. Instead of just opening that file and refreshing it, we can have a sort of the normal, what you would expect, like hot reloading server here. And then it keeps all of our changes kind of in memory. So they update immediately, uh, in order to enable that, what we want is a script here and let's add a start script at the front and the start script is going to run web pack dash dash serve. Actually, I think it's just serve. Yeah, it is serve. I'm being silly. And that's all we want to run now. And then what we can do is go back to our terminal and say, NPM start. And notice that we got this nice little server here. Project is running. So let's see if that works. If we go over to our browser, um, we can, let's put that in this right here that I have opened this up console and we still get this, uh, oh wait, failed to load resource. This is different than I thought. The server responded with a status of 404, not found weird. Okay. I had to reload. Okay. So we're going to go ahead and run that. Weird. Okay. Live reloading enabled. Cool. Okay. So here's all that stuff. And then let's go back to our code and say, all right, well, um, you know, at the top of this, I'm going to say console dot log, get classes was called. Why didn't I put that together as a function? I don't know. Who cares? Get classes was called. Boom. Just like that live reloading. So now you've got a nice little server to simulate development. Um, it's all going through this index HTML, which is like what your actual thing would, uh, load your browser. And at this stage, you can actually host this if you want to, you can put it on Netlify or any other CDN or anything like that. It's just a series of files. And you can actually, um, because you have a build script, you can just tell if you use something like Netlify, you can tell it, uh, you know, every time I push for continuous integration to my repo, I want you to run the build command. And then that will output to the dist folder. And by default, it's going to, you just tell it that that's your entry point, dist or public or whatever you want. And it will serve up some files and you have a site at this point. Pretty cool. With some cool developer experience. Now, um, what I want to do just for a moment is just show you that, uh, typically you're going to see in your web pack config, uh, one little extra rule here. And I did it this way on purpose because I wanted to show you that you actually don't need this if you just want to use the default settings for source and dist. But what you can do is, uh, you can have an entry point here. And for that entry point, we want to say, we want to give it the relative path. So this is the entry to our index JS file. And so, well, any, you know, any row, any since Parallel or Mon somebody knows where it is, and then we're going to go ahead and select it. Press submit command. Let's give me, you know, 15 minute.

File actually doesn't have to be index, but we're going to say it's index because that's what it is. And then I want to say, well, our output place, and let's put a comma there just to get rid of that. We need to do pass it an option, which has like the file name. And so that's what we want to call it. So let's say instead of main JS, we want to call it bundle.js for whatever reason, you know, maybe we have a reason. And then we need to give it a path. Now this one's a little bit weird. Um, I'm actually not sure why we can't use relative paths in this place. We need to use path resolve and use dur name and pass it whatever folder we want. Let's make a different folder. Let's make public. So we've got a different name, bundle JS, and then we've got a public folder. Now, a little bit information about this path is something that comes with node. So we can just do const require or const path equals require path. And then we'll have that no big deal there. We don't have to install another package or anything like that. And this dur name is also something that comes with node. Now, what dur name is going to do is it's going to find the directory or find the file that you're currently at this directory name of the file you're in. In our case, this is root. Now path actually requires a relative or an absolute path, sorry. And because of that, that's why we have to do path dot resolve to commit that absolute path. I suppose we could type it in ourself. The main reason you typically do stuff like this is because on different operating systems, you have different ways of, you know, creating the string for a path. And due to that, there will be some inconsistencies that you just hard coding it can't work. The thing that I was kind of curious on is why does entry not need that? I'm guessing it's a read write thing, but I don't know. So this is just the way that you do it is shut the server down, start it back up again. And we should see content not from webpack or from dist. Oh, that's actually because our server, we haven't changed that over yet. But I'm imagining it did compile our other stuff. Let's see. We should have a public now. Let's change dev server to well, actually, let's just run build. Maybe we'll say the content base is public now. npm run build. Here we go. So we've got public bundle JS, bundle JS map. And so yeah, you can see that working. So if you just need to change your name, for whatever reason, you can, you can totally just leave that off, though, if you don't, it's up to you. It depends on how complex your your setup is going to get, right. So I just wanted to show you that because you'll almost always see a webpack config with an entry and an output. And sometimes it's more complex, because you want to do chunking, or you want to do it into different things. But if you have a simple setup like this, you don't even need to put it, it's pretty sweet that it just comes without that, or comes with that setup, and you don't need that. So I think what we want to do now is make this sort of actually a production dev type scenario, because we really don't want this hard flag here for development, just hard coded right there, because we want to serve the minified assets to, you know, our actual users. So what we'll do to do that, is we'll say, hey, when you do start, I want you to do you know, webpack serve or whatever. But when we do build, we're going to we're going to set an environment variable, you can do this multiple ways. And we're going to set that to production. Okay. And so node env is a pretty common thing that would be used here. And then what we can do is we can create a variable and say const mode equals. And let's do something like process dot env dot node env, so that we can get any of our environment variables. And we're looking for the node environment variable, we'll say is that equal to production? Here's a ternary, well, then this is this variable will be set to production, otherwise, it will be set to development. And then here, we can actually change this and we don't want the string here, we want the variable to mode. And we could do the shorthand here, but we'll just keep it like this. So mode mode. All right. Now let's see if that actually worked. We go back to our terminal here, and we do npm run build. Now it should still start up in watch mode. But what we should see is that the main actually we changed that didn't we? We've got all sorts of nonsense going on here, you'd want to pick one or the other, obviously. But we now notice that bundle JS is bundled in a lovely way. And it's all minified and mangled and all that good stuff. So that's pretty sweet. Now, you could, obviously, you can use these variables to do other things too, like if for some reason you want a different output directories or all that type of stuff, you know, you can you can see kind of the customization that you can do here with with just this this idea. Now to test this out and make sure that we can still get you know, our dev files, what we would want to do is go to let's let's just say that we will make a little silly script here. That's like build dev, just for whatever reason. And we can do webpack dash watch. And then now if we go over to our terminal here, we'll do clear that npm run build dev. Okay, so it built everything, it's watching. And if we go to our bundle, you'll see that it's now in development mode. It's not minified, and it's got lots of fun things. And the thing that might kind of throw you off a little bit is that let's actually do this. If I do npm npm build, run build, sorry. And that will output my minified version. And then after that I do, you know, let's say I switched over to start because I wanted to serve, you might expect this serve because we're not passing the node environment production to it. Let me show you that for reference. This one right here, webpack serve, we're not passing this flag to it. So it should be in dev mode. And if we go and look at our bundle JS, you'll notice it's still minified, which is kind of confusing. But that's because in serve mode, it's actually not writing to that file. Like I said, it's keeping it in memory. So that's why that isn't changing over. But as you can see, the flag is working correctly. If for some reason we needed to build between dev and production, you could just leave it as production or take it off. All right. And with that, you're pretty much set with ES6 plus, you know, all the features, ES6, 7, 8, 9, whatever we're currently at when you watch this video. And I mean, it's funny to even call it ES6 plus because at this point, ES6 is so old. It's just like old timer logic. But there was a time when, you know, we couldn't use any of that stuff. And that's when Babel came and saved the day. So the thing that you should know that's very important with this setup right now is that this does not include proposed features. So you might see a new JavaScript feature that's being proposed currently. And if it's not in the, you know, the current stable versions that are out, then Babel is not going to transpile that until you opt into it specifically. I'm not going to show how to do that in this video, because that would make it run a little bit longer than the intended purpose, but just know that. And then there's one other thing that you need to know, and that's methods. This will confuse people quite a bit, is that you might think that you're automatically going to get method support for, I'll give you a quick example. So let's say if we were to console.log after this, we have an array that we just make on the fly, A, B, C, why do arrays always have three items? I don't know. It's weird for demo purposes. And let's say we want to do the dot includes method. Hey, do you include B? Well, this was ES7, if I recall correctly, and we will not get that transpiled. You might think that we would, but we will not by default from Babel. Why? Because it's a method. That's very important. That requires a polyfill. And to show you that, just that that's kind of not working, what I'm going to do is I'm going to switch back to dist being the main. So I'm going to delete this like public nonsense here. We're going to go back to our config and clean this up. And we're going to say, you know, I don't really care about these anymore. So we don't need an entry in an output. You know, some people might prefer to always have it, but for my purposes, we don't. And in fact, let's actually use start just so we've got our server running here. And if we go back to the browser, let's do this. Couldn't see it because it couldn't be reached. There we go. Okay. Cannot get root. Why? What's your deal, buddy? Do I just need to reload again? Oh, you know what? Ha ha. We got got here. That's because this was pointed out public. So now you know why you need that. So I'll leave that in. You do need to make sure this is pointing to the right direction, right content base. So now that's starting back up again. There we go. Beautiful. Okay. So you'll see that this was true. I should have put a string in front of it, but it came right after the object. So that's all there is to it. Now this might seem like you're good to go. This is a real gotcha. That's just because this is a modern browser and it does already support that. Okay. Now, if we were to go to our code of where this thing runs, I actually don't want source map in this instance. Let's just do a includes search, close this, see how the syntax is still here. Console log ABC and includes. It did not try to transpile that to an older one. And that's because by default, Babel is not going to do that for any methods that require polygons.

There's kind of a larger discussion about that, but the gist is that it would bloat up end result of your main.js significantly to just polyfill all of the methods. It's quite significant and you don't want that by default. A lot of people get tripped up on this because they think, oh, you know, preset env, I should just be good to go. Why is IE 11 failing when it tries to run this dot method? That's why. Now, if you're interested in getting those polyfills to work and seeing what you need to do to get all of your code transpiling for say IE 11, for instance, this is probably a good opportunity to subscribe and maybe check notifications because I'm going to be coming out with a video sometime relatively soon that will include a little more in-depth dive of all that transpiling goodness to kind of take a look at what you need to do to get all of your methods and everything working on older ones. We're going to talk about like browser lists and stuff like that. So you can kind of narrow down your focus and say, these are the browsers that my particular product needs to support. So if you're also interested in, let's say, React JSX, trying to get that going so that you've got, you know, your own kind of custom web pack setup that simulates a lot of the behavior of create React app, but you're going to want to, you know, add more customization. I'm also going to do a real quick build video of that in the near future. So same thing. If you're interested in that, subscribe and, you know, please give me any feedback if you liked or didn't like the pace of this video, if there was different information that you wanted, you know, leave a comment and I assure you I'll be listening. So I will see you on the next one.