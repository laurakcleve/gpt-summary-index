[{"text": "Welcome to Swashbuckling with Code. I am Jimmy Cleveland, and we are about to make a full Webpack project. Now what do I mean when I say a full Webpack project? Well, let me briefly go over what we're going to cover. So we'll be using Webpack 5, and I'll show you some of its new features. We'll be using Babel transpiling for modern JavaScript. We'll be doing React with JSX, production and development builds, source maps, hot module reloading, CSS, and outputting that CSS from a JavaScript import to an actual file, SAS, PostCSS with auto-prefixing newer CSS features, BrowsersListConfig for customizing cross-browser support, outputting images as separate files or inlined into our JavaScript bundle for faster loading of SVGs or icons or any small images. We'll be generating the output HTML file from a simple custom template, and then we'll set up automatic cleaning of our output directory for a more realistic deployment setup. Then we'll quickly deploy and host our project on Netlify with automatic production builds every time we push to the main branch. And finally, we'll add React Fast Refresh, which is a really awesome new hot reloading tool that's maintained by the React team. Now a quick disclaimer, this video is covering what I think is the most common type of Webpack project, which is like a single-page app project, and I won't be covering exporting packages, though the end product of this will be extendable to a multi-page app or exporting your own packages or anything like that. And as you can see, there's a lot of content to cover in this video. I've spent a lot of time on this, trying to find the right balance between moving quickly enough to get through all the material in a reasonable amount of time, but also explaining things as we go. So I hope I did a good job of that, but you can let me know if you have any constructive feedback. Like I said, there's a lot of material to cover in this, so I'm going to be moving through it fairly quickly, but I will be explaining things as I go. But if it's not in as quite as much detail as you would like, I have other videos on this topic that delve into specific areas that I go into a lot more detail of. So check those in the description or in a notification that I'm going to put here. One last note is that I'm not going to be going over routing for single-page apps in this video. That's because a lot of projects don't need or use it, or when they do, there's a lot of different preferences and flavors that people like, and it adds a lot of complexity to it, so I decided it was out of the scope of this video. So now that you know what this video is going to cover, let us begin. Let's start by creating our project. So let's use Mkdir in my case, and I'm going to make this webpack project. I'm going to immediately cd into that project, of course. And then what I'm always going to do is I'm going to init right away. And I think it's a good habit to use Git in general, even if you don't want to host it somewhere, just because you get that history, it's easier to undo stuff and not worry about losing data and all that good stuff. So then what I'm going to do next is I'm going to host it on GitHub right away. So I'll go over to my browser, and this is my alternate account just for making these video repos, nothing crazy. And then I'm going to make a new repository. I'm going to name this webpack config. And I don't really want to do anything else but just create it. And what you can actually do here, this has always worked for me. You might have to type these commands individually, but you can just click this and copy it. And if you go back to your terminal and paste, mine will prompt me, just letting me know it's going to run some commands. And because each of those line breaks will count as the enter key, essentially, it's going to run all of them, and I just have to press the last one. And there you go. Now we've got it all pushed up. So if I reload here, I guess I didn't really need to init there, but, you know, whatever. So then the next thing we're going to want is we're going to install or we're going to actually let's do an init first, npm init-y, just to say yes to everything. And we might as well just install over here webpack, webpack-cli, and webpack-dev-server. These are the first things we're going to need. So then I'm going to open in code. So right off, what we're going to see here is Git is saying that it has too many files to track. And that's because we're tracking node modules and we don't want to do that. So right away, we might as well make a git ignore file, and in there we'll type node modules, and that you'll see this stop tracking it. And then here, this sometimes doesn't update for me recently, I don't know why, but you can just click refresh, and then now we'll just be tracking the git ignore, package lock JSON, et cetera. So I'm going to go over to package JSON, and I'm going to clean this up a little bit. I actually don't care about any of this stuff right here. If I get rid of name, version, description, main, it actually says that a couple of these are required in the npm docs, but that's mostly for packages, and I haven't really had any problems with them. I'm actually going to delete this as well. I don't really care about hosting my repository since that's, you know, for a package. Keywords, author, license, bugs, home page, don't need any of that. Now some people might think I'm crazy here, but I don't really have any need for this type of stuff, and if I do end up needing it as I go, then I'll find out. And so I think it's a good way to learn is just to kind of, you know, trim everything you can and see what actually is there so you don't just like sit in there kind of a bundle of anxiety of like I guess I need all these things. And rant, so I think we might as well just start off by adding some scripts here. So the first script that I'm going to need is start, and my start is going to be webpack serve. This is the new way to do webpack dev server if you are familiar with the old one. Now I want to do a watch because I always find this useful. This is when I want to watch my files for saves so they get updated, but I don't want to necessarily serve it. I might just be running it locally. So I always do a webpack dash watch here. And then finally, most important to me is that we're going to need a build command, and that's just simply webpack. Name these whatever you like, of course. If we come over here and do npm install, we get a few warnings. You don't have to worry about this FS events. This is just a, you know, packages that are needed for Mac that other operating systems can't use. It's really annoying that we can't get rid of that. These are the ones we're worried about, though. This webpack project, no description, no repository, no license. Well, that's because actually what we want is to set this to private and then set that to true. And the reason is because this is not going to be a package, and we don't want to accidentally publish this. This is the whole purpose of this is to be, you know, a project website in the end. And then if we come back over here and run install, those warnings will go away. We'll just be left with these ones that I try to look up, and I don't think you can get rid of it. So it is what it is. And I think the logical place next is to create a new file here, and we want to create it in source index.js because that is the default place that webpack is going to look without any configuration. So we'll create that, and then I'm going to actually set up a little object for my demo. I'm going to make an Elven shield recipe. And then for that, I'm going to say leather strips. That's two. Let's do iron ingot is one. Find moonstone is four. And then console.log, there's nothing special about this. It's just for example. We're going to log it. And then what we want to do is see if our npm run build command actually works. It does. We get a warning. You don't need to worry about that. It's just letting us know that it's going to default to production, which means it's going to minify and mangle it and all that good stuff for the end user. We will fix that in a moment. But for now, what I can actually do to make sure that it worked is I can go into dist and look for main.js, and look, there it is. It runs. And go back over to the editor here, and you'll see that dist has a main.js, and it's this one line format. So that's where it's going to output it by default with no configuration. Pretty cool. But we will want to ignore that folder. Now, the reason that we want to ignore dist before we commit next is because this is going to be our kind of like clean slate output. It should be repeatable every time. And so when we actually host this on the server, we don't want to host all these files. We don't want to pull them down from GitHub already built. We want it to build them fresh every single time. And so that is the reason that we're going to ignore the dist for now. And I think it's time to commit. So we've got our git ignore. We've got package lock JSON. I don't really ever look at that too much sometimes. And then we just take a glance over and say, okay, yeah, this all makes sense, the things we added. And you have that. Perfect. So I'm just going to say initial webpack setup and commit that. And then you can just click this usually. Is that going to let me? You can also do your standard terminal git push, you know, I'll be going back and forth. So I usually commit pretty frequently. I'm going to spare you all this time. And I'm only going to commit during major sections. But I think that it's a good habit to be in just to commit more frequently. It's easier to roll back. That's my two cents. So let's actually make this a an actual Web page here by creating a new file index dot HTML. And this is going to be blown out every time. And we're going to deal with that later. By that I mean, you know, every time we build on the server or somewhere else, you know, this isn't tracked. So we're going to have to start over and index HTML is not going to be tracked. So don't worry about that for now. We're going to come in here. I'm just going to use the good old Emmet shorthand. It's really nice.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "And then here, what we want to do, let's actually make an H1 just so we can actually see it. Webpack, we, I don't care. And then script, we're going to do a source type. And this is just going to point to main JS. So now we have our template. And what we can do, there's a couple ways we can open this and look at it. So we can right click for me and do reveal in Explorer, however you want to go find that folder and open it up. And then when it opens up here, I can just click this little Chrome and see it right here. And if I inspect, we should see our object printed out. Now, if I go over to my terminal, I should also be able to run my Webpack dev server. So that's going to start that up. And, you know, it's all built and beautiful. And then we just want to take this right here. That's going to start our local server there. We can go take a look at that. Now, what it's going to first do is it's going to show us just the whole directory is what it's pointing at. If we click on dist, that index HTML is the root point for dist. So it's going to open that automatically. And that'll work the same. OK, we open this up and install or go to console. We'll just see this object. But live reloading actually isn't working yet. We need to have a Webpack config to enable that. So jumping back to our code, let's make a Webpack.config.js. And that's what Webpack is going to look for automatically. And from here, this is standard. You're going to do module.exports for node. And then I'm going to set the mode to development for now just so that we can actually look at the code. And it's not all minified and harder to read. And then the thing that we actually are here for is dev server. So this dev server property, whenever you're using Webpack dev server, you can set this to content base. And you just give it a relative path to that folder where all your stuff is. And then when we restart that server, npm start, we go back to our browser. And this one shouldn't work because it's a subfolder here. But we should go to local host 8080, and we'll be able to see that. You can ignore this dev tools thing for now. That typically goes away. But this live reloading is enabled now. So let's see. Is that true? Well, in order to test that out, what I'm going to do is I'm going to add actually just to be clear, notice that it's just logging out this one object that we've made. So I'm going to go to our index.js, and I'm going to make a new object. This one's going to be called elven gauntlets recipe. And we are going to use the spread syntax for the next part that I'm going to demo. So we'll take this off of elven shield. We'll clone that. And then I'm going to add, like, leather to it, just raw leather. So it's going to add this property. And then I'm actually going to alter refined moonstone to be four. There's four of those. And then we'll just copy this, and then I'll change this to elven gauntlets recipe. So we'll log both of them. Now, if I go back over here, I should see this automatically logged out both of them. So it reloaded and logged them both out. So I can just manually reload, and it'll do that. Cool, right? Now, we want to look at our output real quick. This is kind of interesting. If I go to my main.js, it won't actually have any of that new stuff. That's because Webpack Dev Server is injecting that. It's not actually building it into the disk folder, just so you know and you don't get confused, because I've been in that situation. If I do npm run build, now that we've set it to development, come back, and we'll see that it's output like this. Just temporarily to fix this, it's a little bit harder to read here. So what you can do is you can go to, you can set dev tool to false. We're going to get rid of that in a moment, but for now, we'll do that. I'm going to rerun build, come back over to our main.js, and you can see now that it's updated to look pretty normal in the output, and you can see the spread syntax here and all that. So that leads us to the next feature that we're going to want to add, which is fable. So we have this syntax that's being straight up output, and we actually want that to be transpiled automatically to whatever Babel goes and looks at. Can I use reports and what browser percentages have what support, and determines that automatically, and we'll customize it a little bit after that. I have a video on this, so I'm not going to delve into that too much. It's the build basic webpack video, which I'll link in the notification and all that stuff, but I cover that a little bit more there if you don't really know what Babel's for, but we need to cover a lot of material here, so I'm going to move on. So in order to add that, let's go to our terminal. We're going to add, these are all going to be dev dependencies, we're going to do babel loader, since that's webpack's way of figuring out how to digest certain syntax, and then we're going to do add babel core, and add babel slash preset env, so core, so that we obviously have all the core functionality, and preset env, that's because those are going to be our standard defaults for last two browsers, 1% usage, or I don't know what their defaults are, but somewhere around there. Now, what we need to do to get this to work is first, I think we should update our webpack config. So if we just go to webpack config, what we can do here is say, we're going to now have a module property. This module property is going to have a rules property. This is pretty normal, you get used to this, it's the regular flow for setting up all your rules, and then here, you're going to do a test, and this is going to be a regular expression test, I think. Oh, whoops, we want an object here. Don't be silly, Jimmy. So these rules are going to be a series of objects, you can think of it that way. This first test is going to be a regular expression. We're going to just look for JS, okay? And we'll put the dollar sign there just to be a little more secure to say it ends in.js. Any file that ends in.js, we want to run against that. We're going to have to exclude node modules because Babel transpilation is actually pretty expensive, and we don't want to run it on a bunch of stuff that has no need to be run against for us. So that will make it slower if we didn't do that. And then use, finally, we want to say, oh, well, how are you going to handle this? Well, I want you to use this loader, and it is Babel loader. Oops. So without any extra options, Babel loader is going to automatically look for one of the default naming conventions for a Babel config file, so let's make that. Now, usually I do Babel RC just because that's what I'm used to, but in some cases you're going to want a config.js, and that's what I recommend for this one. So babel.config.js is another one we can use, and then I'll make it a JavaScript config. So with that, we'll need to do module.exports as usual, and then here this is going to have a presets array here, and then we'll just use at babel slash presetenv. That's our preset that we're going to use, and that's it. So now what we can do is if we do npm run build, we should see, going back to our main.js, we're going to have some extra stuff here that's interesting. Notice that this spread has been replaced by this object spread method, and that's where it's defined, so it's actually gone and made some little bit backwards compatibility support for some of the browsers that don't quite have it yet. It's still not as widely supported as we would like. So now we know our Babel's working. Now if we go back over to our terminal and start our server back up, and go back to our browser here, let's reload that real quick, and what I want to show is that if you were to look at any of this in the main.js, you're going to see the final output code as you would expect. It's all the finally transpiled code. What you can actually do, and it's really easy and awesome, is we can go back to our webpack config. I'm going to wipe all these out for just a moment. Let's go back to our webpack config, and here we can change this devtool false to source map. Now I should need to restart the server from that, but I always like to check just in case someone's made some cool advancements, it looks like it. So let's go back, shut down, restart, npm start, go back to our server, and then you'll notice now that warning's gone away finally, but also notice that it's index.js line 14. Let's go take a look at that, and you'll notice that it's our pre-transpiled code. It's our source code, so it's that easy to set up source maps nowadays in webpack. It's amazing. I love it. Now at this point, I don't want to keep switching back and forth constantly between whether we're development or production when we want to see the final build, so what I'm going to do is go to my package.json, and I'm going to say that my build command is going to set the node env equal to production. And then what I can do in webpack is I'm going to say let mode equal development. Down here, we'll set this to mode, whatever we end up with, and then we can do an if condition. We can check process.env, and we can say if that node env, sorry, environment variable, is equal to production, then we want to set mode. Oops, I'm not in an object. We want to set mode equal to production.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "Pretty straightforward there. Now, this might be a little bit weird to you. I could have used a turn area. There's a lot of other ways that we can make that cleaner. But this will make a little bit more sense, I think, toward the end of the video. I'm kind of setting it up in that direction. So just bear with me on that one. We'll start with this. So by default, we'll have development mode. But if it happens to have this flag, however you want to set it, you can set it in an env file or in Windows it's a little bit different. But either way, you set that environment variable to production. You can just look that up how you can do that. And it's pretty common. Now, if we come into here, we say npm run build, we should see that our main.js is all mangled and minified and beautiful. So it's nice and compressed. Fantastic. And then what I'm going to do is add one more script real quick. I'm going to say, I like to always have this around as a build dev script. And then that will just simply run webpack without passing it just like our old one did. And then let's try it out. Got to make sure it works. Build dev. So that'll switch us between that. So then I can just run this, you know, when I actually want to see my normal output here. But then on the server, it'll run build. I think this is a good point to commit our code and do a real quick review. So we've got this babel config.js. And that makes sense. We know we added that package lock, you know, it's just our packages. But what packages did we add? Well, we added the script. We added our Babel core, Babel preset env and Babel loader just as a refresher here. This is why I like to go through VS codes, diffing of the git. I just think that it's a nice habit to get into to make sure that you didn't leave any accidental console.logs or any problems like that. And to also kind of remember what you did. So then don't worry about that. I always get that. Webpack config. We added the whole thing, right? Yeah, we needed all of this. And then finally, we added the spread. Cool. So we'll say add Babel to project. Okay. And next, I think it's time to add some CSS support. So let's start by adding our styles by having a styles folder is what I'm going to do. It's not necessary. I just like to do that. And then here, I'm going to do index.css. We'll start with a basic CSS file. Now that CSS file is going to be pretty simple. We just want to see some results, right? So we'll say let's set the margin to zero. Could have done m0 there. Let's say our background color to I'm going to do peach puff today. And then our color, I'm just going to set that to 222 globally. Now, in our index.js, we actually want to import this. So we'll say import, and we can just say dot slash styles slash index.css. And then let's try to run it and see what happens. So let's just try to just run build, boom, blows up, right? That's expected. That's because you may need an appropriate loader to handle this file type, of course. So what we're going to do is install those. We're going to do CSS loader. And then we're going to use mini CSS extract plugin. And you can use style loader as an alternative. The real difference is that the style loader is going to inject it, the styles into your JavaScript bundle, whereas the mini CSS extract plugin is actually going to create resources or a final one single CSS file for that. Now, which one do you use in which situation? It kind of depends. And sometimes I don't really know which is the best practice, to be honest. But at scale, it seems a little more normal to just have the files, because the request is a little leaner than downloading this gigantic JavaScript bundle that has CSS put into it. But sometimes you'll use style loader, if you're doing like critical CSS, so you might use them in combination. You know, you check for one, all of your critical CSS at the top, it's like, you know, your basic CSS and fonts and all that stuff. And then everything that can be loaded, you know, below the fold, to use an old term, that can be loaded in with the mini extract CSS plugin. So let's set that up. So here, if we go into webpack config, what we're going to do is need to import this. And so the convention is just to call it mini CSS extract plugin. And that's going to be equal to this should all be complete for us. So we've got that now. And I'm just going to yank that name. Yank that name. And then we'll go down to there's a couple spots here. The first one, I think it's a little quicker as we'll use plugins. And in the plugins, what you want to do is use the new command. I hate when I do that. When I use a new command, and you're going to call this constructor. And then up here, we're going to make an additional rule. Okay. Now this rule itself is going to be a looking for the CSS file. So we're going to test against it just like before. This will be case insensitive, we might as well. We want to do a escape the dot CSS. That's all we need for now, isn't it? Yeah, we just need this for the first part. And then what we're going to do is we're going to set up our loader again. But what we can do is we can just set up this array chain here and say I want this mini CSS extract plugin dot loader. That's the thing that we need off of that. And then CSS loader after it. Now in webpack, everything reads kind of right to left and arrays. So what's going to happen here is when it finds a CSS file, it's going to use the CSS loader to process it. And that's going to be piped into this, which is going to spit it out into our dist folder. Let's see if that actually works. So npm run build. Boom. And in our dist, we now have a main CSS file. You can see that it's got the source mapping already built in, because we just have that one source map setting to true. So that's already done for us. Awesome. Now what we will need to do is link it into our HTML for now. So I'll just do a link CSS. Can you not do that? That's kind of dumb. You have to type that. And then this is actually going to be main dot CSS. And that should be it. Now what we can do is start our server and then check both of them. So we'll start, we will go to this one, reload, and we have our nice peach puff background. Perfect. And then if we go back over to our webpack, this is the one that's just from the file just to show that this is the built one. And this is the served one. And they're both working just to be doubly sure. Right. Now it's pretty sweet about this now that we have the server open. Let's show this. This might actually be tricky for me to show without having them split. So I'm going to split them in half here. There we go. And we don't really want that all the way over there. This should be fine. It's a little bit big of text, but bear with me for a moment. So if we go into our index CSS file here, now let's say that we change, you know, whatever, actually, you know, let's do this. Let's change the font size to 26 pixels. So we're going to just enlarge in the base body of everything. And it should get a bunch bigger. Now you'll notice is that is live reloading, which is pretty cool. We would really want to pay attention to is the fact that over here on the side, these two logs that gets reloaded. All right. So let's do that one more time. So we save that. And you can see that they get refreshed. You can also look up here. But with when it's so fast and lean, it's hard to actually see it. Sometimes you'll see that little flash on that reload. Yeah. So that is live reloading working. But what we really want that's awesome is hot reloading. And to get that very easy now. So all you need to do is go to your dev server. And you want to say hot. It's true. Now you might be used to package JSON. When you run this, like webpack dash dev dash server, the old way, or this way, you could do dash dash hot flag here, which I believe you can still do. But it will automatically do that. And it will also automatically load the hot module plugin in the plugin chain if you just set this slip streamline this to be a lot nicer now. So you just add true. Let's actually make sure that that works. Why don't we, I think we will need to restart. Let's actually make sure one more time. Yeah, so we'll need to restart our server. And then from here, we want to reload this one just to make sure and then add that property again. And look at that. So you can see that it's just dumping more logs. And how can we, you know, make sure that that's actually what's happening, because it's happening pretty fast. Well, check this out. Let's say that you were testing this out. I know this is really squished. Sorry, bear with me. Let's say that you were testing this out. And you wanted this like really long title on mobile or something like that. And you want to see like how many times it wrapped or whatever. This isn't a great example. But notice that I've edited the HTML here. So if I reloaded, it would just go away, right? But if I add this to it, notice it kept the whole title. And if I undo it, we'll do the same thing. So this is one of the reasons why hot reloading is really nice. Because now watch, I'll reload, and it's gone. So it wasn't a live reload, it was a hot reload, a module replacement. And you can also see that in the console. If you want to see that it's working, it'll say.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "hot module replacement enabled. Now, why this is really useful, getting back to that. If it isn't immediately obvious, a lot of times it will, it'll be a little bit faster, of course. That's the first benefit, just faster. But also, when you're making changes, especially later when we add some React and you're changing like state, or maybe you're editing the DOM, you're switching some things around or messing with stuff, being able to, you know, live inject those CSS styles to not have to like replicate your current app state can be really, really efficient and speed up your process a lot. So yeah, isn't that awesome? Just one little property now, and you got hot reloading. And this will also make a difference, I should actually note, as the project scales. One thing I forgot, as it gets bigger and bigger and bigger, the reloading process will be slower, whereas injection will be much, much faster. And that's where you're really going to see it. So on to SCSS. So in order to have a CSS, now, I'm going to go back to this format for a moment. In order to have that, we are going to need some new loaders, of course, but let's just change over to an SCSS file to start. Okay, what we'll actually do is we're just going to set up some scaffolding for like a normal way that you do SAS. So I'm going to make a global dot SCSS file. And that is where we're going to copy over. Oh, no, you got rid of my other one index SCSS. So we're gonna yank all this over here, put that in global. And then what we'll do is we'll use the at use directive, and we will bring in global. Okay, if you're used to import in SAS, it's not really recommended anymore. I think it's because it sets global variables. But the new way and we're using Dart SAS, so we can use this. The new way to do it is the at use variable, which will like locally scope it, you'll see a little bit more of that in a moment. So then what I'm going to do next is I'm going to make a variables file. And I think most of the time, you'd probably want to be using CSS variables nowadays. But I will actually create a SAS variable just to make sure that it's working. And you might have some sort of use case for it still. I don't know. But typically, I would lean toward CSS variables nowadays. But let's make that peach buff. Right? That was our RPG one. And that's all we're going to have for now. Actually, you know what, let's actually do. Let's do both. So we'll do route, just to add a global one here. So we can just see that both are working. And then I have to do two, I don't really recommend using both. But like I said, maybe you've got some use case that makes sense. That's our variables file. So in my index, CSS, we don't actually need to import the variables here, like you might be used to, we're actually going to go over to global. And then in global, we're going to use the use directive. And we're going to say bring in variables need to put a semicolon here, of course. And then you can just change this over to variables dot, and you actually use the variables like methods from there, you are going to use the dollar sign, which is kind of weird. Pretty interesting, huh? And then here, we're using a CSS variable. And so we're going to just do dash dash text, because that's what we set there. Let's try to run it. Let's see what happens here. So we'll do npm run build. And that's not going to work because there's no index CSS file, right? I forgot actually to go here and change this to SCSS. Silly goose Jimmy. And from there, we'll run build again, we're gonna get another error. This one is the famous loader problem. Okay. So in order to get that working, we'll just go back to webpack config. And really, what we could do is just add this s here. And if we wanted support for both, we could just do a question mark here. And that'll mean like it might have an S it might not. Now, go back and run build here. It'll build. But we didn't actually add the loader, right? sass loader and all that. So if we go and look at the output, notice that it's just it just basically took whatever was there and output it didn't actually run it like it like it should. So in order to get that working, all we need to do is add the we're going to add sass and sass loader. And this is Dart sass that we'll be using. There's a node sass package as well. And this one's a little thing. It's a little faster, but also more up to date. Let's go back over to this. And now we'll add sass loader. And that should get us where we need to be. Okay, let's see. Did it actually build? Cool. Yep. And it's all minified, which is interesting before our CSS wasn't. And yeah, you can see it's outputting the color just straight up, which is interesting about the variable doesn't do the name. And then this still stayed a CSS variable. So that seems to be working. Now we might as well just add post CSS while we're at it. So we'll just do post CSS and PMI dash D, and then post CSS, we're going to do preset ENV, which is kind of like Babel preset ENV, but for post CSS, just most modern browser stuff, and then post CSS loader in order to actually utilize it. Now, we will need one extra thing here. We're going to want a post CSS config. So we'll make that file, the post CSS, post CSS dot config dot j s, I always forget that one. This is very similar to Babel should be familiar. We're gonna do plugins. And this is going to be post CSS preset ENV. Now, let's get rid of all these. Now let's go to webpack. We want to do is that our post CSS loader. And we're actually going to add that before the SAS loader. And this is actually really cool. This is something that a viewer from a previous video actually mentioned, because in that video, I'd mistakenly put them in this order, thinking that it didn't really matter because I tested out and I didn't notice anything. And that's just what I like to do. So they actually went and did a little bit of testing a little bit of research there. And they noticed that not only would it kind of break some slash slash comments, but the big thing was that it would take your vendor prefixes, and it would put them into your source maps, which you wouldn't want, you'd want to see the original code. So that's pretty cool. Thank you, Martin, for going discovering that. I really love to see that people in the channel helping each other out, and also helping me to grow as well. It's really fantastic. And now I'm more knowledgeable because of it. So awesome. Now let's run build again. See what we get. Now we'll go to our main CSS. And this is actually going to be pretty subtle. So I'm going to format this. But you'll see here that there's this this one extra line here, the color being output before this is actually the fallback that post CSS is adding. In order to see it do a little bit more, let's actually add some more code to our actual global. We're going to want to do this is some CSS for later. I'm going to add for main tag, I'm going to do display flex, then I'm going to do flex direction, column, and align items. Can I do a I see? Yeah, that's cool. And then here, I'll do button. And this is just going to be FC 1.5. REM, something like that. Mom, that fun size, and then go back over, run our build again. And we're going to take a look at that actually should be doing dev, huh? npm run, build dev. And go to our main CSS. And you'll see that it's not doing anything quite yet. And that's because flexbox is very well supported in most browsers nowadays, which is really cool. What we're going to do is add a browsers list RC to support a little bit wider range of browsers. And that's actually pretty easy. Now, the reason why you do this is, I recommend sticking with the default, if you don't really know any better, you don't really even need this browsers list. But what this can be good for is let's say that you know that your website's demographic is a little bit skewed differently. And you have a little bit more traffic in some older browsers than most people do, then you can opt into this stuff. So what I'm gonna do is last two versions, this is just kind of the general syntax. Each line is kind of a rule is a rule, it's not kind of this is going to I'm going to target 0.5%. I think the default is one. And then I'm going to do IE 10. I'm very sorry for anyone that's doing that. It's just for demonstration purposes. I actually wanted to run build dev, such a habit. Let's go back to main CSS one more time on Whoa, look at all this stuff. Yeah, so these are vendor prefixes. So these this is the way that Flexbox was supported a little bit further back, as far back as it can support it, it's not going to guarantee that you're going to get in every browser, it's just going to, you know, you have to test that out, unfortunately, but you could look it up and can I use which is a great resource. So if you actually if you're not familiar with that, I might as well briefly go there. Do that. And then we'll do can I use go there. Really awesome. And then let's say you wanted to look for Flexbox, you can come here. And this is the important kind of stat to hover over is this is like global support from all the traffic that they look at, like all browsers, it's very well supported right now. And you can see that IE 10 has some like partial support with the prefix. So that can be a good detection for us to say, oh, the dash ms prefix is what supports it. But six or nine won't, unfortunately. So", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "if we go back to our CSS, you'll see we have this dash ms flex box. And sometimes they behave a little bit differently. So you still have to do a little bit of testing. Sorry, that's just the world that it is. But you know that it's working. And you can use can I use to see which browsers support which. And that also works for JavaScript as well. And that's actually what these use under the hood. There's a package that serves up all those all that data. And that's what browsers listed and the Babel preset and V and post CSS. That's what they're all using under the hood as far as I know. So now just like that, you've got some good backwards compatible support. So you can use modern features and still support them in the old way. Like I said, still have to do a little testing. And if it wasn't clear, this browsers list, both Babel and post CSS are both reading from that. So they they'll they'll use this as this kind of global standard to say, what are your targets, there's other ways to set this up. But I think this is the nicest for me just to be able to quickly see what this project supports. Now, unfortunately, as a right now, there is a bug in, I believe it's in webpack, dev server or webpack five, I'm not sure, actually, but it's caused in the modern versions, by a browsers list RC being set there, and then not being sent over properly to your production and starter build. So let me show that just so that you can see that. And in case you want to check if you actually have it, because maybe in the future, they'll have solved it. And you won't have to worry about this. But for now, I'm going to give you a fix. So if we do npm start, all I need to do is go over to my browser, we don't need this anymore, or reload this server. And then what I'm going to do is try to do some of my webpack live reloading here. So let's say I go to, we should actually be able to do this just from well, let's make it easy. So I'll just say like, FC 100. Right? Just do a big old change. Now when I do this, and I come back over here, you can see that it didn't do anything, unfortunately. So I'll change that again, maybe let's do something, you know, different here. Maybe let's say, let's change this to purple. Why not? Nothing, unfortunately, what if I reload? It's there. So this is the bug that it creates. And it's really unfortunate, but I'll show you a quick fix. So what you can do is you can go to your webpack config, stop. And then you can, you have this mode set to development, let's do a target. And this target is going to be default to web. Now this is the default already, just so you know. But the reason I'm going to do it that way is because then I can come right here and I can say target is equal to target. And then what we're going to do is say if you are in production, I want you to actually target the browsers list. That's the setting. And what that's going to do is going to make it to where when you're running the the dev server, it's properly set to web. But when you build, it'll still use the browsers list and output everything correctly if it's in production. Okay, so let's make sure that's working. First, let's check our live reloading. Come back here, we've got this peach puff right? And you can see live reloading enabled there. Is it true though? Hmm, I don't know. Let's find out. So I will just change this here to purple again. It's probably the most obvious, right? And then it auto reloaded. Pretty cool. Just flip it back. There you go. So it is clearly working. And that's awesome. But what we should also check just to be diligent, is that we're going to be able to see the live reloading. Okay, so if we run npm run build, that will be production. Right? And so that means that if we check our main CSS at this point, we should see this big, long minified version. And we should see all our vendor prefixes. That's the important part because browsers list was the one causing it and we do see them. So what if we do npm run build dev just to be extra sure. And it looks like we're still seeing them. Now, like I said, that is a temporary fix right now. And hopefully they will have that solved soon. So make sure that you that issue actually exists for you before you apply that. But hopefully it will be fixed soon. All right. Now, in order to wrap up the CSS section, it's hard to say, I am going to make sure that I do my due diligence here and commit these files real quick as a quick refresher here. So let's go over to browsers list RC. Yes, we did add that. We don't worry about our package JSON. And then here, that was the lock sorry, CSS loader. And then the mini extract plugin. Yeah, we've done a bunch of stuff. Post CSS, post CSS loader. Looking good. All right, add that. We added a post CSS config, so that it would look for that preset env. We then updated our webpack to have the mini CSS extract plugin, setting our target web for the fix and all that good stuff. And then we set up our rule for SCSS. And then from that point on, and actually, you know what, I'll make one little modification here while we're at it. If you want a more universal like test scenario, this one's fine. There's nothing wrong with it. But we can actually do is let's go back to where we just had CSS. And then you can do an interesting little fix here. Or you can say, well, what I want to say is let's let's wrap that this will kind of set up some options. And then I could say it's either going to be SCSS or just CSS. And you can take that a step further, which is pretty crazy. And say at this point has to be an S or an A. Okay. And then that will make it to where it now says it's got to start with S and then the next character could be an A or C. And then, then it'll be either that or a C and then SS. So this is supporting SAS, SCSS, or CSS. So if you want a kind of global solution, just you know, because it's easy, and you can use it every single time, then you can go ahead and use that. All right, sorry, let's finish up. And that puts our rule there. We've got CSS loader, post CSS loader and SAS loader. Remember that you want your SAS loader to be at the very bottom, which is the first thing that's going to enter, and then it'll add your prefixes to your CSS, and then finally output it into a file. And then down here, you got to have that plugin. And we got hot true, we've got our hot reloading, lots of fun stuff. We imported it into our JavaScript file. And if that wasn't clear, that was because we need Webpack to actually see it to process it. And this is our entry point. So that's why we do that. And finally, we set up our global CSS files. I'm not too worried about reviewing those too much. We know what we did. And we're using that at use directive. Cool. So let's say add CSS, SAS, post CSS, hot reloading, all sorts of good stuff, and a browser list. We should probably add that as well. If you're actually being diligent about your commits, you can do a big old message. But I think that's fine for now. All right, now it's time to get some React and JSX working in our project. But first, I would highly recommend you take a standing break, or a quick water break, get some hydration going on. Just a few minutes, you know, stretch your legs out. And it's just a good habit and then come back refreshed and ready to set that up. All right, start off now, we're going to do npm i react and react dom, one too many spaces there. Now, this is actually not going to be a dev dependency, because it's going to need those packages in your final output. I actually don't think it really matters in Webpack world in the situation. But standard convention here is that these libraries will actually be used with the code that the client downloads. So they should be in production, just so that it's clear to everyone. Next, in order to transpile a JSX here, we're going to do at fable, and then slash preset react. Yeah, so we already have preset ENV, we're going to add preset react now to get that working. And so let's head on over to our fable file here. All these things open, just close all go to fable. What we would normally do is we would just add it here and say at fable slash preset react. And that will work. However, we're going to do something cool and new and fun. So in order to do that, we are going to put this extra array around here a little bit weird. Extra array around that, and then that will stay the same. But we're going to add an object that's a that's in the config option here. And then we're going to do runtime. And this is going to be automatic. So what is this? Well, since react 17 plus, and they've been part they partnered with Babel on this, the team that does it does the tool set, there is a way now to actually opt in to not having to import a react whenever you're just using JSX in a file, which is really cool. And under the hood, it actually is supposed to make it a little bit more efficient as well. And so the only time that you'll need to import react is when you need methods or state or anything like that from the react library. You'll see what I mean. But just so that you know why the settings there, it's pretty cool. Now let's modify our index JS. So what I'm going to do is I'm going to add to the index JS want to import. And then I'm going to import react. And then I'm going to import react.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "And I'm going to do a D structure here. We're going to do render from react dom. So we will need to import that. And then right here underneath this, I will say I'm going to call render. And just to test it out, I'm going to put an H1 here. And we're going to say, oh, hi, from react. And then here, the next part is going to be document.getById. You can just do that as a shorthand. If you type it right. And then so when you get element by ID, you can do query selector as well. This is just pretty normal. And that will make it to where we attach react to our dom. But in order to make that work, we actually need it there. And so we need this. We need an element with root or whatever we want to call it. Roots the convention. Come back here, that document.getElementByRoot will attach this H1 to it. And then that should work. So let's try to run it. So I'm just going to do start. And then go back over to our server. Oh, hi, React. Yeah, got it working. Pretty cool. Notice that we didn't need React in that file. But you'll see that in the next file that we're about to make as well, if you don't believe me. So next, let's actually make a component here. Let's come over here. We're going to add a new file on the side here. And in source, I'm going to make a new folder. And I'm going to call that components. That's a pretty standard convention. You can do it however you like. Don't worry about having to adhere to whatever. If you've got a preference, you can. But if you don't know what you're really doing or you're not opinionated, this is pretty normal until you scale to a certain size. So in the components, we're going to make an app.jsx, which is also pretty common. And I'm also going to make a, well, here, a recipes.jsx for our recipes. And that's so that I can come over here and I can take all of this code, steal that, go over to recipes, just put that in there for now. We're going to do more with it in a second. And then also, let's go to here. And I want to take this CSS and then put that in app. I guess it could stay in the other place, but this is fine. And then what we'll do is we're going to import app from.slash components slash app. Cool. Notice that I made that with a app and recipes.jsx extension. You don't have to do that. You can do.jsx. It's just, if you want to, it's a common convention. I think in TypeScript, you have to. It's TSX in that case, but either way, you don't have to, but notice I'm also not putting.jsx here, right? I just want to import it as a regular JavaScript file. That's going to matter in a moment. So then let's actually make that a React file. So in order to do that, what we'll do is we're just going to start with app and get that working. I have a shorthand here for my snippet library, snippet good, if you're checking it out. I need to actually update it for React for that latest stuff that I just showed, the not needing it, but either way, we'll make an app here. And then this app, we might as well just, you know, I'm going to set it up as the way it should be here. So I'm going to change this to be a fragment, and then I'm going to set section, and I'm going to set the class name. This is just some scaffolding for a moment later. We're going to set this to hero. That's our section. And then I'm going to do main here. And then in that main, I'm going to have another section. And h1, this is where we'll do, oh, you know, oh, hi, React. And then that's it for now. Then we'll go back to index.js, and then here we will see, actually, no, we don't want that tag either. We want app. We're just going to load app. What can I type? Let's see if that runs. Did it fail? Module not found, cannot resolve components app. Let's just make sure that it wasn't just the server flipping. And you'll see that it failed. Can't resolve this file. Why? That's because it's looking for a.js automatically. So all we need to do to fix that situation, you could just type the.jsx if you want to, and that'll work. But what we can also do is come on down and say, okay, let's add a resolve property. And that resolve property has a bunch of different other properties it can have, but you can do extensions. And for extensions, we still want to support js, and we want to support.jsx. Okay? And now when we do this, this will make it, what this is doing is saying, whenever you import something, you don't have to have that extension. It will automatically infer it. And you can throw more on there if you want. This is just what I usually do, just those two. So let's run build again. And see that it works. No, it does not, because we don't have our loader set up, but at least it saw the file this time. Okay? So same thing, we got to the jsx, see that fragment there? It's saying, I don't know how to handle that. Okay. Well, I'll show you Webpack. I will show you. So all you have to do actually now is come up to here because our Babel is already set up to handle React or jsx in this case. And so all we need to do is add an x here, and we can just do a question mark like before and say, it may or may not have an x. Now let's do run build again. Oh yes, ha ha. Index SCSS. So we moved it to app, which means that we now need to go up a directory because we're in components right now. So we need to go up from components and into styles. Sorry about that. And there we go. Awesome. So let's just do npm start. Now, since we've got that all configured, we'll get our live server loading, make sure this is still running. And then notice we have the centered thing because I created that CSS for the main section here, and it's just centering that oh, hi React. So that's working right. But next I want to set up our recipes. And this is important for a little demonstration I'm going to do. I'm going to show you how to do that. So in app, we can import. We actually don't need to import React. That was the thing that I was going to show you, right? Will that work or will that not? Reload. Still working, right? Pretty cool. We don't need that because we're only using JSX, right? That's the key thing here. And you'll see in a moment when we do need that. And that's why I'm going to set up recipes. One reason I'm going to set up recipes. So recipes, okay. We can do the same thing here. I'll just do, you know, rfe. And then I'll say recipes for me. So you're going to have, we will not need React, but what we will actually need, I'm just going to use this. We will from React need use state, okay? And in this situation, the example that I'm going to set up real quick, I'll probably just speed forward through this to save you the time of watching it. So we're just setting up some state here and I'm going to set up a couple of buttons to swap between the two different objects that we have and then just list out all the properties. And really the purpose for this is to just show the persistence of state when we get into some hot module we're loading and stuff later on in the video. And that should be good. And then in app, want to import that. So we will say recipes from.slash recipes. And then we'll just load that right here underneath. So recipes. Oops. Ooh, okay. And here we go. Those are big. Okay, so now we click this and we click this and you can go between the two states. If you reload, you'll see that this one loads this object and this one loads this one. So our React and our use state is working for compiling JSX. And as I said before, you do not need to import React whenever you aren't using state. And that's pretty cool. And it should be a little bit more efficient as well. Now I almost forgot. Let's actually add these files and do our quick review of what we've done. So we've updated our Babel to have this runtime automatic here. And that's with the reset React, of course. Let's go to, stop that. Let's go to package.json and we'll see that app Babel preset React was added as well as the React and React DOM dependencies. We go over to our webpack config. We can see that the JSX test has been added. We just added this X character to look for those files instead of just JavaScript. And we've also added the extensions for JS and JSX. So that's cool. Now for our index JS, I'm gonna review that. We brought in our React DOM so we could render it. And now we're importing app. And just so you know, some people, you know, like to put index.js, not JSX here, even if they're using the JSX syntax because it's not quite a component necessarily. I've seen it different ways. I don't think it really matters too much. For this one, it's just demonstration purposes that you can do both right now, but you know, do it how you like. Moving on, the app, pretty straightforward and it includes recipes. We added that component. And then recipes, this is our stateful component, just so we can showcase, you know, when you do need to bring in React. You'll need to bring it in if you wanna use useState. Okay? Now for this commit message, I'm just going to say add React.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "Something like that. Do whatever you like. Push that up, since we haven't pushed in a little while. So that'll wrap up that section. And the next thing that's going to be really common in our app that we're going to want to support is images. Now if you'll recall, I made this section with a class name of hero before, intending to be a sort of hero section with a background image. And so this is about the time that I normally would want to bring in some images. So I'm going to actually copy some over just to save us some time here. I've got this folder that just has a bunch of images. And you can see it's a various different extensions, because we're going to make sure that we cover some different ones and not just one type. And then what I'm going to do is I'm going to make a whole new file here. And I'm going to make it hero.scss. And then what we'll do with that is we'll target that hero class, and we're going to have a background. And you can just use this, which is really cool when you're using Webpack Project, just like a relative import for where you are. So in this case, let's say we're going to go into images, and then we're going to do the SWC banner. And that's going to set the background. So if this isn't already obvious, a kind of cool note that I like to point out here is that, you know, we're able to import this like, you know, sanely from a relative path, because we're working with our source code. But eventually that's going to be output in this distribution folder. And those might all be flat, or they might have different locations. The main point is that everything's going to be different on the other side, and Webpack's taking care of that for you in the final output, which you'll see in just a moment. So now that I have this set, let's do some basic CSS as well, just to make it look a little bit better. So I'm going to go bgz, make that actually cover, background size cover, and then can I do bgp? I don't even know. Oh yeah, you can, but we'll do center, min, height. And for this min height, I'm just going to do 300 pixels. And then finally we'll do a width of 100%. I really wish that w100, whoops, w100, like, didn't do pixels, but I get it. Oh, and let's not forget that we need to import this. So we'll say at use, hero, and that should be good. Now let's run this, and we should see an error, since we haven't set up anything for it yet. It's a pretty weird error. It's right here, it's module parse error, module parse failed, unexpected character, and this cute little question mark diamond. And it's also letting us know that it needs an appropriate loader. Again, I wish that it could tell us a little bit more information about the type, but it doesn't, unfortunately. So it's just the way it is, and maybe it's really challenging. Now, how you would solve this in the past was that you would use a file loader or a URL loader. Those are the two plugins that I've always reached for before. But in Webpack 5, it's pretty cool. There's actually a built-in way to do this without any extra packages to be installed, and I'll show you that right now. So what we can do is add a new rule to our rules list here. And this rule, we're going to do a test for it, just like normal, and we'll make that case insensitive, because we might as well. And then this test is going to be just like our other ones, but this time we're looking for file extensions, right, for images. So png, you can do jpg or whatever you're specifically doing. You can also just do this, so that, like, optionally it has the jpeg or just jpg. Then we're going to do gif or jif or whatever you like to say, and then svg. And then here, we're just going to say it ends in one of these. So we're looking for all these types of extensions, so we can kind of do a good catch-all for all those. And next, normally we would put a loader here, but actually all we have to do is say type, and then I'm going to show you the first one here is the asset resource. Okay, so notice that at this point, this is what our dist folder looks like, and I'm going to flip over here, npm run build again. So we get one more error here, and if we come up here, we'll see that this automatic public path is not supported in browser, and you need to look up one for this mini-css extract plugin is where it's happening. This is a pretty good gotcha. I got stuck on this the first time I did it for quite a bit. Let me show you how to get around this. So what you need to do is this mini-extract plugin, you can pass these in as a string or just a series of arguments like an array list, but you can also pass in objects for each one. So I can move that up here, and then what this will be is this is going to say this is the loader, and for this loader we have some options, and that's why we need to do it in an object. And for the options we just need to put public path quote there, get rid of that line, and that's all we need. There was a point in time when I knew what this did, this public path here, but I was messing around with it the other day to try and refresh my memory, and I can't for the life of me remember exactly what it's for, but I know it's required at this step. So if anyone has any super cool knowledge about that that you want to drop in the comments, I'm sure everyone would appreciate it. I definitely would. I'd like to level up myself. So that should be all that we need. Let's run build. Oh, looks like I must have typed something wrong. Probably. Options. Oh, yeah, we got a typo. Sorry. Happens though. NPM run build again. And there we go. So now if we go back to our folder, we will see that there is this image sitting out here. Now it has renamed it with this little hash, that's normal, but it will be the exact same size as the original. I don't know if I can show you that. It might be kind of hard to see, but this 226 KB here, if we go to our images and we look at this banner, it's also that same size. So it hasn't changed it at all. There's no compression or anything going on at this point. Yeah, so now we have that in our dist folder. And if we were to let's go back over to our server. If we go to our server and oh, well, I didn't start our server today. Well, we can just look at the built one. And here you go. There's this little image and it's using the background position cover. It's pretty cool. And if you inspect it, you will see that the URL now points correctly to where this file is on my system. And that's that's the gist of it. Now, the other way that you'll commonly use images in Webpack is just to the standard import. Actually, I meant for this to be up here. So let me move that for just a quick second. And then what I'm going to do here is just say import. And then we can name this whatever we want. So I'll just name it Sword from and I'm going to go look up one directory into images. It's still a relative path here. And I don't know why I don't get auto completion on this one. It's kind of weird because you do in the CSS. I'm not sure if that's just a configuration thing, but we can go over to here in images and just say, OK, we want the SWC Sword PNG. So we'll use a PNG for this one. SWC Sword.png. And then this is just actually going to be a regular image tag. So we'll go image. Change that source to JavaScript and say it's here and then all will be sword. And then I'm actually going to give it a width just like to cap it out here. And I think that this will be about 250 pixels. So just to quickly go back over this, this is importing this as a path for a console log. This it will actually be the path to that file currently. And so that's what's going to happen when we run this. And let me I'm going to build for this just so you can see the assets each time rather than running Webpack Dev Server. So I'll build this again. And there's no extra configuration needed. We already have it set up. The only one we needed was that extra CSS property. But if you go up to the top here, you'll now see these two images. You'll see this sword that I just output and then this background. And if we go to look at it in the browser, you'll see the image is now loaded there and it's going to be the same. It's just going to be a file path that it finds. OK, so what's another type of image that we commonly want to bring in here would be a SVG. So let's make sure that that works. So from dot slash images with this exact same thing. But this time, this one's just called sword.svg. And here we will copy this. Sword SVG. Everything else can be remain the same. We're going to run that build again. Let's go make sure our assets are there. And here we can see this SVG output. And it's also all hashed and beautiful. And then if we reload, we'll have two copies of these images. One's an SVG and one's a PNG. And actually, let's take a look at that. There you can see that path. And now I'm just going to set up one more quick demo. And that is going to be here in the global. So in the global, what I'm going to do is I'm going to target all ULs and I'm going to make the list style image set to a URL. And then that's going to be my tiny little image here. That's this dot dot slash images slash. And then there's that 32 by 32. And this, the purpose of this will be revealed in just a moment. So let's go and build real fast and then we will be done.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "We'll go over to our browser and we'll reload this. And then when I drop this down, you'll see these cute little sword bullets that I've made just to show that. Now, why I'm doing that, like I said, you'll see in a moment, but coming back to this. If you would want to actually put these, you can see how we have all these like files right here in the root. Let's say that you want to put those for cleanup purposes into an image directory, just to be a little more organized, I should say. What you can do is you can add the output path or the output property here. And then just for that output property, you can do asset module file name, and then do images here. And then what they want is, this is just something I copied off of the docs. I know the hash and the extension, it's just those brackets are saying like that goes here. So we're gonna, anything that, any asset that comes out, just notice right here, these assets are gonna go into this folder images here. And then this last one that they always have is query. And I'm not sure what that is for, but they always have it on the docs, so I put it in. Now, if we pop over here and do npm run build, we will, wait till that finishes, come back here. And you'll see now there's this image directory that has all the images in it. Now, of course, you'll notice that all these old ones are here. And so what we'll have to do is delete all of those. And that is less than ideal, and we're gonna fix that in just a moment. But for now, we have all of our images in this folder, and it's a good opportunity to show you another type of thing that you can do, which is set this to inline. So asset resource is going to output all of these things. Asset inline is going to actually inline it into our JavaScript. So I will delete this directory just so you can see that. And then when I come and run npm build one more time, you'll notice that we get this warning. And it says in asset size limit, exceeds the recommended size limit, 244 KB, and can impact web performance. That's very nice for them to tell us that. Now, let's actually see, are things still working? Yes, they are. You know, we have all of our images, but look at when you hover over them, go away. It's just like big old crazy string, and you can see it says data image, PNG base 64. And what that means is that it has actually been inlined into our JavaScript bundle file. So if we go back here, we don't have any images in our dist, but if we were to look in main JS, and then let's just say we do a search for base 64, let's say, and here you can see this data image, PNG base 64, data image SVG base 64. So it's actually taken and made them all this base 64 encoded text output, and put them all into the JavaScript bundle. Now, that is not good to do for what we are doing for this purposes, because those are rather large resources, and that's gonna make our initial bundle very large and time consuming to download. But this can be really useful if you only have really, really small images, and that's because there won't be any additional requests required to hit the server for any of those assets, and it won't have to wait to kind of parse them out as it hits them in the DOM, they can just be loaded right off the bat. So maybe if you have like a bunch of little small icons that you wanna load in the header really quickly, that's a good time to do something like that. So that's the gist of asset inline, but there's a really cool little generic property that you can do that's just asset. And how this works is Webpack is gonna automatically determine based on a default max size, which is 8KB according to the docs, whether it should be inlined or whether it should be in the image directory. So let's try that out real quick. NPM run build. Okay, come back here. Notice as we have an images directory now, and we only have these two images in here. So we have this banner, and then we have this picture. Now the SVG and those cute little sword icons that I made, those are smaller than 8KB. Let me show that those work. Let's reload. Yep, there they are. And if you look at this one, it's base64 encoded for this. And if you look at this one, it's just a regular file path, okay? And if we go to the bullets, let me show that in the URL. Oops. Here, we can see that it is this base64 encoded drawing it from the JavaScript bundle. And so these can load really quickly if we needed them to, and the rest of them can just be resources in the final scheme of things. So I'm actually not sure what the most optimal way is to do this. My assumption would be just to leave it on asset as a default or go asset slash resource. But I think sticking to asset is probably your best bet. That's what I would initially recommend, but it probably depends on your use case and what you're doing. So if you're starting out, either asset or asset slash resources is probably the best default way to go. Let me show you one extra little thing that you can do that's kind of cool. So you can say parser, add this little key, and then do data URL condition. And then what you can do is max size 30 times 1024. Now why I'm doing this is where our normal max size is 8KB, but I want it to be 30. And that's 1024 bytes times 30. It's just a little easier and that's what they do in the docs. I think it makes sense to mentally math. And from here, I actually have made some of these just around that size, just to show that point. So if I npm run build, actually, you know what? We are gonna need to delete this first. Aren't we? So let's delete this. And what we should see is that only one of the images, the big old banner image should be in the final output. Let's see if that's right. Yes, it is just this banner. So now we've taken that PNG sword that used to be there. And because I've raised the max cap, you can now inline that. You probably don't wanna be dabbling in that unless it's like a small size adjustment or you just happen to know that. That's what you want, but that option is there. And I just wanna show that. So I'm gonna take that out and we'll go back with the default. Now, of course, you could split these tests up if you wanna handle different things in different ways. You might wanna break out your SVGs into their own and just make those all inline. There's a lot of customization that you can do, of course, in Webpack. That's the whole beauty of it. And also the double-edge sword, where it can get really complicated. And I also wanted to mention that I did do a test I did not add support in this for inline SVGs. We only have the image format to an inline SVG is where it actually writes the SVG code into the HTML, which gives you a lot more power if you're trying to like change an SVG with CSS. But that option is available to you. I'm not gonna cover it in this video as it's gonna add a little bit too much time to it. But just know that that's out there in case you wanna dabble in that. But for a lot of people's purposes, the SVGs just loaded in as the image are gonna be fine because you're still gonna get all that vector quality but then you can just treat it like a normal image with resizing and all that. So that wraps up this image portion for now and it suits our needs, but I'm getting pretty sick of deleting this images folder and individual images over and over again as I'm fiddling with the config and such. So what we could do is we could go into our package.json and make a little clean script. And let's say, let's make this clean. And then what we'll do is we'll RM, maybe say we do a dash RF and we do dist, something simple like that. The problem with this right now though, is that it will delete our HTML file and that's not tracked and we aren't generating that. It's the only thing we're not. And so that's the next thing that we're gonna tackle so that we can get sort of a purity situation where every time we wipe dist and we build it from scratch. And that's gonna make it to where it's a lot more realistic for setting up on our server. So let's make a quick commit just to review all that stuff. And yep, we added this little clean command that we aren't using, but we'll keep it around just for the fun of it. We learned about making a custom asset module file name directory here so that you could put all of your stuff in images. We obviously learned about the asset type and catching all of those. And then we had to fix for importing our images through CSS, we had to fix this with a little options config of public path. And so that's all for that file. And then of course we added our images here. Not too much to see there. We added all of these images. Now we didn't actually test an import of a GIF. We should have done that just to show that that works. And then for our global CSS, we added this little style just to be able to use that in our hero. Well, we added this new thing and then we imported that in the index. That looks good to me. So I'll say add image support to webpack. Pop over here, get push origin main. And now we're ready to generate out our HTML files from a template. Okay, so what we're gonna need now is we're gonna do npm i dash d and we're going to want to install HTML webpack plugin, very common plugin in this world. And then what we'll need to do is go to our HTML file.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "Go over to our code. And in our webpack config JS, we're going to want to import that first. So we'll say const. And then that we'll just call that HTML webpack plugin, pretty standard here. And then we're going to acquire that. And that's HTML webpack plugin. And then we'll go down to plugins here. I don't know why I went back up there. And we need to add that to this plugins array. So we'll say new HTML webpack plugin, call that. And I'm not going to pass any options just yet. So I'll show you how that works in general. But what we will need to do is we're going to take this index HTML, we're going to drag it on down just into source and move that. Okay. And that's going to put that here and make it tracked now, just so that we can save that. And then when we go over to here, we can actually be crazy and run npm run clean that script we just made. And that's going to remove our dist folder, which is kind of scary. Now it's gone. But if we run npm build, all these things will be generated out, you'll notice that there is this breaking change error, we're going to fix that in a moment. But let's just start with this and show the dist folder has been created. It's got images and look, it has an index HTML. Now if we format that actually look at it, it's cool that it's been minified and all that. But you'll see that it has automatically added main CSS here. And main JS here, you might notice that it's missing our little root ID tag that JavaScript or that JavaScript that react is attaching to. And that's okay, we're going to fix that in just a moment. But this is pretty sweet for it to automatically detect that we're going to have a main CSS and a main JS and just put those right into it. Cool. Now also notice that it says webpack app. And I believe our said webpack project. So that's different as well. It's just the default. So I'm gonna close that for a second. And then what you can do here is you can add an object when you call this. And you can set template to a template. And this just takes a relative path. And it's going to go to index dot HTML for us. So we're going to point it at that file we just copied over because that has our div with an ID of root, that's really the only thing we need. But we might add other stuff in here as we move on. So this is our template that we're building it from. So let's try that again. And what we'll do just to test it out here is we're going to delete this for now. We're also going to have what we'll do it with our script, we're going to have a way to do that in an automated fashion in a moment. But for now, let's just do npm run clean. And then npm run build. Let's go take a look at that file. As soon as that finishes. And see what happens. So now our index HTML, or added again, is it's got duplicates. So it does have our ID root. But you can see that it's injecting these things for us. But then we have them to start with. So all we need to do, I just want to show you that that's kind of how that works. All you need to do is just remove these, it's going to take care of any of our dependencies like that for us, which is pretty sweet. Okay. And then that takes care of that. And then the the error that we were running into before this breaking change thing, hopefully, in the future soon, this will also be solved. But there's a temporary problem where HTML webpack plugin is producing this error that you can fix by doing I dash D. And then when we install HTML webpack plugin, you can do at next. And that's going to do like the latest beta version. So we'll see as soon as this finishes, it's going to do beta mines 500 beta six, in case you end up following along. So I showed it in this order, because I don't think you should install it with the next flag. Unless you actually have this this breaking change thing, you can just stick with stable because by the time you watch this, it might already be fixed. I'm not sure. But from there, let's just try it one more time. This is hopefully the last time we'll have to delete this bucko. And then we will NPM run build, I guess I could have used my clean script. I keep forgetting that we just made that. And there we go. And that error is gone. Awesome. Now, we could solve this next problem of cleaning automatically instead of having to do it manually by going into here and saying, Okay, well, when you run this, you could do NPM run clean and and but then you'd want to do that on pretty much all of these and also with the web pack like serve doing it, it's only going to run it on the first time we want to kind of do it on every time. So there's actually a really cool plugin that will take care of this for us instead of us doing it that way, called clean web pack plugin. So we're going to add that clean, a pack plugin. Now only to update our web pack config for that as well. So we're going to bring this in. And this one's actually going to be destructed from it. So it's clean web pack plugin. Oops. And that is going to be brought in from the web pack plugin. Now same song and dance here, this should be getting kind of familiar to you. This is how you handle a lot of plugins here is we're going to do new now I think this has to be at the top. I've always seen it put at the top in most situations. I haven't actually played around with I should sometimes see if moving it around makes a difference but I just recommend putting it at the top for now. And so we just need to add that on to this the top of our array. And then now when we run npm run build, you'll see that we get this little bit of a warning here that says clean web pack plugin options output path not defined the plugin is disabled. So unfortunately right now, with this plugin, what you need to do yet another thing that may be fixed is you need to add a path property to your output. Now normally you don't have to do that. A lot of people do anyways. And that's why it's still around web pack five was the first one where you didn't have to do this, I believe. But for this plugin, they haven't updated it quite yet to that state. So maybe hopefully soon. But what you can do is you're going to do path dot resolve here. And like I said, you don't have to do this normally. If it's the default path. But if it you will commonly use this if you want to change your output path. So if you want to change it to not be dist, and you want it to be public, you know, you could just do that here. Now let me break this down real quick for you while we're here. Actually, you know what, let me get this working first. And then I'll do that. So I'll say const path equals require path. Now if you're not familiar with this, this is just comes with node, you can just require it, you don't have to install it. But let's see if this works. Oh, did I do? Whoopsie. That was supposed to be a string dist. Whoopsie daisy. Sorry. Okay. And we don't seem to be getting the warning that it's disabled anymore. And we can look and see that our stuff was output. Fantastic. So now, you know, let's actually let's make sure. So to be certain, let's add some gibberish file dot txt, right. And then this will be right here. And then if our plugin is working, right, and I run npm run build, it should remove that because it removes the whole folder, and then build out all our code into there. And you can see that file is gone. So pretty confident that it's working there, right? Okay, so this is a pretty common point of confusion. It was for me for so long, and I still even forget the gist of it every now and then. So I want to go over just really quickly this whole path required dur name thing, because it's kind of weird, right, that like, we can use relative paths all over. But for some reason, we just start doing it right here. Let me actually show you, you know, the best way to learn is just to break it. So let me actually show you what if I were just to say, Well, yeah, go put it in dist. Will webpack care? Yeah, it actually says, initialize using configuration object that doesn't matches. And we can look at dist is not an absolute path. That's a pretty good error, actually. So it is telling us that it wants an absolute path. Now, if you run node, just regular old node right in the terminal here, what happens if you type path dot resolve, and you call that, you'll see that it automatically resolves to where we currently are an absolute path. And then if I were to backspace and just put dist from there, you'll see that it resolves the absolute path dist. So that's what path dot resolve is doing. Now kind of a gotcha here, though, is that if you were to CD up one directory, and then we're going to do node again, and path dot resolve. See how it's telling us that it's going to be only up to this point. So what path dot resolve does is it's wherever you're running that script from, you can also use CD dash space dash here to go to the last folder you're in just a little trick there. So path dot resolve is going to give you an absolute path. Well, what is der name therefore, well, der name is the directory of which the file that you're running this command from that where that directory is. So that's just going to give you the directory, but then path dot resolve.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "Resolve is going to give you the absolute path to that directory. So that's why you need these two combined in this situation, because during only as far as I understand, only exists when you're running a script. So essentially what we've put all this together for this nice little path thing. This is a really common pattern and node. You're going to see it all the time is that we just want to know what's the absolute path to the directory that this web pack configures so we can build everything from there. Oh, another thing to know, actually, is that this path resolve way is also going to work universally across different operating systems as well, which is useful for that purpose. So I'm out of my depth to really explain much more than that. That's just what I know about it. But hopefully that gives you a little bit of insight, a little bit of clue into it. And in case you didn't really know that or it's a little bit of a refresher for you. I need one every now and then. Now, let's seal the deal here by going in and adding these last files here. So in our package, Jason, all we had to do is add this HTML web pack plugin and clean web pack plugin. And then for our config, we obviously brought in path. We brought in the HTML web pack plugin and the clean web pack plugin. We had to set up an output path in order to use that. And then down here, we added it to our our plugins array. And we have that template. And then we should also obviously be tracking the index HTML template that we're using now. So there's that. And we will say. Add. Web pack, clean and HTML plugins. Push that up. And now we are in a very good position with the addition of these recent plugins and the fact that we have this set up to where our dist is wiped every time and then rebuilt and everything from it comes from our source. We can now host this. OK, it's finally time to deploy this on a server, which is pretty exciting. So there are a plethora of ways to host this, but we're going to use Netlify because it's going to be really fast and it's so awesome that it's just the clear choice for me, honestly. So let's go over here to the browser again. So let's head on over to Netlify. And you search that in Google and get there, and it's going to ask you to log in. And if you don't already have an account, you can make one with GitHub. I think that's the best way to do it, or it'll just ask you to log in if you already have one. And so here we go. This is how it works. And if you're not familiar with Netlify, just a real brief introduction. It's really popular for hosting for the JAMstack. Or any sort of like static files. And since we're using a pretty simple React single page app, this works great for us. So new site from Git. You can go to GitHub and it will usually add a little GitHub plugin for you. You can say configure in the Netlify. If it doesn't show it here, let's see if we see Webpack project. We don't. That's because I'm not sharing all of them. You can choose to share all repos or select ones, which is pretty cool. So if I come down to here and I say Webpack. Oh yeah, mine's config, right? So we're going to add that to the available ones. Save that. And now my Webpack config, I click that. And what's really cool is it is going to know the branch to deploy from. Now that's going to be whatever branch, like typically you're going to spawn off from your main or your master or whatever. And then this npm run build it detected as the build command. Isn't that really sweet? And then the publish directory is dist. It just did all that for us. So now we just click deploy site. It's pretty amazing. And what's really sweet about this is that it adds continuous integration for us, which is really awesome. And what I mean in particular about that is that every time that we push to master, it's going to auto deploy a new version of the site. So what it'll do is it'll build it. If it has any errors, it won't host it. So it won't break your current site if it have you push up an error. But if it's a successful build, it'll spin down your old one after it replaces it with a new one, which is really, really awesome. Now let's go to that build and run build. Post build command. Now if I build complete, cool. And then that'll show right here, published. So this is your URL. Now you can obviously buy a domain and set up all your stuff and SSL certificates and all that. We're not going to do that in this one. We're going to make this pretty quick, but look at that. We're hosted now. So does it work? Yes, it does. You got your cute little JavaScript clicks. I need to get rid of these images so that it actually fits on the page. And then let's go see if, you know, our script's running. Yes, you can see our objects here. It's really cool. This is just a favicon. We don't have a favicon. Classic 404. All right. So there we have it. And we're hosted. That was really easy and really cool. All right. So we've made it all this way. We have our site hosted and I have one last thing to share with you. I've left it to the end because currently it's in an experimental phase for Webpack. But that is for React Fast Refresh. So React Fast Refresh is the new hot reloading thing for React that is really, really cool. It's going to be supported by the React team. Dan Abramov has been working on it for quite some time, doing a lot of cool integrations with it. It was originally developed for React Native and it's just kind of coming around to the web as support grows for it. But for now, there's an experimental package we could use that works pretty well so far. So if you're not interested in seeing that setup, then you can call it good here and that's fine. But if you are interested or curious at all, you should stick around because I'm going to show you why it's pretty cool. And there's a little gotcha that I ran into setting it up for Webpack 5 that I'm going to show how to get around. So to show this, first I want to show what are we solving with this? Well, in our project, if we say npm start, we start that up and we're going to go back to our local host server. We have this setup and actually to make this a little more clear, I'm going to get rid of these images temporarily. And I'm going to get rid of these two just so that you can see that on screen. All right, and then I'll go over to the console so you can see what's actually happening here. So it says hot module replacement enabled as we showed before, and we know that's working for our CSS. And if we click the different state positions here, well, what happens if we were to change the text here? And I think I should probably do a side-by-side for this. I think it's going to be the easiest. Oh, man, so crushed. This is going to be tough. Okay. If we let's say that we click the state and we want to see that state here staying there, and then we want to change some text. How are you? Why did I type real stuff there? I don't know. Instead of gibberish. Notice how we saw some stuff loading and then it hard refreshed the page and we lost our state, and that's why. Let's do that again. So watch when I save this file, you can see this little guy respin, and then this whole log will reload once again. So live reloading is working, but we don't actually have hot module replacement working. But I do want to show just to be clear before I move on that if we click this state right here and we say change, oh, I don't know, the global FC to 20, what did I do, 26 before? Save that. Yeah, that still works, and it still keeps the state. So our Sass, any of our CSS hot reloading is still currently working. It's just our JavaScript that isn't working right now, our React in particular. So there's already a hot reloading for React that you can currently use, but this is essentially the new cool thing that the React team's been working on. They've mentioned that there's been some bugs and issues and even TypeScript support issues with the current hot reloading plugins and stuff like that, and that's because it wasn't actually maintained by the React team. And so this is what they're working on now, and like I already said, it's in React Native supported, but the support in the browser so far is kind of limited depending on your bundler system. But someone's been awesome enough to work on an experimental plugin for it, and so that's what we're going to throw into the mix right now. So in order to install that, this one I am going to copy over because I'm never going to type this correctly. So if following along, you might want to search React Refresh Webpack plugin to go find it or the name, or you could just obviously type it in 3Ms here. But we're going to install that, which is a person who has been kind enough to set this up for Webpack and getting that going, and then React Refresh, which is actually from the React team here. So we're going to install those two packages. Now what we're going to do is we're going to go over to our code, and we're going to need to edit our Babel file first. So all you need to do is go to plugins, and then you're going to do React Refresh slash Babel. And then you'll also want to go to your Webpack config, and then you're going to want to bring that in, just like the other plugins. So in this case, we'll do React Refresh Webpack plugin. It's a mouthful to type. And then we're going to require, and that's this P, what was it, at PM. Such a long name. There we go. And then scroll down here.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "To our plugins. And we're going to throw that into the mix. So I don't know if it matters exactly what position that you put it in here. Actually, I'm going to put it here at the bottom. Oops, React Refresh Webpack plugin. Save that. And let's try and run it. NPM run. And actually this would be NPM start, right? Because we're trying to get hot module reloading. Okay. This is where I got got for a little bit. I'm going to show it, just so you can see. Let's reload the server here. So it says hot module replacement enabled and live reloading enabled. So let's see if that's actually true. For now, let's just go to our app JSX. And here, let's try the same thing. I'm going to just click something to get some state onto the page. And then I'm going to type some gibberish and save. And look at that. It didn't actually change our title at all. It said that it hot reloaded here, and it didn't refresh the page, but it actually didn't update anything either. I'll do it again, just so you can see. It doesn't really update anything. Blah, blah, blah. That's really unfortunate. I almost gave up on this one. But after a little bit of spelunking, I was able to come up with a solve for this, thanks to trusty GitHub issues and the lovely people there. So the solve is actually pretty silly. What it is, is that they were not counting on the fact that Webpack 5, you don't have to put an entry point anymore if you want to use the default. So unfortunately, we will need to add that now, and we'll say the entry point is source.index.js. So you can use a relative path for this one. Why? I actually don't know. Output seems to be the only one that really requires an absolute path. So let's try that again. npm start. Restart that server. And let's see what we get. Go back to app. So hard on this squished view. Reload this just to make sure that you've got the current one. Click some things and then let's see. Cross our fingers. Yeah! Look at that. So now, when I change things, different HTML or text or whatever, I can even, I'll go into the, let's say, recipes one. And I can go down here and I can change this to whatever. And you can see this button change, but we keep the state. So that's really cool. So that's all it took. That will be the fix. It's a pretty easy fix, thank goodness. I mean, you know, it doesn't feel very satisfying considering the hours that I spent trying to look it up, but you know, there it is for you. I don't know if it was actually hours. It felt like an eternity. But yeah, now we've got that working. Now let me show you how cool this thing is. So the first thing that I think is super fancy here, I'm going to get rid of this just so that you can see it a little bit better, is what if you have an error when you save? What's going to happen is it's going to tell you exactly where that error is happening, and then if you just go and fix it and save, you get your app back. Now, if you didn't notice that, this is pretty crazy. Your state is still there. Let me refresh so you can see that. So I'm just going to, like, you know, make some sort of syntax error. I'm going to save. It tells me where it's at. I'm going to re-save. Here we are. Now I'm going to click this button so we have all four of the bullet points. And you know, let's just, I don't know, what's something that we can delete? It doesn't really matter. We'll just delete that. Okay. Re-save that. And we're still keeping our state. That is awesome. Now this also supports React hooks, which is worth mentioning because with hot reloading, the old plugin, you had to do additional work to get that support. And this just comes out of the box, which is fantastic. And obviously you're seeing that right now, but I just wanted to point that out. Now, in order to show a cool concept and to illustrate this a little bit better, I'm going to create one more component. And we're going to name this whatever.jsx. We don't really care. And in this component, I'm just going to copy-paste some code to just make this really fast. I'll paste this, save that, and then I guess in my app, I'm going to import that. So I'll say import. Actually, let's see if it'll auto-import for us. TypeScript always does, but sometimes it's iffy otherwise. So let's say we now want to call this whatever. It looks like it's going to do it for us. Amazing. So now we've got whatever loaded. And look at that. It loaded the new component. It just kept the state and everything. It's so cool. And so why this is really useful is you know, imagine that you're like filling out a form that you've built that's a controlled form or anything else like that. And you're trying to test different stuff out, but you want to keep it in the same state. Maybe it takes like several steps to get to a particular state, and then you want to make a change and see that. That's where this is really going to pay off. But let me show you something that's really important. So in this whatever, I have a state and set state as well. And all I'm doing is just making it to where when you click the button, it says button clicked. It's very dumb. It's pointless. But the purpose is to show that just to show you again, you already know that if I change this the state is going to stay the same. We already know that. That's cool. But what if I like remove some stuff from the DOM here? Ooh, what happened there? Well, we lost all our state. That's because the parent has to re-render. And when the parent has to re-render, all its children are going to re-render. Unless you're setting them up in a different way. But let's not get into that. So in this case, what I want to show is that if we go to, let's say whatever here, I'm going to click this button, I'm going to click this button, and then I'm going to delete the h1. And notice that it did do that. Actually, you know it's a better example. Let's do this. So with this button clicked, I'm going to delete the button. And now notice the state kept it saying button clicked even though I deleted that button. So it kept the state for itself and it also didn't re-render this other component because they're sibling components. And I'll do the same thing for recipes. We've got our state up here, and then if I go down here, and let's just say I wipe out these buttons or whatnot, I'll still have all of these bullets here, and I'll still have this state here. And that's really cool. So these two are siblings, they're not affecting each other. And that's just showing some of the power of fast refresh. So again, this is really awesome. I'm so excited for this. It's fantastic. I want to show you one more feature real quick of this that I learned while I was doing this. So you can add this pragma to the top here that says refresh, at refresh, reset. So this comment in this style with an at here is known as a pragma. We're not going to get into that but this is a way to add a little custom functionality to just this file. So what's going to happen here is now when I click this and I change some text and save, notice that it wiped the state, even though it normally wouldn't. So why that is, is this little command here is like, maybe we're a little bit too hot module reloady for you, and you really do want to wipe state every single change. Well you can just add that little pragma or that directive at the top there, and that'll change that. Now that I wiped it out, just to show you again, you know, I've changed the state and I add something here, and the state stays the same but this thing uploaded for it. So you actually have this option to opt in to kind of force a reload on a file by file basis. Yeah, they've thought of everything. So that concludes a quick little demo of React Refresh. It's very exciting, and I'm glad to have it working in Webpack 5. There's just one last step that we need to do in order to keep this production ready. And I'm going to show you that right now. So if I do npm run build, I'm actually going to get into an error. Unfortunately. And it says, React Refresh Babel Transform should only be enabled in development environment. So I just wanted to get that working to show you that, but now what we need to do, and I'm going to make this full screen to make this a little bit easier to read again. Whew, it's a breathing room there. We need to change our Babel config and our Webpack config to only enable this when we're in development. And the easiest way that I found to do that is I, this is why we used a Babel config in the first place, actually, for stuff like this. I'm going to set plugins. I'm going to make it equal to an empty array. And then here what we'll do is we will set this, let's cut that out real quick, to just plugins. And then what we want to do is do a check and say if process.env .nodeenv is not equal to production, so if we're in development, we're going to do plugins.push and then we'll do react refresh Babel. So this will say, you know, by default it's an empty array, but if we aren't in production, then we'll add this to it. You might have a better way. Feel free to leave it in the comments if you thought of something smarter, but this works for me. Now, Webpack config, we need to do a check.", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}, {"text": "We're going to do kind of the same thing here. And because we've already set up this if statement this way, it's actually not going to be too big of a deal. So what we're going to do is we're going to say const plugins equals, but a little bit different on this one. We're going to go down here to this plugins array, and we're going to cut this whole thing, move it to the top here. So we're going to start with all of the plugins here that we have by default. What we can do is we can come down here and say else, because here we're checking if node environment is production, and we don't want that there. But we could say plugins.push if it's not production. I want to push, and then we'll just snip this little line out here. And I guess we don't want the comma, but I'll get rid of it later, I guess. Cut that there. There you go. And then what we need to do now is go down to plugins and say plugins, plugins, plugins, something. Go back up. How come you're not formatting? This comma? Yes. It's always something. Okay. All right, there you go. You've got your build working. The build's working, and then let's also make sure that we still have fast refresh because we don't want to lose that. So we'll go back to here, bring up our browser, and then let's say we're back to this world again. So then we go to app, and let's just make sure that with this, man, wait, let's reload. Let's just make sure. And then go to here. There we go. Okay. So that sums that up. I'm just going to really quickly recap over this one. Well, let's do it this way. We'll finalize this whole thing here, right? So we started here with this babel config. We needed to set the setup that we just did so that we can kind of dynamically add the plugins. We know what's going on there. And then in our package.json, we've added these two packages. Yes, we know that. We have our webpack config. And this is where I'll kind of just really briefly go back over this again in case anyone misses this. So what we're doing is we're moving the plugins up to the top, and we're saying these are going to be our default plugins that we're going to have no matter what. And then if we're in production, we don't do anything but then else, which means we're in anything other than productions, probably going to be development, then we're going to push this onto the stack for just development so that doesn't break the build in production. And we needed to add this entry point for react refresh to work, because it wasn't auto looking for that it wasn't inferring the default from webpack config. And then finally, we just call those plugins down here. So move on to this, we just made a new component for demo purposes. Nothing really too much crazy to see there. And yeah, we can throw that in there. Why not? And then we'll say add react, refresh for development. Fast refresh, whatever you want to call it. Now this is where it's pretty cool. And that's why I wanted to take you through this last step. So when I get push origin, oops, main, let's go back to the browser here and see what happens. Get over there. I'm going to refresh. I don't know if this auto loads, maybe it does eventually. And you'll see that we already have a production build building because we pushed up and that's part of that continuous integration that we got from setting up with Netlify. So if we were to refresh this when this is done, you know, it'll change with our new content changes. And that's really sweet. See this is already done. Yeah, so fast. It's amazing. So reload here and boom, we've got our new stuff. All right. Ooh, I almost forgot a little gotcha here. I've got one last thing that we need to take care of for our react, refresh setup. And that's that when you run NPM run build dev, you're going to get an error here. And I got stuck on this error for a bit as well. But it's really just because when I for this little fix that I've made, it says process env node env equal to production. So where are we in the production environment? And that's when we're going to set that but else so in any other situation, we're going to do react refresh webpack plugin, but we actually only want that when we're doing the webpack dev server and live reloading. So it's going to try to look for the webpack plugin down here. This is what I've deduced that it comes from is that now in the newer webpack when you just set hot to true it automatically loads in the webpack hot reloading plugin, which it didn't used to do. And this is relying on that and it's not finding it. So all we need to do here, I just have a quick silly little fix here. What I did, you can do this however you like, but on my build debt or my webpack serve, actually, I want to set this another environment variable and you can make anyone up you want. And I'm just going to set it to true it could be any property that you could check for or whatever. And then when I come back here to webpack config, instead of doing this else, we can just do another if so let's put that on a new line. And we'll say if process dot env dot and then we'll do serve is equals equal and you can name that whatever you want. And then let's just set that well actually you know what since it since it's anything if we want to set to anything, let's just say is that set at all. And if it is, then we will go ahead and push this reactor fresh webpack plugin on there. Let's see if that works for us. Okay, and that looks like it's all working. We'll just really fast check our main js output. And there we go. We have it all here and building in the dev environment. And then if we do npm run build, you know, we always want to check our other ones just to make sure that we didn't mess with them at all. That's going to work as well. It's going to be all minified and all that good stuff. And then finally, if we do npm start. Oh, and can I click this control click now? Nice. Okay, well, that's new in Windows Terminal. I've been wanting that for so long. All right, sweet. Well, now we can see it loading our state. So working fine. And to make a quick check. And then we'll just go into app jsx here. And then I'll just change the text here and make sure that it live reloaded or hot reloaded, sorry, without changing the state or anything like that. So everything's still looking good. And that's all there was to that. Now, that might not be the most elegant way to deal with this problem. But it works for me right now. And we're in this kind of experimental mode that you might not even be in with this plugin. Hopefully it'll be a little more polished in the near future. But for now, I just wanted to show that because I had to do a little bit of troubleshooting to figure that out. And hopefully you can skip that whole phase and this will just work for you. So that is going to wrap up this whole video. And I know that was a lot of stuff. But hopefully, you've got a good concept of how to put all of these really important pieces together to create a whole webpack project. And the whole purpose for me is that at this point, I know that I probably didn't cover every little flavor and every little plugin that anyone could want, I can't really do that. But it's at a pretty good spot right now where it's extendable. You've gotten the gist of like what it's like to continually add loaders and plugins and all of the new cool webpack five, fable seven features and all that good stuff. Plus, we got the latest react refresh working. And so now it should be in a really good spot as a starter project or whatever for you to extend it to whatever your needs might be. So yeah, if you stuck it out all the way through this, congratulations. That's a ton of distilled information to take in. But hopefully you're a lot wiser for it and ready to move on with your own webpack projects. So thanks for watching, and I hope to see you in the next video. Bye. That's probably pretty bright for you isn't it baby?", "title": "Webpack 5 Full Project Setup", "url": "https://www.youtube.com/watch?v=TOb1c39m64A"}]