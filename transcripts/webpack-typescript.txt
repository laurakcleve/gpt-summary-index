

Welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and in this episode, we are going to be covering a Webpack TypeScript setup from scratch. I'm going to be going over every little piece of code and package that you need to install in order to have a basic TypeScript setup running so that you can feel a little bit more confident about what your project configuration is doing under the hood. We'll start in the terminal here, and we're going to make a directory, and I'm just going to name it Webpack TS. You could make this directory whatever you like and however you like. If you want to use an editor or whatever, that's fine. And then we'll just cd into there. And then what we're going to do is we're going to init a npm project dash y is to say yes to all the options. We don't care about answering them right now. And then what we can do is we know that we're going to use Webpack, so we'll just install that. Now, the I here just is short for install, and the dash uppercase D is short for dash dash dev, which installs it as a dev dependency. And the reason that you're going to want to install it as a dev dependency, which you'll pretty much do with all of your build tools typically, is because your end result that you're going to ship to the client, it doesn't rely on those packages. So you really just want to use them just to build the things, and then they're not bundled together in your final output. Hopefully that makes sense. And then, well, let's actually just create a file here while we're here, and we're going to make a JS file to start. We'll turn it into a TS file in just a bit, and then we might as well just open our editor of choice here. Okay. Ooh, did I do code? That was weird. Okay, so now you can see we have our package JSON, we have our lock, and then we have our index. And so let's just real quick create a age variable and just set it to 99. It doesn't really matter. And then we can jump back over to the terminal here, and then what we can do is run NPX, which comes with all the modern NPM installs. It's just a way to either use a local version of something you have or go ahead and grab that real quick and run it from NPM's registry. So we'll do NPX webpack, and this is just so you don't have to install it globally. And I kind of want to just show how you, what little you need to run this. So I'm a fan of when I'm trying to learn something, I like to go through in sort of like a red-green way, kind of like TDD, if you're familiar with that test-driven development. And what the red-green means is I want to see the error first and then make it work. So rather than install the packages right up front, like maybe a readme would do or a lot of walkthroughs, I want to show you kind of how I go through the process of figuring out what all I need to make this thing run. So in this instance, you can see that when we ran NPX webpack, it says that you now need webpack CLI. And that's kind of cool that they tell you that. So normally when you set this up, you would just see the docs saying, okay, install webpack and webpack CLI because you need them. And I just like to test them, like, do I really? Let's see. So yeah, we'll say yes. Cool. Seems like we do. And that's good enough for me. Okay. So then it finished. And you can see that we got this module not found, can't resolve dot slash source, which isn't the greatest error, but it kind of leads you in the right direction. So what this is about here is that our index.js is not in the source directory. And when you run webpack without a config, which a lot of people don't even know that you can do, you need to have some defaults in place. And one of them is that it's in the source directory. So source index.js dot slash source is kind of short for that. So now that we've put that in here, let's try and run this again. Npx webpack. And it built. Pretty cool, huh? So let's jump back over here. And you'll see that a dist folder was created for us. And then if we go into this, we'll see a main. Now there's nothing in there. Well, that's because we're making a production bundle. And we created this variable, but it doesn't do anything. So if we were to log it, for say, whoops, just type the number in, you silly goose. And then we'll go back and we'll run it again. Now you have to run this every time you're going to build. We'll do a watch mode in a minute. But for now, you have to run it each time. And now you can see in your main.js, it's going to do console.log the number. Okay? Because what it's trying to do, it's not going to try and build every single line of code that you are writing. It's going to build what you need to run your program in the end. All right? Now we want to keep running this script. So what we're going to do is we'll make a script called build in our package.json. And then we'll just run red webpack, just like we did before. All right? And then now, whenever we want to run this, we can just do npm run build. And that'll do the same thing as our npx thing. That's just so that it's actually local in our project. Now, we're going to change our index.js to a ts file. Okay? And then we're going to do the same thing. We're going to come back here. We're going to try and run it. And you're going to see that it fails. So the error here is the same that we just got before. So that just kind of clue us in now that we've solved that. It can't seem to find that file. All right. Well, that is because what we need at this point is a webpack config if we want to actually use a ts file. So if we make a new file in the root of our project, we can name it webpack.config.js. And that's your default there. And then this is just going to be module.exports. And you're going to export a sort of a config option here. Now, what you need, the minimum that you're going to need for this is actually just to resolve that file extension, surprisingly. You don't even need a loader at this point. So extensions is going to be.ts and.js. So we're saying what I want you to resolve or look for is anything that ends in.ts or.js, because by default, it's just going to look for those js files. OK? And now, if we come back over here and we run this again, you can see that we got a build. All right. Well, let's check it out. Did it work? Yes, it did. Pretty normal, right? Now, we're not writing any TypeScript code just yet. So let's add some TypeScript syntax here. So we'll say that this is a type of a number. And then we will run this. And now we get a different error here. We get this unexpected token. And this is where it actually happens. So it's nice enough to show us that. And it gives us sort of a hint. You may need an appropriate loader to handle this file. That is correct. I wish it would try to steer you a little bit more toward like what kind it is. But that's probably pretty hard just from a random token error. So that's all right. So what we need right now is we want to run npm i dash d ts loader. That's the loader that we want. And then we'll just jump right back over to here. And if we go to our webpack config, we actually need to set up our loader now. So this is a little bit more involved. But this is pretty much the normal song and dance for webpack. So once you get this down, it'll just make your life a lot easier. So what we're going to have is a module type. And that module has rules. And that rules is typically an array of objects. And then here we have a test. And so what I'm going to do is I'm going to write a regular expression here. And I'll explain that in just a second. And then we'll say, what do we want to exclude? Because we need to say that we don't want to run this on node modules. We don't want to run it on other people's code at all, other packages that we're using. And then the last property that we need is the loader that we're going to use. So we could do loader ts loader. And then we're going to need a comma down here. And then we're good. So what we've written here is we're saying, OK, when you're processing any of my code webpack, these are the rules that I want you to go by. Now the test is what you're testing files against. So it's saying, hey, if there's ever a ts file, because this regular expression is capturing anything that ends in.ts, this dollar sign says ends in that character there. And then we don't want to run on node modules. And this is the loader that you're going to use. Cool. That's it. Now let's come back and run this one more time. npm run build. Whoa, we got a big old error here. All right. Cannot find module TypeScript. All right. Well, that's pretty simple, right? We'll just do npm i dash t or dash d TypeScript. And then we're going to run it again just to see if it'll run. OK, now we have another error. No worries. We're making progress here. And we're kind of figuring out exactly what we need as we go along. So we can see that ts loader requires TypeScript to run. And then now it says the files list in the config file, ts config.json is empty. When I first encountered this, it got me for a while. This is a terrible error. It really, I don't understand why they can't just tell you this. But really, what they're trying to get at is you need a ts config.json. And this happened to me one time because I actually just misnamed it. So the whole the files list in the config is a bit confusing for that. Now let me show you how you can get a ts config going pretty easily. So if you run, we'll use npx again. There's a tsc here, and that's for the type of file.

script compiler, and you can do dash dash init. And what that will do is create a ts config in your project. So let's go over here and look at that now. And it created this file. And you can see it's got all of these options. Some of them are just here automatically. And a bunch of them are commented out, which is really cool because it's just showing you the defaults. So for instance, no implicit any is by default set to true. So you can turn it on and we will in a moment to like disable that or change some settings if you want. But let's just go with the basics here. So now let's try to npm run build. And again, and see if it'll work. Boom. Okay, we got some output sick. So now if we go to main j s, you will see that we got our output, like usual, it's getting a little bit harder to read nothing crazy here. Of course, we can read it because the code so short. But let's say that we actually want to be able to read it as we go along. So if we go into this webpack config, there's another option we can add in here. And this is what's kind of cool about the not needing a config a config less setup is that you can just add things as you need them. And we can set this to development as the mode because by default, it's production. And then when we do this, what will happen is when we run this build, and we go back to our main j s, we will see a completely different format. Okay. And this is close to what we want. But there's some weird stuff here. But check out this nice little comment they've given us the eve al dev tool has been used maybe by default in mode development. Yes, we are in that. And this dev tool is not neither made for production nor for readable output files. In the end, basically, what they're kind of pointing us to is that we can disable this by doing dev tool, tool false, or setting that to some other dev tool configuration that they give us a nice link to. So let's come down here and say dev tool. All right, turn that off. No dev tooling. Let's run our build again. Come back to our main j s. And there we go. Okay, so now we have a nice little readable output that we can compare and see what our stuff is actually being built into in the end. And now you'll notice that our TypeScript is actually just being compiled to regular old JavaScript, right? So that's pretty sweet. So that's working fine for us for now. Let's actually set up a watch script now so that we can make some changes and see the code change on the fly. So there's a couple things that you patterns that you could follow here. I like to just do the colon pattern here and say, well, build colon watch is the mode that I want. And in this case, I want webpack dash dash watch. And this just comes with it. So it's really nice. And then if we come back over to here, we can say npm run build colon watch. Oops, typo. And so what that is going to do now is watch for any time that we change any of our ts files. So now come back over to here. And let's actually change some stuff and write some TypeScript here. So if we were to do, let's say we'll make a function, we're gonna call it wolf. And wolf takes in a noise. And that noise, we're going to console dot log it. All right. And what you're going to notice here, let's go back over to the terminal, because it's actually going to TypeScript's already kicking in here with its linter, that's saying implicitly has the any type, which we don't allow by default in the config. And we're getting that IntelliSense in our VS code right away, which is really sweet. So it's saying, yeah, you can't do implicitly any. Now, it's kind of weird to me, though, about this is that if you look over on the side here, you can see that our output is there. And if I were to just like, remove this, let's say, and save, you can see the output updates, even though I'm technically building an error here. But if you were to run npm run build, so not putting it in watch mode, you'll see that we actually get a failure on the build, which is what we would want. In TypeScript. So just so that you know. So let's actually change that in our config here. So if we go over to our webpack, actually, our TS config, sorry. And we can go to this no implicit any. And what we'll do is we'll set that to false. And so now the interesting thing is that this will pick it up right away, VS code will not be yelling at us anymore about that not being true there. But also, if we restart our build, it will actually build properly. So you can see that it's using the TS config to determine some of the rules that TypeScript wants to set up. Okay, so let's flip that back on, though, because we are going to want that. And you can actually just recomment this if you want, if you if you just want to do it that way. But it's nice to leave it, you know, set to true so that you know the defaults in case you forget. So now let's go back to watch mode. Watch here. And we'll get that error. And that's fine, because we're going to fix it in a moment, we're going to be bad kids and actually write any here. Okay, and got a reason for this. But typically, of course, you want to avoid any in TypeScript, if you can. So where we're going to leave that any now is for my illustration purposes, what we're going to do is we're going to create a object. So we can get some real cool TypeScript functionality going on here. So you can see that it's building more than just the simple types. So if we create this object, we're going to make it nested object here. So I'm just making up some random keys for fun. And then we're going to do an awu. We've got our dog noise here. And then you can see all this code is being built out here. Now remember what I said before, we've switched it to development. So it's actually printing out our code. If we were to switch it back to production mode, all of this is going to go away. And just the final output is going to be there just as a quick reminder. Now, here, what we want to do is say, call the wolf function, and we're going to pass it object. Okay. And you can see that getting called. And then what I'm going to do right here is I'm gonna open up my terminal down here, CD into this directory, because it didn't think that it could be cool enough to do that for me. And then we'll run node, and we'll go into the dist folder, and we'll run our actually its main.js. And there you go. You can see it running our code. And just printing out this object. All right, great. But that's not quite what we want yet. I'm going to get rid of this log here now just to clean this up. And then what I want to do is say, okay, well, what if we were to call noise.1,.2,.3, and then run that instead. And so now if we run this, we'll see we get our string printed out. But what if we weren't going to pass that in? Okay, what if we passed that in? We passed in like null here, let's say. All right. We run that, we're going to get an error. Okay. And I'm just opening this in this terminal just so that you can see it in line here. Our webpack is still running in the background every time we change on the other terminal. Sorry. So console.log noise.1,.2,.3, you know, pretty, pretty standard issue here, right? Like we tried to run a property or call a property on something that doesn't exist on undefined. Cannot read property one of null in this instance. So okay, how would we normally solve this? Well, if we weren't in, let's say, TypeScript here, we would do noise. This is one way. Noise.1, noise.1,.2. Everyone hates this world, right? Noise.1,.2,.3. We checked 1, 2, 3, I even got to look it over. And then now let's try and run this. And we'll just get null. So at least we don't get an error, right? Get what we expected here. And then you'll see in our output on the side, that we have just a bunch of ands. It's just normal JavaScript, just the way that we wrote it. But what we could do instead is we could do, why can I not type? Noise, and we can use the optional chaining functionality built into this. This is actually in the latest version of ECMAScript as well, but TypeScript's had it for a little while, and we're going to show it generating that out with TypeScript. So what we can do is say, does noise exist? Okay, well, then access this property. What about that one? Okay, and the next one? What about that one? All right, the last one. Through three. And then now we run this. Boom. You can see that we get this null and undefined. They're a little bit different. And I'll talk about why. If you come over to here, let's bring this over here a little bit, got some stuff in the way. You'll notice that the first one that we wrote is a little bit different than this one. And it's kind of interesting, huh? There's this very long set of like void code. Actually, I'll make it a little bit longer. So you can see it this way. You know, doing multiple different checks with ORs and ternary here. Okay, so why is this? This is actually by design. The optional chaining is trying to be a little bit more robust and reliable here, because if you were to type in just zero here and run this code, what's going to happen is you'll notice that zero got printed out in this check, and then undefined was printed out in this one. And typically what you would have wanted was undefined. You're saying, hey, if you don't have any of those properties, don't just break, but just return undefined to me. But the thing about it is zero in a double ampersand check actually returns the value, because this first value that does exist, it's zero. And that'll be the same with like an empty string and some others that just wouldn't give you the behavior that you would normally expect. And it's kind of hard to troubleshoot. So that is optional chaining. And at this point, uh,

you have a TypeScript setup working, which is pretty cool. You can see it transpiling here and you can see it line by line in watch mode. If you're curious about what it's kind of doing under the hood. And I don't understand as a quick note, uh, you know, all the code that's being generated out, of course, uh, I just like to peek under the hood every now and then to get rid of a little bit of anxiety of like the mystery of what Webpack's doing. It's kind of cool to see what it does under the hood, uh, just to get a quick gist of it. And then I can, you know, move on with my life feeling a little bit more confident. So we're pretty good. Here at this point, uh, I'll give you one last little piece here, uh, to make this a little bit more flexible for you. What you can do here for this mode, because you might want to switch back and forth between, um, production and development. Now you don't even have to put anything if you want production, just as a reminder, and let's go back over to the terminal here. Um, and stop this build. Cause, um, whenever you change the Webpack config, you do have to rerun this and we'll just run a regular build here. And then what I want to show is the output is going to go back to this minified version that you'd want for your final output. Okay. And I'm going to close this for a moment. So to go between those easily, you can do something this simple. You can say, um, whoops, you can actually access a process dot ENV dot. And then typically you're going to use node ENV here and you can actually go to the output. And you can say, if that's passed in, um, I want you to use that. Otherwise I want you to default to production. Okay. And now what we can do is we can say, all right, let's set our node ENV here and we'll set it to, um, development. Actually, let's not set it the first time, just so you can see that. So if I just run NPM run build now, uh, and go back to here, our code will just be run in production mode, just so that you can see that it works. And then now we'll set node ENV equal to development and we'll do NPM run build. And we'll go back over to here again, and you'll see it ran it in this mode. And just so that, uh, in case you're wondering, Oh, well, what if we just pass something non that? Okay. Well, typically your system shouldn't be doing that, but if you did happen to do, you know, woofers or something, you can actually do that. Something like that here, and then do NPM run build. You'll see that you get an error. It'll tell you, uh, we expect the development production or none. So it's pretty nice. Um, that, that, that's the gist of it. And then now, if you want to just set up some scripts where you set node ENV or however you like to do it in your system, um, you've got a little bit more flexible config. Now, of course, there are a bunch of other rules that you can set in the web pack and fig. Uh, you can find those in the docs, or I actually have a video that, uh, more thoroughly goes through a web pack, trying to understand the basics of it. And it covers, uh, like source maps and having a web pack, dev server, uh, entry and output points and all that type of stuff. I'll link that in the description and a little notification card in case you're interested in that. And I'll probably be doing some, uh, future videos pretty soon about the different types of loaders, like probably doing style sheets, SAS, and all that type of stuff, uh, in the next set of videos. So if you're interested in that, please like, and subscribe, and I'll see you on those videos.