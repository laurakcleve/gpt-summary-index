[{"text": "Hello and welcome to Swashbuckling with code. I am Jimmy Cleveland and in this episode we are going to cover JavaScript promises and async await. In JavaScript, promises are a way to achieve asynchronous results, which essentially means that they do not block the execution of code. Probably the most common example of that would be fetching data, like say from an API, and that would still allow your users to continue interacting with your app or your website. Because making an API fetch is one of the most common use cases of promises, that's where we're going to start out. We'll make a simple fetch and then we'll do something with the data, such as logging it. After that, we'll get into the foundation of writing promises using the new constructor, using promise.resolve and reject, and also going through the various then and catch statements that you can chain on to promises. After that, I'll show you how to make some nested promise queries and we'll also show how to flatten those whenever we can to keep it nice and readable and composable when we're writing our promises. Finally, we'll wrap it all up with a async await example when our promise nesting gets a little bit too unwieldy. Hopefully that gives you a good idea of what the content structure is going to be so that you can use the timestamps to jump around wherever you need be, depending on the level of knowledge you already have on promises. But with that, let's get into it. For this video, I'm going to be using a few different mediums to showcase the things that we're going to be delving into with promises because I think it's nice to have different ways of visualizing it and some of them do it better than others. For one, we're going to be using Firefox in a couple different ways. We'll be loading up an HTML document like normal that runs a script, but I'm also going to be using the console because I like the way that it represents promises in their different states, which you'll see in a moment. I'll also be using Quokka as a VS Code extension and you'll see why I kind of like that when we get to that point. I'll explain it. So we're going to start in the Firefox console here. So the first thing I'll do, of course, is bump that up for you all the way. As much as it can go, that's actually max, just so you know. And then what we're actually going to do is use this nice little icon here that shows you this multi-line editor, which I think used to be called a scratch pad. It's a really nice feature that Firefox has. Let's bring that over here since we'll use the whole real estate. And what's cool about this is it actually lets you write out code and execute it whenever you want, rather than executing one line at a time or as you like write one function. It's a little bit akin to writing it in an editor, which you'll see. Now for this first example, rather than diving into the basics of promises and their various methods, I want to start out with a very simple but common example of using promises so that you can kind of see what we're going to be building toward and you have something to base it on. So in this case, we're using the fetch function, which is native to browsers nowadays in JavaScript, but not in Node. And what we're doing is we're going to be making a fetch to this API, which is the Star Wars API, which is a nice little public API that you can hit to get some various data, and you'll see in a moment. And then we'll be doing these various things, which we'll talk about in a little more detail, but you can see that eventually we're going to console.log the response from this, and then I'll go and create a variable, and then I'll console.log that. So when we run this here, you can see what happens. It first shows the code that we created, so don't worry about that, and then these are the actual things that are running here. And you'll see that we got created after fetch call. This variable was logged first before this log happened. So for some, that won't be too much of a surprise, but for some of you it will. So why is this happening this way? Well, let's take a look at the code that we're going to be running. So why is this happening this way? That's because fetch, or promises in general, are a sort of asynchronous methodology in JavaScript, which means that rather than running synchronously, which means line by line, they go off and they do something, and then they report when they're done. Think of it that way. So normally, of course, when we run our code, each one executes one line after the other, but in this case, this goes off and does its thing, and then these are able to continue on, and that's why you get this first, and then when that response comes back, then you get it. In this case, we're just logging it, but of course, we could do various other things. There's a really great video by Philip Roberts on the event loop, if you're interested in learning a little bit more details about asynchronous JavaScript and kind of what's going on in the background and getting a better mental model in your head. I really recommend that, and I'll link that here. Another recommendation I have is by the always entertaining Jake Archibald on the event loop as well, and it's a really in-depth, detailed video about set time out and promises and all sorts of good stuff like that that I really recommend checking out if you're trying to get a good mental model on what's going on in JavaScript with asynchronous behavior. Let's actually start with the MDN docs with promise to get into, you know, how the different methods and states of understanding it. I'm not going to be, you know, thoroughly going through all this, just using it as a reference, and I highly recommend, you know, browsing through it or reading it whenever you get a chance because it definitely is really well written. So for promises, this is the most important part to start with, I think, is that there are these three states. There's this pending, fulfilled, and rejected. And so what we're going to try and do is showcase that. You'll also see that there are these general methods, and I'm actually going to start with promise.resolve just to kind of see that. So when you write promise, you can actually just call it like this and say resolve, and when you do that, you'll see I'm so I'm going to press ctrl enter here, and that will run the code. You can also click this little button if you're using Firefox and following along. And here you'll see that we have the state fulfilled with no value, right? So what if we just put a value in real quick and say value and some other stuff just so you know no reason. I refresh just to rerun it here and clear that. And here you can see that we have the same thing, but now we have this value stored in here. This is something I really like about Chrome and Firefox is how they represent promises when you run them. They show you this promise object and the state and the value of it. So there's our first state we have fulfilled, right? So that was one of them fulfilled, and that's when we just resolve it. Hopefully you'll understand that a little bit better once we start building our own promises, but that's just a fire off of resolve right away. So what if we fire the reject method? What happens then? We'll say go away, all right? I'm gonna refresh that just so we don't have any noise. When I run this, so the first thing you'll notice here is that we have this error, right? And that's always going to stand out to you first. You can actually ignore that for now. We will explain that in a moment. It's just an uncaught error. But then we get this promise object state and it's rejected. And notice that it's not value, it's reason. And the reason is go away. So we've got rejected here. We've got our fulfilled. So how do we get a pending state? Well, these are actually evaluating like instantly here. So let's try to do something like this. Well, let's use the promise constructor to demo this real quick. So I'm going to say new promise, you can call it like that. And then what it takes is a callback here that will give you a resolve and a reject method. So we're going to just accept the resolve for now. And then we'll just use a quick arrow function. And what we'll do inside here is we'll use a set timeout. And we'll just have a function in that set timeout that calls resolve so that we can pass it a value and say I waited. And then after that, of course, we will pass in milliseconds here. And let's just do like 1000. So we have a second, we're going to wait a second here, and then see what happens. So what we're doing here is we're showing that we can actually by waiting to resolve this thing, once this promise is created here, the promise as soon as it's printed out as it's run is in a pending state, which is our final state here. And that will be a little bit more normal when you're using promises. So let's say that you're making an API request, it's going to be in the pending state until that API request comes back to you with either an error or the data that you wished for, in which case it will be fulfilled or rejected. Now, you'll notice that we didn't get any sort of log or anything like that from I waited, right. And that's because all we're really doing is calling that resolve function, which is going to give us something that we can run a then method on. So let me actually store this variable real quick and say my promise equals will make this new promise. So if I just try to access my promise here, and refresh and run that, you'll see that we're still just going to get this state pending. What happens if I console dot log, my promise, okay. Same thing here, right? Just getting this promise state pending, that's time it's actually logged here. But what we can do is write my promise dot then. Now the promises is doing this sort of IOU behavior, which is saying like whenever I am ready, then I will pass you back this thing. So in this case, we'll say dot then, and what we'll get back with the then method is a some sort of response, what it's commonly referred to. And with that response, we can do whatever we want. So let's console dot log the response here, run that code. And you can see after a second, it says I waited. Now something interesting we can do here is that we can on a new line here, let's say, I want to console log my promise. Okay. So we're saying, once this dot then fires, and it should be in a fulfilled state, after we log out our waited, I waited, can't talk, run that again, and you'll see I waited, and then the state is fulfilled. So here you can see a promise going through these different states, going from pending to fulfilled once it's completed. So a promise also takes, or gives I should say, a reject method here. The callback takes it, and from here we could, after a set timeout, just call reject. So reload, I'm going to run this, and let's see what happens. Notice that we got uncaught in promise, I waited. We don't actually get this state right here. And that's because when you get a rejection, the then method actually isn't going to return it in the first callback here. This is a little bit confusing of syntax to look at, but let's see if this is the whole first argument of the code.", "title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}, {"text": "And then the second argument is what I'm going to put is, let's say, error or something like that. And then here what I'll do is I'll console.log error in this case. And then also I'll do console.log my promise, reload, I'll run this. And here you now you can see we got the I waited value still. That was the error that was passed. But this time it says the state was rejected, and that's the reason, is I waited. So you could, you know, in this instance, do console.error here. See that? So you could kind of just put your own console error, however you want to handle it. And the point here is that rather than actually throwing an error and halting your execution, you might want to do something else. You might want to have a fallback state, you might want to send it off to your logger if you happen to have a logging service, etc, etc. The choice is up to you. I know the syntax is a little bit confusing. This is the first argument, and then this is the second argument that it takes. Now I don't commonly see people use it this way. What you can actually do instead of this, let's take this right here and cut this out, is you can chain on, and I like formatting it like this because I think it makes it a little bit easier to read. Oops, let's dial that back here, sorry. I like to chain it like this so we can actually continue to chain one method after another, you know, just like, you know, map filter reduce or anything like that. But we can do a catch block here. So in this case, I'll paste that code from before. Oh goodness, forgive me, this is very difficult. I am not normally going to be editing inside of the browser like this, you know, I'd be using my IDE, but I'll struggle through it for your sake. So here, now we have this catch block, which is really interesting. And so what this is going to do is catch whatever this error is, and then we can do whatever we want the normal way that we did, but instead of doing it in this, you know, more confusing, harder to read syntax where it takes these two functions, we can just do it in one catch. And you can see we get the same result here, right? Now we don't need this then here, just to be clear. We could just go straight to the catch. I don't know why you would ever do this. But we could. The point is that this is this really neat format that a promise when it gives you the sort of IOU back, depending on the state, it will go through these various different chains. So to take it a step further, to show you the generic kind of model here that you want to be using, what you can actually do is from this then you can return something, and that is going to be received here. So let's say I'm going to return, even though I'm logging it out, I'm going to return a response, okay? And what that will allow you to do, let's say we'll go back to this being a resolve, is chain onto it further from that. Now I'm going to not do that first just to show you that I will get the IOU response, which is this console log here, and then we're logging out the promise being fulfilled, and then we return, but it doesn't do anything after that. That's because the catch block is not going to be fired because it's not an error, right? But I could do another then. And I can name that whatever I want. I can change the name or I can keep it the same, since you know we're at the same scope level here. Goodness. And then what I'll do here is I'll console.log the response one more time, and maybe to make this a little bit more clear we'll say first then, and then we'll say second then, and then I guess let's just put this here. We'll leave that as an error because we know what it is. I'll return that and I'll run it. Oh whoops. Missed a comma. Rerun that again. Okay, first then, I really should put a colon here, make that a little more separate and easy to read. But first then, I waited. Second then, I waited, right? Now this seems pretty pointless at this point, and it should. But you can see, it's just to illustrate that you can continue to pass this down by returning from a promise. Anything that a promise returns will be thenable, or you can run then on on the next step. If I were to return an error here, let's say, or just throw an error, how about that? So throw new error. It will get first then, I waited. So this actually got hit, but then I threw an error, and the catch block caught it here. In fact, let me add catch block. It's not really a block, I guess. See that? Just to be sure, so that you know. So it's skipping this step right here, and I'm going to show that. I think it's a little easier to understand or kind of see going on in my VS code in just one second. What I want to show here is that to end it off, if we go back to the return, we can actually change our values. So we got that response, right? But there's nothing stopping us from adding on to that or changing it or, or let's, let's completely flip it up here. Let's return an object that I'm just going to make on the fly, and I'll say, you know, value is response, oops, response. Let's not make that a string. And then something I added this. Okay, so right here we have this first then right here got called. Then we'll see here that the promise fulfilled, yada yada yada, that's this log right here. But then the second then, that is right here, okay? That logged this has this object, which has something I added this, and the value I waited. So that's this original value I waited. And we don't have to return that. I mean, honestly, we could return anything we want, ignored the response, right? Last example here. Last example here. Just to show that, you know, the second then ignored the response. So you can do whatever you want in these promise chains, you can just keep returning and then and all that stuff. Let's take a look at that in a different view to kind of show how it bypasses things. So in this case, in my editor, I've got just a simple index JS here that I'm going to be writing for just a moment. But what I'll do, let me close that. So we've got full real estate here is I'm going to start Quoca on this start on current file. And if you're not familiar with Quoca, it's a very nice little extension. It essentially continuously runs the code that you write in that file and gives you this nice way to print it out. You know, seeing is probably better than being talked at. So here we go. So I'm going to write a const, and I'm going to call this success promise. And then we're going to make that equal to a new promise. And we'll do the same format as before, we'll pass it a resolve. And in this case, I don't need to get reject off of it. So I'll just ignore that. And then here, what I'll do is I'll just call resolve. And of course, you know, normally, when you're making a promise, if you're promisifying things, as it's commonly called, you could be doing all sorts of things in here, a common thing is that you set time out to cause a delay after so much time, etc, etc. But you know, let's just stick with the basics here. So we've got this resolve, and we'll say, you know, resolved value, something like that. Now, you can see on the left here, I've got these little green boxes, that's Quokka, letting me know, my code is actually running. And you'll see that in just a moment here, some differences. Okay, so next, let's make a new variable here, failure promise, that's going to equal new promise. In this case, for our callback function, I'm just going to put an underscore since I'm not using that variable. And then I'll do reject, we are going to use that. And then let's just call reject. This time, I'll do rejected value. Okay, so this is where it gets interesting. So what we'll do is we're going to call success promise. And you can see that Quokka prints out this then resolved value, which is really interesting. So what they do is they go ahead and even though you're not calling the dot then method on it, they're saying after you run it, then you'll get this, it's really neat. What's kind of interesting is if you do failure promise, they'll put a catch rejected value. So they'll say, well, this is this would only print out in the catch block, that's what you're going to get is rejected value. Let's make that rejected. So we don't miss it. So let's go back to the success promise here, we can do here is we can then chain off of this. And so let's do our value or response or whatever you want to call this, it doesn't matter. For this first level, I will say console dot log the val. And you can see that we get this resolved value, it's the actual one, it doesn't say then at this point. But I can also in Quokka just print it out by writing it there. And then I will return that value. Okay, I'm gonna write another dot then here, just going to chain it along. You know, that's weird to you, it's just the same as that, calling it afterward, but I can put it on a new line. We'll do one more here. And then what we'll say is, we'll call a val again, do the same thing, make sure what we have the val is. And then we will return. I'll set this up in one second, let's do a val one more time. And then finally, we'll do a catch block. And this catch block, we'll call it an error. And then here's where we will", "title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}, {"text": "console.error. Now you'll notice that this little white block appears here, which is kind of interesting. This white block is saying that this code didn't run at all. And that's because we don't have any errors at this point. If we were to switch this over to failure promise, you will see that we get the rejected value and none of these ran, but this one did. This is a really nice thing about Quokka that I like, it shows things that were skipped. Let's go back to the success promise. Now check this out. What if I return from here failure promise? Isn't that interesting? I don't know why it's saying reference error. Oh, it hasn't like updated yet is why. If I save, I'll do x e. Sometimes it gets stuck like that, don't worry about that. So here you can see that this first block ran, but then I actually returned a whole promise, not just the value from that promise. Isn't that interesting? So I returned a promise that called reject or called resolve. And because I did that, it was caught in the catch block. So if I do success promise, you can see once again, this one will run, it won't run the catch. And then finally, if I return success promise again, it's not going to do the catch block, it's just going to, you know, you basically have kind of left it open to be bend on one more time, but you're not doing anything with it. But if I ever do failure promise, now all of these code lines execute. Let's go back over that briefly one more time here, what happens here. So we start with the success promise that we make a new promise, and then we just immediately call resolve. We don't do anything because it's kind of a useless promise at this point. But you know, it's for example purposes. Then we also had this failure promise. We did the same thing, but we just did reject. We start with the success promise, and then we say dot then. So when you're done resolving that promise, which in this case is instantly, well instantly in an instantly in an asynchronous way, to be clear. So then we're going to get a value, we log that value out, and coconice, and it just puts it right here for us. And then we return the success promise, and that success promise is a promise that resolves. And so since you have a promise that resolved, you can then move on to the then. And then finally we return the failure promise, which triggers this catch. And as you saw, if you put this at any point, it'll go and trigger that catch. So you can return values from the promise and keep thening on them, modify them, whatever you like as you've seen, or you can return a promise itself. And that will be really important to understand in an in an upcoming segment here where I'm going to show nested promise fetching and how you can flatten that out a little bit. Because a lot of people seem to not realize that, and they just jump straight to a single wait. So now that we've gone over the basics of writing your own promises and creating them and all that such, and how you chain them with enables, let's come back to making a fetch request, because that's I think the most practical and common example. So we're going to start our fetch. And you could use Axios. I if it kind of depends for me, fetch is nice, because it immediately runs in the browser, and you don't have to install any packages. And that's why I'm going to use it here. If I have a larger scale project, I probably use something like Axios because of the ability to set defaults and not have to set your content headers and all that good stuff, just so you know. But we'll stick with fetch here. It's nice just be able to reach for natively. And so what I'm going to do is I'm going to do https://swapi.dev API, and then you can go to people again. And in this case we'll still just do, we'll start with one. Okay, so we're going to get that fetch working. And then it's just kind of common to format it by putting it on the next line, because it makes it a little easier to read through as a synchronous sequence of steps. So we'll say we're going to get a response back, right? And that response, this is kind of an odd thing about fetch compared to like something like Axios, is that you have a bunch of different ways that you can kind of convert the data. The most common that you're going to do for like a JSON API is just call this JSON method. And so that also is going to return this value that you then want to then on. Okay, and in this case we could write response again, or we could make it like maybe a little bit more readable and say person. So we got a person back, and then here let's console.log for now person. Why do you format this way? Okay, let's run that. You saw that we got the state pending, this was just our code, and we're back where we were before where we have all this nice data for Luke Skywalker, right? Now to show a kind of a silly use case about how you could do something besides console.log, let's scroll this over here. And if I go to my inspector, what I've done is I've made this little pre tag here that has an id of result block. So let's go back to our code, and what I'll do is I'll just simply grab that. So I'll say const pre block equals, or we could do pre tag whatever, document.querySelector, and then that's an id in this case, and so I'll do pre block, oops, can't type, and I'll do a space just to make that clear. And then here instead of logging this, what I could do is say pre block dot inner text equals, and we'll do json.stringify. We'll take the person and dump that there. We'll do the standard null and then two space indents. Oh, we got an error. What was that? Probably from pre block is null. Oh, don't be silly, Jimmy. It's, what do we do that as? Result block. Result block. Apologize for that. Oh, we're all over the place. Ah. Let's refresh. So we'll run this again, and I'll just lengthen this just for a moment so you can kind of read it here. So yeah, we're going to call it once we get the data back, turn it into json. It's actually just called the json method, so we're turning it into an object here, but then we're going to set the inner HTML here. So if I run that, you can see that I'm just dumping it on the page here. And if I didn't put this like null and two, it would just be one long string all the way across. It wouldn't format it, just so you know. So really the only reason I've done this, it's not much different than logging it out, it's just to show you that, you know, you could do whatever action you want in here, and in many situations you might just dump some data, or you might, you know, have a an object up here that you're, you know, assigning that data to. You're causing some sort of side effect, I guess you could think of it as. Now let's take this one step further here, because I think that's kind of interesting, is what we get from this data. You'll see that the way this API works is that a lot of these values are sort of static, but this one is a URL in order to hit. Isn't that interesting? And that's because Homeworld has all its own data, and rather than, you know, like either, it's just a way to write an API where you can have these kind of, just like variables, like dynamic endpoints that it hits, you could obviously make your back end like go and grab all of that data, but in this case the way they've made this API is to just grab kind of the minimum of what you need, and then you can go and grab more if you need that. So let's take this line right here, and we'll cut that out just for now. So what we want to do is we say, okay, well we've got our person, we've got Luke, but I want to know his Homeworld, okay? All right, well what will we do here? We kind of just need to run another fetch. We can't really run it outside of this because we need to go get the person first, and that will give us the data that we need to get the next thing. You'll run into this situation quite often quite often when you're doing any sort of complex queries or anything like that, where you'll get, you'll do some sort of promise, and then based on the results of that, you need to take that data and do something else. So that's what we'll do next here. So I'm going to fetch, but what's interesting about this is I can just say person.homeworld, because this is the person we got back, and then we're just going to go to that Homeworld. We're going to do the same song and dance again here. Let's say we do a.then, and it's really common to do this res.json, just to make it shorter. Most people will do this with res. I'm kind of a stickler typically because response and resolve and some of those other things are similar, so I like to write out the whole word, but of course if you want to be succinct, go ahead. I prefer to be a little more declarative typically, but just to show a common pattern since you'll see it a lot. So there you go res.json, and then we'll say okay well after that, then I want to, let's say we're going to have Homeworld at that point, and then we can do the thing that we wanted to do before, which is this pre-innerblock, but we'll swap that out with Homeworld. Okay now we're getting a little bit crammed here, but I think you get the idea. So let's run that now. I'm just refreshing, and notice that now it prints out the Homeworld that Luke is from, Tatooine. So we've simply just nested these different fetches. Now I hope you can see at this point how nonsensical this could get, and if you happen to have been around in the time of callback, you know callback hell and Christmas, tear of death, and all those various terms, it's got an eerily similar vibe. You're going to keep nesting if you need to keep doing things. It might not even be API fetches, it might just be general data stuff, and it's going to get messier, messier, and messier. And let's say what, you know, the next thing you want to do is, you know, get these residents or get the first film or something like that. You know, you're going to have one more...", "title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}, {"text": "fetch there. So what we actually can do, we learned this earlier, that you can return not only the value but a promise, and from that promise you can do a then. So what if instead of kind of nesting it like so and doing this pre-block here, we were to say return this fetch, and of course you could keep the then here. I'm personally a fan of breaking all of my thens into their own thing, and I'm going to do it that way just to show you. So here, this is the end of this sequence here. So we've got that, and so that's this then here. Oh, I missed something. Uh, we need that, that's this, whoopsie daisy. So let's get that. Yeah, that looks better. Oh, braces and parens, how you get me. So then we'll do this, and we've got that. Oh my goodness, formatting. And I'll just bring this here just to give you a little bit more real estate so you can see it. There you go. Okay, normally if you're in a normal size editor, this is closer to what it would look like, but obviously we're all zoomed in. So do you think this is going to work? Hmm, hmm, it does, because we simply learned that we can return that promise. And so rather than nesting it, you can keep this nice and flat and sort of instructional. So you can see now, because we're using fetch, Axios would be a little bit cleaner because you wouldn't have to do this extra JSON step, but regardless, you can see how if you're doing a bunch of promise stuff, you can you can read it as a sequence of steps, which is really nice. You go and you fetch the thing, then you do this, then you do this, you're going to get that data back from a promise, then you can move on and process that as JSON, and then you have the home world and you can do whatever you want. We can actually make this a little bit easier, nicer, because we we could keep this all fancy for doing simple stuff like this and use an implicit return. And then we'll just reload just to show that that still works, and then it's even a little bit cleaner. Now it's not always going to look this nice, but a lot of times it actually will if you're doing pretty simple operations that you can just return. One value just returns to the next, returns to the next. The same idea is like mapping, filter, reducing, all that good stuff that you typically learn in declarative programming and all that good stuff. So if you can, you want to be flattening your promises as much as possible. It just makes them a lot easier to read, not have to deal with the, you know, the nested Christmas tree of death nonsense. But I'll throw in a little disclaimer here. Sometimes you need to do a little bit more. In this case, we're just getting back home world, right, at the end. But what if we actually wanted Luke with his home world attached to him, okay? Right now we sort of have this function. We've got get person, person's home. And it takes an id, let's say, which is kind of funny. So then we could say, cos get person's home is equal to, fetch this thing, and then we'll turn this into an interpolated string, and then that will make it to where we can do braces here, id, and then I'll go back here and I'll make this an actual function that takes id, of course. Formatting. Okay. So now we have kind of the same thing, you know, make sure it runs. So yes, we have get person's home, and that's great. And that's how you can kind of make this general use functionality of this. But what if you just wanted get person, you know, with home? You probably wouldn't say with home, but you want to get more data for them. Well, in this case, you're kind of in a tricky situation because when you go and you fetch this home world and you get that JSON back, at this point you don't have access to person. It's in this function's scope here. So what do you do? Well, you could do something like this, where you say const person equals, let's say, you know, by default, it'll just be an empty object. Okay. And then on this step right here, we would actually have to put a brace back here and say person is equal, oh, well, we've got a scope, let's say person data to make it not confusing. Person data is equal to person at this point. And then we're going to do that fetch still, but now we have to manually return it, retrun it, classic. And then that will be here, we'll have a brace. So we'll assign person there. And then finally, when we get the home world, what we'll do is we'll say person data dot home world. So we'll replace what we had before, which was just the URL, we'll set that equal to home world. And then when we JSON string ify, we'll just do person. You think that'll work? Oh, it's not get persons home anymore. You silly goose. Get person, person, make it make sense. Oh, and I can't assign that, of course, I was thinking, you know, I have an object and I was going to mutate it. But let's just do this. Why is person not defined? Oh, the person data here. We are making a lot of mistakes. I'm sorry. There we go. Goodness. Okay. So now, this does work. We have Luke, we got his home world, we dumped all of that data, you know, we haven't gone and gotten all these things, but you can see it then moves on to all the various other data. So this is a way that you would kind of accomplish this. It's kind of, it's all right. I don't really like the whole mutating outside of this. I like the way that we had it before. But if you really do, you know, need that previous data, you're in a kind of tricky situation. There are little what I would call them little hacks, little tricks around like returning a promise that you could like make as an array of the fetch and then the person and do some different fancy stuff with that. But it's a little bit confusing to do it that way. If you need to do something like that, I would do it this way. But this does bring us into a pretty good use case, for example, for when a sink await can be pretty nice. So with what we have right now, what we could actually do is make get person an async function. So we could just say, a sink here, you're not familiar with this, just hold on. So that I'm just going to put some braces around that function here. Now, with a sink, what you can do is you can make a variable, let's say person, call it that. And we're going to await something. And you can only use this await keyword if you have a sink here. And then what will await is actually this fetch right here to come back. And we can still chain this onto it if we want. But it's a little bit kind of confusing. So let's do it like that. And then from here, we can console log what is person. Now, normally, we wouldn't be able to do this outside of then, right. But what this allows us to do is run our code sort of synchronously, to where it will do this thing. And then it'll stop here before it can do this next thing. This function itself is asynchronous, but within it, you can run everything line by line. And sometimes it's a little bit easier to reason about. Okay. So we'll do that. And for now, let's comment this part out. And let's say that that's all we do is we just call that and we won't need this either. Okay. Now, goodness. Here, you can see that we did indeed get Luke back at this point. Okay. Bring this back over here for just a moment. So we got our Luke data back. And you can see that that works pretty well. Console log normally, you know, if we were to put it outside of it wouldn't have been able to access that data, but in this case it can. And so that allows us to keep moving on with the next step in a normal synchronous manner. So now we'll say, okay, well, you know, go get me the home world. We'll say await. And that's where we'll comment this back in for just a moment. And we'll say, okay, we have this then person, blah, blah, blah, blah. We just want to do this part, right? Fetch the home world. Home world, await, fetch. Get rid of this. We will need this. You could also do each of these one by one if you wanted to, but I think that kind of creates too much noise. And then finally, on this last step, we'll have a home world. So we don't need to do this then home world. We can actually just delete this block here. We would do something like this. And so we would just say, okay, well, person, oops, we don't need person data anymore. Sorry. And we'll make that home world is just equal to the result home world here. We'll do this. And there you go. We don't need this variable anymore.", "title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}, {"text": "Okay. So let's reload and run this. And you can see that it still works now. So we've got our Luke and we have our home world and we've built this whole person object with Luke and the home world on it. So this is kind of the value of a sink away. And some people would say that you just pretty much always should use a sink away because it's just a little bit easier to read. And there's no reason about that code. I think that that's a valuable argument. I could see that, you know, just kind of using one way all the time, depending on your environment, it's possible that you might not be able to, but it's, you know, most environments nowadays do have a sink away. And so you'll be fine with that. Sometimes if it's a really simple promise, I don't mind just writing a normal promise. Personally, it just kind of depends on the code base. But there you have it, you might find this a lot more easy. Oops, sorry, to, you know, read and reason about you go and you get the person actually should be probably called print person, right? Since we printed here, but you go get this person, you have to say sink operation, you go and fetch the person and you store it in person, you go and fetch the home world and you store it in home world. And then you just change this little property on it. Do a little mutation dance. And then you go ahead and do your side effect or whatever you're doing. Now, what happens if we wanted to keep this as a get person, but and not a print person, and we want to make a separate function, as I think you should to print person. So let's say const print person. And then in this case, for now, let's just say, Oh, well, this is just a function that maybe it takes a person. Right? We run this block right here. Well, that means that we would have to return from this person. So get person, this case, print person, that's a lot of same person. What we could do here is we could say let's call print person with the value, get person. If you don't like that, you could store it in a variable first, of course. And see how that works. Let's run that. Hmm. Object. Interesting, right? Okay, well, what happened? What if we console log person here and see what we get? We got a promise with the state of pending. If you don't believe me, I'll put person. Just to make it more clear. Look at that. And then I got fulfilled once I opened it. Isn't that funny? Watch this. This is an interesting thing that Chrome does. So when this is printed, the status is pending. But when you like, look into it's kind of like a Schrodinger's cat thing. And you look into the object, it will actually update with what the values are. This can be really confusing. Sometimes if you're looking at objects that do mutation or change them afterward, think that your thing did right or didn't, right? You get the idea. It's pretty confusing. But you can see that we still just have this promise object and we can't write that promise object. We don't have the data. So what do we do here? Because, you know, I thought that we just asynchronously got everything and returned person. This is kind of a gotcha here. Because, you know, when you wrote this async thing, like I said, this function is asynchronous. It didn't just turn JavaScript everywhere into synchronously writing. And actually, that would be really confusing if it did. It has made this, you can think of it just as returning this promise. Anything that's going to be returned from here is still going to be a promise because it needs to be treated asynchronously. Okay? So what we would just need to do is we would need to do something like person.then data, let's say. And then we'll put this block here. We're doing a dance. We don't need this line anymore, right? And then we'd have to change this to data because that's what we changed it to get back. Let's run that. Oh, it works. Cool. So even though we're using this, you know, async await thing, and a lot of times with async await, you won't even see these then statements in here. You know, it looks something like this. And people get pretty confused, understandably, that, you know, you could write everything in a sort of non-promisey way without thens and such. But what they might not realize is that, you know, in the end, you've still got to handle it with this then statement, however you're doing it. Now you might be thinking, well, can't we just async await here? Yep. Sure you could. You could say const data equals await person and get rid of this line here, get rid of this line here. Reload, rerun, and that works, right? You got this promise back. You don't need to then at this point because you just got this promise back and you're just awaiting it. I think that shows off kind of the async await syntax fairly well, I hope. So if you wanted to, you could go async await all the way. But I wanted to show you that it is just kind of obscuring it. And a lot of people jump right to async await because they're not used to doing a lot of heavy callback or promise things without really understanding the inner workings. And it can get pretty confusing, you know, like you could be totally coding in a vacuum of async await and just be writing, you know, this block right here. And maybe the package or whatever you're using is doing this type of stuff for you. Or I should go back to the like the promise.then type stuff for you. And you don't really know that you need to do that or that you can't access this out here in the root. You know, you can't go and store that variable here. You know, you can't do something like this. Let person at the root, you know, let's say we start with this object. And then here, I said person data last time, let's make that less confusing. Person data, blah, blah, blah, blah. And let's say that, you know, print person, you want it to be a bad person and use a bunch of crazy side effects stuff. Well, you could say that print person doesn't take anything. And maybe it reads. It just does this simple thing, person data. We don't need to return here. Instead, we'll just say person data equals person at this point. Right. So we've gone and we've done all our mutations in person. And then we're just going to say this is person data. Now, we obviously could have just reassigned this, but whatever. Let's rerun that. You're still going to get that object. This is what I'm getting at. Like you can't do that. You need to handle that promise that thenable in some way. And that's what a sink await is doing for you. Hopefully that kind of clears that up. I know it can be a bit confusing if you're not used to it, but I just wanted to show that that let's go back all the way here. You need to do something to this effect. I think that'll be good enough. Get that running again. Beautiful. Now, at this point, we have covered quite a bit. And I would love to show promise.all or all these other different various methods that are really cool. If you look at these methods, there's a bunch of neat ones that are kind of fun to dive into and understand that. For example, in this for a real quick example, this residence, you know, we would have to go get a bunch of different things. It's not just one fetch. And so how would we wait for all of them to complete or maybe the first one to complete or something like that? That's what those kind of methods are for. And you can return that all as a promise that comes back as an array. But that would definitely add on to the length of this video considerably. And so I'm going to call it here. And if people have requests for going over those methods, then I'll consider doing a video of that in the future. This video was a pretty tough one for me to put together, just trying to decide on what the right way to display promises and kind of think about them and how much depth I should go into async and all that stuff. So I apologize if I didn't really do as good of a succinct example. But as usual, I hope that this was a little bit informative for you and helped level you up a bit to getting a better grasp or concept. Or maybe you're just brand new to promises, kind of getting your head around the idea of them and how you would commonly use them for some basic scenarios. But if I did not do a very good job, go ahead and let me know in the comments and I will do my best to improve from that feedback. Thank you, and I hope to see you next time.", "title": "Understanding Promises and Async Await in JavaScript", "url": "https://www.youtube.com/watch?v=2Ur9X4tUI9Y"}]