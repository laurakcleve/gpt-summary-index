[{"text": "Hello and welcome. Today I'm going to be covering using stories from Storybook in your tests. I'm going to be using React, Jest, and Testing Library for these examples, so you'll want to be familiar with those. If you're not, I'll put some links in the description for some documentation and general videos that you can use to get spun up with any of those, and I'll have some of that content on my channel pretty soon as well. But if you've already have those covered, let's dive right in. We're going to start this off with a project that I've already created ahead of time to save some time, and it's just a create React app simple project that we've used Storybook init to set it up with the default Storybook setup. I've made some slight modifications, which you'll see, but let's start it up so you can see what the Storybook actually looks like. Okay, so you can see the default Storybook button story that you might be familiar with, and it has its various different states. I haven't modified that at all. We also have a carousel component here. This is the demo that's a code sandbox that David Courchide showed, and it's really cool. It has, it's using CSS grid to lay things on top of each other and then using the hidden attribute with CSS targeting that to display it. So it's a pretty neat little demo, and I'll link it in the description if you want to check it out. And we've got this here to do a little bit more involved testing after we go through the basic testing setup of the button. So now that you know what we'll be writing some tests for, let's head back over to the code. And just so that you know, we are on Storybook 6.1.21, and I'm actually gonna start up my tests, kick over here, and do yarn test. Now the default React, create React app has testing built in, which is pretty cool. It starts with this test, and the test command runs a script that does it in WatchBoat, just so you know. So we have this app.test.js here that just comes with React Storybook. And popping over here to our code, you can see that I have this folder with these components and a button and a carousel. So I've just, I haven't modified any of the original button story, except for I've moved them into the folder structure that I like. So if you come over here to index.jsx, it's the same one that you've always seen before in Storybook, just the default. If you never checked that out, you can just run up a new init and you'll see it. And then here we have all of the starting stories. So you can see we have the primary, the secondary, the large, and the small. Okay, so let's start here. So I'm gonna make a test, and I'm gonna name it button.test.jsx. And you can use JS or JSX if you like. I'm a fan of JSX personally as the extension for just identifying them a little bit easier, but it doesn't really matter. Some people have a strong preference for it. And the same thing with the folder structure here. You know, this isn't the ultimate folder structure. It's just one that I like that works at a pretty good scale for me. But of course, do whatever you like. And also just a quick note, you might notice that my icons have a test icon and a storybook icon. I really recommend picking a icon library for your editor that does that. Mine is the Viking icon library, but I switched it around a bit. But I really like to have the storybook and the test icon and the react icon just to easily identify those when I'm looking through my folder. Alright, so let's start with the first test here. So what I'm going to do is I'm going to start this out by importing button, and that's actually a destruct. And I'm just going to import that from the directory that we're currently in. So I'm using dot. And then we know if we're using a testing library react, which is the default with create react app. I highly recommend you use that for testing personally. We want render and screen from that. It's going to be pretty common. And that is from at testing library react. And then we'll set up our first test. So I'll make a test here. And what I will name this is just something simple like should render. And then from here, we can render and we'll use that button. And in this case, the button actually doesn't take children like normal prop, it takes a label for the text. So we're going to pass in a label here. And I'll say like, click me. Cool. So I want to immediately know if that even causes an error. So I'm going to flip over to my tests. And I can see now that I have a new test that's passing. Cool. So it renders fine. And actually just show you that. Let's say that we deleted this, and we just saved it like that, we would immediately get an error here, but it's just a console dot error. It's not an actual test failure error, just so that you know. All right, so let's go back to that. Now, we're going to write our first expect here. And we'll say we want to use screen. And we'll say we want to use screen. And I'm going to do get by role, explain this in just a moment. And I'm going to do button, good old get by role button. And then we're going to say to have text content, and finish that. And let's first do it just click to see what happens there. And then I'll go over this. So we're going to get a failure here. But you can see that it gives us this nice message expected element to have text content click, but instead got click me. So you can see it's taking click literally. And I just want to show that because what you can do, if you aren't familiar, is you can put this in a regular expression and use case insensitivity. And that will get you what you want, basically. You could also make it click me if you want to be a little more specific, and that's fine too. Okay, so a couple things to really briefly unpack here. The screen, if you're not familiar with it, it is the new recommended way in testing library to basically do all of the get bys and query bys and all that type of stuff. You might be familiar with destructing off of the render, pulling off that get by, and it's recommended that you don't do that anymore. And you use screen and just pull it here. So and that's really nice, because then you don't have to constantly update this variable over and over and over for every single test. When you have like 10 different tests pulling that off, you just get it all from screen. So I kind of like that. Okay, so now we have a button test working, we just have an initial test, we can tab over here and see that that's good. Now what would be interesting, don't you think, is if we could use our stories as the test. Perhaps that's why you're here. It's a really interesting idea to me, because something that can happen at a larger scale product is that when you're working on a project and it gets bigger and you get more and more tests and more and more functionalities added, it's actually easy for your stories and your tests to fragment a little bit. And your stories won't show everything that your tests are testing and vice versa. And this can be a little bit confusing for your users sometimes, and it's just easy to happen. There's some other reasons that I like it that I'll actually show you by actually showing an example when we get to the carousel. But for now, that's kind of the gist of why I think it's an interesting idea, is just to kind of keep those synced up. So let's try it out. If we pop over to story here, you can see that we have a primary story with the component story format. And so I will just say, all right, well, let's pull in that primary from button.stories. And that's obviously going to fail our tests. I'm not even going to bother to look at that just yet. And then we'll replace this with primary, which this might be a little bit weird to you at first, because, you know, it's not actually the syntax for a button. But it's not actually that bad when you get used to it. And you'll see in a moment, because when you have multiple tests, you know exactly which one it is. Now this part, what I'm doing is I'm going to, it's kind of like passing on props, dot dot dot props. But in this instance, what we're doing is we're taking that primary, you know, function that we have here. And what we're going to do with this component, and we're going to get the args property from it, which you can also see down here and spread those out. And why it's args, if you don't know, is that Storybook is supporting more than just React, they're supporting Vue and all these other things, they're quite ambitious, or even vanilla JavaScript. And so args is just kind of a generic term there. So if you're used to it in React, this is kind of like dot dot dot props. So we're going to spread all those out, save that, see what we get. Now, we're almost there. But you can see that we had different text in our story. So you know, we've made it fail to show that. And so what we could do is pop over here. And let's say, we just want to look for button. Cool. And if you didn't catch that, that's right here, this label button. Sweet. So that was pretty easy, right? We now have a test that's reflecting our main component, or our first main story for this component. So in order to better showcase the usefulness of the next couple of tests, what I'm going to do is I'm going to pop back over to my terminal here, and shut this down, I'm going to run yarn test dash dash coverage to get a coverage report. Now you see that at first glance, it looks like we have 100% coverage, but that's actually not true. Because it's looking at button dot stories dot j s x, because by default, just is only really going to run tests that are being imported. So components are files that are being imported into tests, I should say. And so we need to do a tiny bit of extra configuration in our Create React app to fix that. So I'm going to go over to package JSON, we will add a jest property, you could also do this with a jest config. And what I'll do here is I'm going to do collect coverage from, so I can override that, this is going to be an array. And in this array, we're going to put root dir, and we'll do slash source slash components, slash star star slash star, and then dot j s comma j s x. So the reason that I'm doing this here is because we want to, for my purposes, I only want to test things in the components directory from this point forward. And of course, you could add extra customization if you want to be doing that for different folders or make it a little more complicated.", "title": "Using Storybook stories with Testing Library", "url": "https://www.youtube.com/watch?v=k6NG96awIJ0"}, {"text": "And a final note, I actually don't know if this root dir is necessary here. This is really common in the docs, but I've seen people do it without it, just starting it like source. So if anyone knows if that's actually required or if it's a different operating system thing, you know, feel free to drop a comment. So here, what I need to do next is I need to say no node modules. We don't want to be testing node modules in case we happen to have any that do. Right now, I don't believe I do. And that's because we're overriding the default settings that create react app comes with that it's ignoring. And so we're going to have to add that back in, I believe. So then, lastly, we don't want to run it on any of our stories. So we'll do js, jsx. And that should be it. Now we're almost there. Pop over here, run test coverage again. And you'll see now we're not testing anything at all. That's kind of interesting, right? So we're definitely not testing the story, which is good, but it's not pulling in all of our files. So we can come back here. And we'll make a new test script. And this is because watch mode behaves a little bit funky. With coverage, I've actually had a lot of problems with coverage and watch mode in general. So I always just run it without watch mode normally. And that resolves it for me. And then plus, what this will do is this will set it up to where if we ever use continuous integration, we're not going to want watch mode in that anyway. So we can use this script for that. So I'm going to say test dash dash watch all equals false, and then dash dash coverage. So that'll be our script now. And then now we can just run yarn test colon coverage. Of course, you can name that whatever you like. And there you go. You can see that our button and our carousel are now being tested against. And I like this because now it really is blatant about like, you don't have tests for these things. It doesn't just show me the things that I've already started a test for. So the thing that we want to point out here now that we've done all that is that we only have 50% branch coverage for our button. So let's take a look at that. We can go into our coverage report, l curve report, this is generated out when you run a coverage. And you're going to want to be able to open this in the browser. So how I'm going to do that is, since I'm on Windows, I'm going to reveal it in Explorer, swap that over, and then just double click this and open it up. And then here, we can click through this nice little UI. So we go to index js, you'll see for this button that this yellow is saying that we have not covered it. So when we look for the mode, and when we look for mode, and we're going to set that to here as a class name, we're basing that off of primary that's coming in. And one of the cases is we aren't passing primary for any of our tests right now. And the other one is that the style tag is adding a background color prop if it happens to have one, it runs writes that as a rule. And we're not testing for that either. So one of these we actually have a story for and one of them we don't yet. So let's rectify that. And actually coming back over here and close that, come back to our button, just to show that you know, this is the primary. And this is the story that doesn't pass in primary that we're going to test first. So let's close this, we're not going to need this or this anymore. But what we can do is really simply just kind of clone this test here, and then come up here and this is going to be as simple as just pulling in the secondary story. And then we'll replace this. Of course, I could replace them all at the same time. I'm being a noob. And then here, we probably have the same text, so we should be fine. Let's go back over to terminal. And we'll start up our tests again. And that seems to pass. So then, just to make sure, I'm going to, you know, change this and see if the second one Oh, actually, we have them on the same name. So let's change that to should render secondary button. And we'll make this should render primary button. Whoopsie daisy. Okay, and there you go. So on our secondary test, it can't find button because I typoed it. So here, make that pass again. And we're good. And it was that easy. Just pulling in that story. That's pretty sweet. So next, let's actually make a story for this new prop variant that we're going to test. Now I have a quick disclaimer here. So when you are writing these tests and writing these stories, I personally don't think it's reasonable to try to cover every single prop combination scenario that you're going to have in your stories or in your tests. Really, the point of tests in general is to raise confidence in your project, and not to create a bunch of noise to where you ignore things. And that will happen really quickly if you try to test everything, and it'll waste a lot of your time. So that's from my personal experience. I think that you should though, have a story and a test for every either explicit state or primary functionality that a component has. And so in this case, maybe primary or just the color in general, we can click this little cool little control in storybook and move it around. And that's good enough for us. Maybe that's fine. But if it is a primary functionality of our button, and people are going to commonly use it, then you kind of have to make a judgment on whether you think you should have a story representing that and that you want to, you know, make sure that you catch that if any bugs are introduced. So we're going to assume for this purpose that background color is really important to us. So let's make a quick copy of this story. And we'll make it called custom color. And I'm not going to put size small, I'm going to change this to just say custom color just for testing purposes. And then I'm going to pass background color. Thank you for helping me there. And I'm going to make it coral. Coral. And let's see if that comes in. Yeah, we've got that already. Very nice. So now let's write a test for it. So going back to our test. Now we of course we can pull in this custom color. And then jump down here, we can use the same test idea for now. And then should render, let's do a custom color. And then of course we can change this to be a custom color. And we'll do the same thing here just so we can see the test failing if it tries to pass button. I'm a big fan of the fail then pass methodology. Red, green, refactor and all that. Okay, yeah. So it's looking for a button and it received custom color. Perfect. It looks like we're getting the right information. So now we can just write custom or we could write custom color if we think that that's what we want to test for. And we're passing. So now let's make this test a little bit more useful here. So I think in this situation what we might want to do is expect and then we'll just use screen.getByRoll again. Oops, getByRoll, sorry. And we'll do button. But what we're going to do here is we're going to do is to have style. So this allows you to pass in one or multiple CSS properties or declarations here. So I will do background color. And let's make it fail real quick by passing it red. Must be an HTML element or an SVG element. That doesn't look right. So I must have done something wrong here. Oh, getAllByRoll. Aha. There we go. Perfect. So it expected red but it got coral. That's what we want. So there's a couple ways we could accomplish this now. We could say let's do coral here. Okay. I'm going to scroll down just so my head's not in the way. So we could just pass in coral and that's going to pass for us. And I don't know if that way is better or this way is better. This one feels a little bit better to me personally. But what we could do is actually change this to be, oops, to be a interpolated string. And then we'll take off of custom color, the dot background color property and test against that. And oops, I need to put args in there so we can actually see it failing there. That's good. Always nice to make sure that it does. Whoopsie daisy. And there we go. Now let's see if we satisfied our coverage report. So let's close that out and we are in test coverage. And then we can see that we are at 100% now, which is pretty cool for that button. And we will go back to our browser and look at that. And now if I reload, boom, we have covered 100% of this component just like that. A quick note about this to have style rule here. This is a bit of a contrived example here. And in most situations you probably aren't going to have your styles being written out directly to your HTML. And so this wouldn't really work for you necessarily without some sort of snapshot serializer. And that's how I'd use it, especially in a lot of situations I'm using CSS and JS. And so that'd be the time where if I were to...", "title": "Using Storybook stories with Testing Library", "url": "https://www.youtube.com/watch?v=k6NG96awIJ0"}, {"text": "were testing any styles, that's how I'd do it. Just a quick note there. So, so far, I think we can start to see that there's a little bit of potential here with using these story tests, right? We got this nice little feedback loop to where we know that our tests are testing the things that our visual documentation is showing. And this will even give you a little bit more confidence when, let's say, you are using your storybook not just for yourself, but also perhaps you have developers that are consuming your components or your library or whatever, your design system. And sometimes maybe designers will be looking at it or stakeholders or whatever. And now you are testing, you know, those same things back and forth. And we saw how with the coverage report, it kind of alerted us to a potential weakness that we might have in our stories or that we're representing and vice versa for our tests. And that's pretty cool. Now let's move on to a little bit more of a featureful component and some more fun tests. So I'm going to start testing the carousel at this point. I'll make a new file here, carousel.test.jsx. And then we can import, and in this case, I'll go look it up for us. It's going to be from./.carousel-stories. So let's open that up, stories. And you can see that we just have this one story template that's called default, and it passes in this array for the prop slides of swashbuckling with code. So let's go back and pull that in here and see if it would help us here. Yeah, it does. That's really cool. And then we can assume that we're also going to need render and screen from, oops, at testing library react. We'll write our first test. I'm going to use my little snippet. And this one will be just should render. We'll do a simple one first. And I'll call render and call our carousel. You're familiar with this at this point. And, oh, in this case, it's actually default though, right? So then we'll do... default.args. And that really should be it. So we'll save that. Do we have our test running? I don't believe so. Nope, not yet. Okay, now we have button and we have a carousel. Let's go back here. And then I'm going to test. Let's just do a snapshot test. Actually don't know if there is a new better way to do container here. So if you happen to know, let me know. So we'll do expect container and I'm going to do our first child because I want to get rid of that first div for my snapshot and we'll do to match snapshot. And we will see that a snapshot was indeed written. So you can't really write a snapshot without talking about it really briefly that it's a bit of a hot topic. Some people have some great arguments against it. They have great arguments for it. Now for my purposes, I find it to still be a useful tool, though I do see a lot of merit in the negative arguments, especially when they are about it creating a lot of noise. So I'm just putting it here to show that you can do it and I'm going to show a little quick thing about kind of what makes it nice in some way. But I particularly find snapshots useful still for snapshot serializers for CSS and JS. I kind of mentioned a little bit before. I think it's really nice when you have a bunch of components that are using other components, you know, you have this atomic structure and a change in one might give you some changes in others that you didn't really expect. And sometimes the serialized snapshots can catch that. Of course, if you can test that in a better way, great, but you know, do whichever you like, of course. So what I like about this is if we go to the carousel and we let's say we just make a little class name blooper here. Our snapshot is going to tell us right away that that's changed. And did we mean to do that? Okay, so that's pretty normal. It's pretty expected, but it's also going to do it in here. So let's say someone messed up the data here, just a little minor blip, and then it's going to cause the same effect here where the actual thing that's rendered out doesn't match. And this has now told us that our story is a little bit different as well, which is like we talked about that nice little feedback loop of our tests kind of catching errors that are in our stories now as well. Now, this is just a minor example. Of course, it would catch much more meaningful bugs in a lot of situations, but just to show that. So let's test some functionality, shall we? I'll write another test here, and this one I'll do should switch slides when clicked. And we're going to start off by doing our normal render here with default. And in this case, it's going to be the same thing. We don't even need a new story at all. What we're actually trying to mimic here. What am I missing? Ah, yes. What we're trying to mimic here is if we go over to our storybook. This is kind of a neat idea here because before we were testing just kind of static states in the stories, and that was great. But now we have tested the static state of this carousel, how it's first rendered, but we know that we can also click it. And in the storybook, that just simply happens. And now we can write some tests to simulate a person interacting with our component and, of course, interacting with our story here. The beauty of this is that we don't even really need to look at the code. We generally know how it functions. And what we can do is we can, let's see, first we're going to grab, let's do carousel container. Screen. And then I'm going to do get by test ID in this situation. Carousel container. Now test by, get by test ID is very useful. It's usually last resort. In this case, I don't actually know what the right role or semantics for a carousel tag are. I tried to look it up. But, you know, you shouldn't let the test be the proper testing methodology or where it's be a barrier to you writing tests. You know, you want to make sure that you actually can write the test and just use whatever works for now. And then come back to it once you find out a more proper way to do that. But if anyone knows that, please let me know in the comments if you have an idea of what the right role or how the right way to grab a carousel or a slider is. So moving on, we're going to do, first we're going to say grab all slides as they are always in the DOM. So in this case, the first slide, because of the way this is using grid with the hidden attribute, it's actually not rendering only one at a time. It's rendering them all and then just hiding them, which is kind of neat. So we'll do screen.getByText. And we're going to look for case insensitive swashbuckling. So that'll be our first test here. And it's still passing, which is great. And this screen.getByText, if you don't know, is actually a test in itself. Usually you want to be a little more explicit, like using an expect around it like we did before. But this alone will fail, you know, if we can't get it. So it is a test. You can see that. Unable to find element with the text. But we're going to use that in just a moment. So let's move on. So I'm just going to copy this a couple times. We're going to check for the second slide being in the DOM. We're going to check for the third slide being in the DOM. And then here, this is just width and this is just code. So we're just checking that each of those exist. Yes, they do. Awesome. Now we're going to start using them. So we'll say the first slide is visible by default. And we'll do expect and we'll just check that the first slide to be visible. This is actually one of the most common things that you're going to use for something being there or not. If you hover over it, you'll see that it covers all of these different scenarios. Display none, opacity zero, hidden collapse. It's even nice for the details. HTML attribute, if you ever use that, it's kind of like an accordion. But it doesn't actually remove the things from the HTML, so they're still there. And so in this case, what visible will check for all of that, which is really, really cool. Also, fantastic documentation on this. It's really awesome that they give you this from a nice little hover. So that will be visible. Now check this out. First, let's say, well, actually, let's say, what if we were to put not to be visible just to see. Is that test passing or failing? Yep, it's working correctly. Beautiful. So now, what if we do second slide to be visible? Okay. Okay, so in this instance, our second slide is not visible, which we haven't clicked at all or anything like that. So that's what we expect. We'll do the same thing with the third slide, but then we'll make this dot not to be visible and check. Okay, well, what about the third slide? You can see here it says expect third slide is the one that it's hitting, and it says element is not visible. So we'll put the dot not here. Perfect. Are they passing? Yes, they are. Glorious. So now that we have the kind of starter test.\n\nState here, let's do an action. So in order to do an action here, we're going to want to pull in something new. We're going to user event, and then we'll do from, and that'll be at testing library user event. Now, I actually wasn't familiar with that until really recently. So this is the new best practice way that the testing library documentation recommends using if you're used to fire event, this is replacing that. And it's really nice, actually, I've used it, I've swapped out a bunch of tests on my work project. And I really like the way they do the dot type event, it makes it to where you can type a series of keys as sort of a string, and then you can insert a backspace or an enter or anything, kind of all in one command. And it just feels a little bit more natural, like actual user input. So this isn't going to be too much different, though. If you're used to fire event, it's going to be the same here, we're just going to do user event dot click. And then we'll click the character cell container that we grabbed. So when we click that, we expect the slides to change. And so what we should do at this point is essentially grab all of these and paste them down here again. And we should probably write a nice little comment here to say after clicking once, only the second slide is visible. That makes sense. And of course, let's make sure we save this should fail. It does fail. Glorious. Oh, what I do. And then we'll just swap this to be okay, so the first one's now hidden. Come over here. And whoops, that one should be visible. Awesome. So that's a pretty good complete test just to test that the click itself is working. I think. Let's dive over here and see how our coverage is looking. yarn test, colon, coverage. And it looks like we've covered all of the generic usability for our button. And for our carousel. This brings me to another point here that I really like about this paradigm of using our stories for our tests. So you might not be familiar with this if you haven't gotten into this position before. But you'll notice that my story has this data that's being passed in right now it's really simple. You know, it could be as complex as you like. We have a whole bunch of JSON from an API or something like that. What I end up having to do a lot with my tests is I have to write dummy data for them. That's what I call it. And so I'm basically, you know, mocking some sort of simulated data from the API, because I don't want to test actually hitting the API every single time in my unit tests. And that caused me a problem of getting pretty out of sync with my stories at points where I'd essentially be, you know, copy pasting a bunch of information back and forth until, you know, I, in hindsight, it was really obvious, but decided to move that into a file that they could both share. Now, because of my convenient folder structure, where I have everything all in one component folder, I could just put it right here in a little dummy data thing. And I could, by default, add a rule to ignore all dummy data in my tests and stuff like that. It'd be a little bit more cumbersome to import that if my folder structure was all over the place. But really, this problem is kind of crazy at scale. Because, you know, if you don't find a solution for it, you're, it's very easy to get out of date, as you add new features to your components, you know, your storybook won't immediately be representing that possibly, or your test won't or etc. And so I really like this about this is, I could still make that abstracted file if I like, or I could put it here. But either way, I'm just going to import it into the story here. And then because my tests are derived from that story, they're always in sync with whatever data it's using. And I think that's really fantastic. Now, if I were to continue testing at this point, what I would probably write next for functionality is make sure that my carousel properly loops back around to the beginning, when we click it multiple times. So in this case, we click it a few times and check that just the first slide was shown. But I'm not going to bore you with that. I think that you could see how that could play out. But I hope that this example here has shown that, you know, we can take a story and elaborate on that and build some more functionality based testing around that. And kind of extending the nature of that either way. So this really lends itself to work very well, this paradigm of using your stories and deriving those tests from those stories. So I'm rather fond of it at this point. And I hope this video was useful for you to kind of showcase that paradigm. You got to give props to the storybook team. It's really awesome, all the stuff they're constantly pumping out and keeping up to date in this really fast moving ecosystem. So if you're a fan of storybook, like I am, obviously, and testing in general, especially with Jest, feel free to head over to my channel. I'm going to have some more videos on storybook and Jest coming out pretty soon. And I hope to see you over there. And once again, I hope this was useful for you. And if you have any feedback, go ahead and leave it in the comments. Take care.", "title": "Using Storybook stories with Testing Library", "url": "https://www.youtube.com/watch?v=k6NG96awIJ0"}]