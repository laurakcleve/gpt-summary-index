PROMPT:

The following is a transcription of a video for web developers called 'Using git bisect to quickly find the origin of a bug'. Write a detailed summary of the video, providing an account of the steps taken and topics covered. Include any names that would be useful for a keyword search: names of tools, specific commands or messages, etc. Use the first person point of view, using 'I' instead of referring to the speaker as 'the host' or 'the speaker'.

---
TRANSCRIPTION:

We had a test, and it passed. So that's kind of cool. We can say, okay, this was a good commit. So 47, good, right? Git bisect, and then we'll say good. Okay. And now if we run npmt again, whoops, npmt, this one failed. So if we were just to run it manually, we would see it's 137. So 137 is the number that we don't want in this situation. Now, at this point, it might seem a little bit silly to you if you're thinking about it, because you're like, well, you had tests. So how did this even get in? Well, in this example, I'm going to show you a little bit more legit one after this. But in this example, I'm just kind of trying to show you, you know, how the thing works and trying to reaffirm that whether it was a good or a bad commit, and to show how easy it could be to miss it. But this could happen in a real scenario, if you don't have continuous integration up, and you know, you aren't manually running your automatically running your tests, every time you do pull request or something like that, it could get in some way there. So this is if you did have tests, it'd be a pretty cool way to run it. But you can also eyeball it, right? So this was a bad commit. Okay, so we'll say git bisect bad. And then notice it says, all right, there's zero revisions left to test after this. So it's chopping it in half, it's saying, okay, you know, I looked, I looked at the first, you know, 10 commands, and then, you know, you said it was good there. And I looked at the previous 10 commits, and then you said it wasn't good there. So I'm going to go, you know, in those previous 10 commits and through those bad ones and see, okay, if I chop that in half, how much closer do we get? Hopefully, you're kind of following along there. But on this one, we will say, okay, node index dot j s. And we see it's 47. I'll just do this just to confirm it. But we know that's the good one. So we'll say git bisect good. And you can see that only in a few moves, it found the bug. That's pretty cool. So, you know, if you had a bunch of commits to go through, this can really speed that up. This is pretty awesome. It found this commit, you know, let's read the message here. This commit is the first bad commit. And it, you know, here's the message. So I know to reaffirm like, oh, yeah, that is the one. Pretty cool, right? And if we do get I think if you do get log, it will show you I think there's a bisect log, too. But you'll notice that all these refs have bisect. And so this is kind of neat. This is showing me all of my commits here. And it's saying these are the ones that it actually ran bisect on and what I said whether they were good or bad. So before you quit the bisect, you can do this as a reference and be like, okay, this one was good. This was bad. Yeah, that looks right. So now I can say, get bisect, reset. And we're done. You can go and you can find that commit. And you can fix the original broken commit. Okay. So now I'm going to show you something really cool. On top of that, it gets even cooler. Alright, so as I was reading this, I found this beautiful individual here, who he was commenting on the thread and mentioned this, you know, want to really cook with fire, you can write a bash script that will exit nonzero for bad commit and automate this process further with get bisect run that test. And then so if you're a node user, in this case, this is what stood out for me, get bisect run npm test. I was like, there's no, there's no way that that there's no way that that can work the way that I that I thought it would, or that I'm thinking it will. I was really in disbelief. I was like, that sounds so cool. I need to try it out right now. And that's where I started setting up this, this example for so we're on master right now. Let's do this. So I'm going to go to the bottom, grab that commit again, in case I lost it, get bisect start. So like say get bisect bad, the one we're on is bad. Get bisect. Good. That's this one. Okay, we've begun the bisect. Now I can say get bisect run npm t. Is that not the sickest? That is so sick. So yeah, it just ran through each one and just automatically determined whether it was bad or good based on a test failure state. So cool. So thank you. I'm going to link those tweets. So you can give them some love if you want. But this is really, really sweet. This is such an amazing technique. I've actually used it a few times since I learned about this in my real project. And it's worked out extremely well. Just in general, get bisecting really powerful technique when you can recognize it takes a little bit for you to notice, oh, is this a bisect, you know, situation. But some of my teammates as well have picked up on that and come up with some really cool times to use it that have saved us some time. So we're about done here. But I want to show you for all those who were kind of like, well, what you already have a test, like, what's the point of this? Okay. So I have made painstakingly a repo, that's a clone of the previous one that I have stripped out the the tests. Okay. So now, I'll open the code here to show you, I guess I could just, you know, list it out, right? There's no test here. Okay. And if I do ll, you can see that there isn't an invoice printer test. And to show you this, I'm going to go get log, I'll go to the bottom again. And we'll say get bisect start, get bisect, we're on the bad one right now. You know, actually, let me show you node index.js 137. Okay. So get bisect, bad, get bisect, good. Boom. And the bisect has started right now go get bisect run npm T. And they're all going to fail, because I just don't have a test. Okay, so that's not going to work. So check this out. This is this idea, I'll do reset that I've had. And I've gotten it to work once, but it's kind of hard to come up with a situation for it. But I had this crazy idea where I was like, well, what if you write a test at your current position on master where it's bad, that you know, what's what's causing it to fail, you can't always do this. But if you know what's causing it to fail, then you should be able to write a test that is supposed to pass, since you know, the correct output that you're looking for, but it doesn't. Okay. So we already have such a test. So in this, let's see, where's our other test? Let's see, where's our other one, we're gonna copy this test. Let's pretend that I just wrote this from scratch. And then I'm going to paste this right here. All right. So now, just to shortcut this, I already set up the just environment and everything. I just didn't have any tests. So now on master, what I'll do is I'll run npm T. And you can see that's failing. Okay. Now I'm not committing this. This is the important part. I'm not going to commit this, I'm going to leave it untracked. And you know, when you're using Git, and you check out different commits, it will like keep your floating ones as long as like they're not conflicting with something else, the staged commits or so what we'll do are the untracked files is we'll leave that there. And we're going to do the same thing now. So get log, go grab that commit. I don't know if there's a faster way to do that. I wish you could say just like go to the beginning of history, but I'm too dumb to know how to do that. Sorry. So get bisect start, you could probably make shortcuts to speed this up. If you do this a bunch, get bisect, we are on a bad one. Let's say this is the good one. Control shift B. And now we'll say get bisect run npm T will work. Look at that. It found it. So this is really cool. Like, you never had a test in the entire suite, but you went and you wrote one and it retroactively worked. Because as you check out each one, and you run the test, it can still verify, okay, does it match like the current expected output, you know, in this case, it's a snapshot that I already had that snapshot state. But if you, you know, just wrote and said, I expect this string to equal this, then it will test that over and over and over. snapshots are kind of a tricky situation for that they probably won't work as well. Because, you know, they're, they're outputting it versus the current state. So you might run into some conflicts. I can't really explain that. But I foresee some trouble happening there. So this is a really powerful technique. Overall, I think it's it's really cool. And I hope that you will find some use for it. And, you know, let me know in the comments if or on Twitter or anything like that, my information will be down in the description, if you run into a situation where it helps you out. So thank you for watching, and good luck with that.

(END OF TRANSCRIPTION)

---

SUMMARY 1:

In this video, I demonstrated how to use git bisect to quickly find the origin of a bug in a web development project. I started by showing an example with a test that passed, and then used git bisect to determine whether a commit was good or bad. I also demonstrated how to run git bisect with npm test, which can help automate the process even further.

The key steps in using git bisect are as follows:

1. Start by running 'git bisect start'.
2. Identify a commit where the bug is present and mark it as bad by running 'git bisect bad'.
3. Identify a commit where the bug is not present and mark it as good by running 'git bisect good'.
4. Git will now bisect the commits, checking out each one and allowing you to test whether the bug is present or not. Mark each commit as good or bad accordingly.
5. Once the first bad commit is found, git will display a message indicating the commit that introduced the bug.

You can also use 'git bisect run npm test' to automatically run tests for each commit and determine whether they are good or bad. This can be especially helpful in situations where you have a large number of commits to go through.

In addition, I showed an example of how to use git bisect even when there are no tests in the project. By writing a test that checks for the expected output at the current position on master, you can then run git bisect with npm test to find the commit that introduced the bug. This works by leaving the test untracked and allowing git to check out each commit while keeping the untracked test file in place.

Overall, git bisect is a powerful technique that can save web developers a lot of time when trying to find the origin of a bug in their projects.