[{"text": "Hello and welcome to Swashbuckling with code. I am Jimmy Cleveland, and in this episode, I'm going to be showing you bundle visualization tools, sometimes called bundle analyzers. And they are really awesome way to get a sort of visual graph of what your packages look like for your final, a bundle.js, main.js, whatever your JavaScript bundle that you're serving up to your client. So we'll start off using webpack visualizer, which is a nice little drop in web tool that just makes it really easy. As long as you have a webpack JSON output, which we'll have at the beginning of the setup. And then we're going to dive on into a webpack bundle analyzer, which is a little bit more of an industry standard tool, as far as I've seen in my experience. And I think it's really awesome. It's, it's my preferred way to do it, but we'll kind of compare both of them because I think it's nice to see them both. And what we'll do along the way is we will add a couple of different packages and we'll look and see how that grows our bundle and how importing them in different ways can drastically affect our bundle size and these visualizers make it a lot easier for us to have, you know, more visualization. And this is so that we can get a representation of the dependencies of our dependencies and all that stuff. And we get to watch and maintain our code and be a little bit better, a little bit more diligent about our bundle size growing, and then we can kind of surgically change things as they happen, rather than having this big surprise at the end of your project or in the middle of your project where your bundle has grown enormous and you don't know why and you have to track it down. So even if you are in that position, a bundle analyzers or visualizers are really useful for tracking that down. But I think at this point, just showing you we'll explain the rest. So let's get to some visualization. We're going to be starting out with a basic web pack and Babel setup. It's got Babel core preset ENV, Babel loader, web pack, web pack CLI, nothing fancy, just so that you know, let's take a look at the files that we're going to be visualizing first though. So in our source directory, we have our entry point, which is our index JS. And you don't need to be concerned with the code that's going on right here, right now. All we're really looking for is the fact that we are importing get classes, and then we call that, and then we run some code inside this file. And then in get classes, we have two destructured imports and it just console logs those as well. And if you take a look at those, they're just simply exporting a string. So this is just to get some import diversity for our bundle, which you'll get to see visualized, and that's kind of interesting. So jumping on over to our browser, you can see that we have, let's start out with web pack visualizer. We have this interesting website here that is probably the quickest to start out. And so what it tells us to do is to use web pack dash dash JSON and arrow that into stats dot JSON. Okay. So we'll make a script that does that since we're going to be using that for a while here. And we can just go into our package JSON and we'll say, let's just make it stats. And then here we'll say web pack dash dash JSON. And you actually don't have to use this arrow to send it into a file because the, this actually takes another secondary argument here. So we can just do build stats dot JSON and that'll work just fine. Okay. Go on over to back to our terminal. We'll do NPM run stats and you'll see stats are successfully stored as JSON to build stats. JSON. We go back to our code. You'll see that we now should have this build stats JSON file. Let's take a quick peek at that. Why don't we, we don't want to get too lost in the weeds here, but I think it's always good to just get a little bit of exposure and familiarity to things. So the things that we're kind of concerned with here is, um, this assets by chunk name, and you can see that we only have one chunk and the chunks are basically web packs, you know, kind of version of letting you know that it's split up your bundle into multiple files, but we only have this one bundle main JS. We're not loading extra chunks or anything like that. So that's our only one. Let me come down here. It'll say, okay, this is our asset. It tells us our size and some interesting information, and then keep coming down. There will be this chunks array of objects. And within that there's a modules. This is the part that I wanted to point out. That's kind of interesting. It goes into each module. It will tell you the name somewhere here. So barbarian JS. So it's looking like it's doing it alphabetically. This barbarian JS, it will say the issuer, which is kind of interesting because it even tells us that in node modules, Babel loader is the one that handled it, and then finally it tells us the file at the very end that was handled with it, or we could just look at the issuer name, get classes. So this is saying that get classes is the one in this case that, you know, went and got the barbarian and used it. So yeah, barbarian wizard. Why did I do that? Just for fun. There's nothing special or anything going on there. So that's it. Just a quick little dive into what this JSON file is, and you can imagine that you could do lots of cool scripting stuff with that, but what we're going to do is right click, I'm going to do reveal in Explorer for me. I'll bring that back down here to you since it went to another window. Let's resize that because we're going to have that around for a little bit here. And the reason why I'm doing this is because if I open my browser and then I want to just be able to drag this build stack, I can just drag it to drag this build stats dot JSON onto here. And it's that easy. Pretty cool, huh? So right off the bat, we're getting a 6.5 K actual and a 2.8 K raw. All right. And let's see if that lines up with our numbers, since we are pretty concerned with the build size here. Now, I believe that this is going to by default run this at dev since the way that I have it set up. So we should see that we're probably okay, 1.09 KB and then NPM run build dash dev for our main output. So I'm just looking at this main JS 1.09 KB and then here it's 6.52. So let's go back to the browser here and you can see it's 6.5. So this is our development bundle and you'd probably normally want to compare it to your production bundle. It kind of depends, but there, there are some hiccups that can happen where it won't quite separate all the files the way that you need, so I'm just going to leave it for dev for now and we'll use it to reference those numbers. But obviously you could do it in build if you're looking for a real actual, what the client's going to download. Okay. So visualizing this, we start here with this main JS 6.5 K actual. I know that's kind of tiny, but I can't really zoom too much here or else we'll we'll lose all the information that I need. Sorry. But then it says this ring around it is a hundred percent. So it's saying of this main JS file that we output a hundred percent of it was from this source and it's blue as a directory here. And then here, the index JS that goes around that is saying 87.2% of all of that source was a index JS. And that's, so that's where the bulk of our code is happening here. And then each one of these is going to be our wizard, our barbarian, tiny percent, and then get classes a little bit bigger. And that makes sense, right? We had a bunch of code and index or get classes just brought these two in. So let's build upon that by installing a package UUID, which is a nice little package that I use a lot, and it's got a really good setup. I'm going to see the benefits of that a little bit later. But the main thing here is we just want to install it and then we'll use V4, which is just like a random way to create a unique identifier. And it's pretty cool. And then we'll see what that looks like in our bundle. So back over to our terminal here. I'm going to NPM install and then we'll do UUID. And then we'll go back over to our code here. And in our code, I'm just going to use this in the wizard one, just to kind of bulk this file up and see what happens there. So we'll import and let's start with, let's actually start with UUID just straight from it, even though this isn't the way I would normally do it. And you're going to see why. So UUID here. Let's say what I want to do is append to Ravelin. So we'll just like concatenate to this and then we'll do UUID.v4. And you're going to call that. That's a function. Okay. Now we'll go back over to our code. We will run stats. So when we run our stats, we're going to be dropping this file in here again. And this is kind of annoying at first. This is just like the easy, quick way to do it. Oh yeah. Refresh this browser, sorry. You have to refresh to get it to reset there, but we will do it in an automated script way in just a little bit. Cool. Okay. Wow. That bulked up quite a bit, right? So now we have 38.3 K actual 22 K raw. Okay. So let's look at this. What does this say? Okay. So big portion is node modules now. That's that directory. And then here's our source directory in proportion. So we still have all our usual suspects here, but we're going to now we have this node modules. That's taking up a ton. So that's bloated us right. A lot. Right. And then if we do this, you ID here, that's taking up 89.7% of all of, you know, is the same, same percentage here that node modules is, and that's going to be the same moving out so we can see, we don't really care. It's just a bunch of folders climbing that way there. So then in here you can see, we have, what are the individual packages that are in those folders? Well, we have an empty five. We have a V one. We have a Shaw one with a string of five ours, and we're looking for our V4 and there it is 2.5%. So that's what we really want. Um, but then you can see along here, we're getting a bunch of stuff for the ride. There's a V5, B3. So we're just picking up a bunch of stuff. Okay. So we're going to say, we're going to pick up a bunch of stuff. So we're going to say, we're going to pick up a bunch of stuff. We're going to pick up a bunch of stuff. And then we're going to say, we're going to pick up a bunch of stuff.", "title": "Know your Webpack bundle better with visualization", "url": "https://www.youtube.com/watch?v=oAgHZ9zlmaY"}, {"text": "So we didn't actually want those methods. So, you know, maybe we want to wonder like, what's going on here. Let's go back our code to look. Okay. So when we import UUID this way, we're actually importing the whole thing. Let me show you an interesting little thing here. If we do import all as UUID, and then let's rebuild that run stats back to here. Reload this, drop that bucko right in here. Oh, that's a little bit different. Right. And now we're down to 13.4 K. So now it's only 60% node modules and then 40% the rest of our code. And then here, I mean, this is a nice little graph here just to kind of see like, oh, okay, like proportionally. My code is actually only this, this much, but if we go back out to the packages at the end here, look at this, these are a lot bigger proportion now, and there's a lot less of them. So that's all we really had to do. So that is really cool thing that visualizing the bundle can show you. Um, obviously you could just look at the output, but it's nice to be able to see it and say, oh, okay, so that's why you import it this way. All right. Well, what will happen if let, well, let me actually show you one thing before I convert it over. So let's say we don't even use it. What happens here? Right now, if the project set up, right. Webpack should be able to detect that it's not used and not throw it in there. Okay. Even though we're importing at all, it's going to be like, well, you didn't do anything with it. Okay. So NPM run stats again. Oh yeah. I always forget this refresh and then build stats. Okay. There you go. It's back to where we were this, uh, 6.5 K and then it's just our code. It's all in source. All right. So just to show that the package is working as intended, and that's cool to get a little bit of confidence there, that that's how that's working. So finally, what I'm going to do here is instead of importing all this way, I want to see if I get the same result, um, destructing V4 off of this to see if it's properly handling ES modules when we use this, so we'll go all the way over to here and we'll say, let's just call it V4 and you could rename this like they do in their docs, but I'm not going to for our demo build. Go back over here. Reload. Kick this on over here. Build stats. And that looks the same. So 13.4 K, if you remember the number and then notice we still have the stringify, RNG, V4, et cetera. Now you might be wondering at this point why we have these other methods and I'll show that at the end of the video. Um, I think it'll be a little more relevant at that point, but for now, just know that their dependencies of this V4. Okay. So we can see that, uh, when we import it, let's go back to our code again. We destruct import it this way. It works the same as just bringing in UUID star as UUID and then calling that individual function. So that's pretty neat. Now that we have that visualize, let's try another visualizer here. Let's try, uh, using, uh, a different method. Let's try, uh, using webpack bundle analyzer, which is one that I really like and we'll compare the differences. So going back to our terminal here, we're going to install NPMI. And, uh, this is a development dependency, dev dependency, because we're just, you know, using it for visualization purposes, webpack bundle analyzer. And actually while that's going, let me make a quick note on this one. Uh, it does actually say that they have a plugin and, uh, I tried to set it up before for this video, cause I'd never used it before, but I had some trouble getting it working. Um, maybe it's just the latest webpack or whatever. So, you know, if you want to try and get that working, uh, the same way that we're about to do with bundle analyzer, you know, feel free, but just so you know, I'm just using it for this quick drop in because this other tool is my preference and it's what a lot of people use. So to set this, uh, bundle analyzer up now, we're going to go to our webpack config.json, we're going to go to the top here, we're going to say, uh, const, uh, bundle analyzer plugin is the way that they normally do it. And then, uh, that's going to be equal to a require statement. And then here we can do webpack bundle. Yeah, that one, that's the one. And this is a little bit weird, but, uh, they actually make the first thing an import here. They do it like this bundle analyzer plugin and just change it on so that that's the final thing that you get back. So that works. That's fine. That's the way they do it in their install. Actually should try out and see if I can just destruct that since it's clearly a property on this, but for now, let's just get it working first. Okay. So then, um, we need to add a plugins array here and in that plugins array, we're going to new up a bundle analyzer plugin, and we're just going to call that as a function and we need a comma here since this is a property to end that. All right. And then now the way that this works is this is now in our normal chain. So anytime that we run a webpack at all, it's going to run this analyzer plugin on every build. So just be aware of that. So we can still run our build stats dot JSON, and that'll run because let's go back to our package. Jason, that will run because it runs webpack first. All right. Now I'm going to stick with build dev still so that we have the same, like size comparison analysis. All right. So going back to here, just remember that we had 13.4 K in our dev mode, and then we'll go to our terminal and we're going to do NPM run and let's just do stats again, point on build dev would work as well. You can see that it, it shows that it started the server up. Okay. So that's kind of interesting. And what I'm going to do is I'm going to copy this because, uh, it doesn't pop up for me, WSL life, you know, but it might automatically pop up for you just so you know, and then what we can do is go over to here, paste this in and there we'll get this. Now, this might not be super visually appealing the first time that you see it. Uh, it wasn't to me, but once you kind of get used to it, it's pretty nice. Now I have this, uh, zoomed in a bit just so that you can see these numbers a little bit bigger, but it tries to keep all of these squares intact. So the, the idea here is that, uh, it's showing them as a series of kind of containers instead of that, um, you know, circular graph. I'm not sure what that kind of graph is called, but this is going to say, okay, well, all of this is under main JS. And then you can see on the right here is our source and we can hover over each little thing and see the individual file size of those pretty nicely in the path and all that stuff. If we hover the whole thing, it says 13.36, which looks like it's in line. So it's visualizing it the same way. And then over here on the left, we have all of our node module stuff. And within this folder, ESM browser under UUID, we have stringify, V4, validate, regex, all the same culprits. So that's pretty nice, huh? You can actually bring this over here and you can look at some different views, which is pretty cool. But one thing that I really like is let's say I type UUID here. It will highlight all of these individually, and you can actually pin this, um, which is pretty cool. And then normally it's not this big because it's not as zoomed, but you know, for recording purposes, it is. You can actually click on each of these things to go see them. And that will be really useful when we have a bunch more packages in here, because some of them are going to be like microscopic and hard to see in it. And it lets you zoom in and see them. If you ever get in a weird zoom mode, you just zoom all the way out and then it'll reset itself. So that's pretty cool, huh? All right. So now that we have seen that, um, what we're going to do is we're going to add another package, uh, to show how things can be a little bit tricky and how you can use these bundle analyzers or visualizations to catch some problems early. This is something that I really wish that I had done early on in my career or known about, um, is it's, it's really nice way to not just look at the file size, but to continually look at where is this file size coming from, because it lists some sub dependencies too, you might add a package and not know how big it actually is. So enough of me blabbing, let's do this. So going over to load dash is what we're going to be using next. A really, really common library. If you're not familiar with it real quick rundown, it's essentially. A utilities library for JavaScript that gives you a bunch of methods that some we don't need anymore, but a lot of them are just really nice, um, like flat map and all that stuff that we didn't used to have once upon a time. Now they have a bunch of different ways to install it. If you come down here, the default, they just say install low dash, but there's also this low dash core, low dash FP. Uh, you can individually do them. So I'm going to show a bunch of these. I don't know why they don't show low dash ES. Maybe it's a different team. Um, but we're going to be covering all of those in just a moment, or at least the ones that are pertinent to us. Okay. So come back over to the terminal here. Let's close this server down. And then what we'll do is we'll say MPMI and we'll do low dash. Oops. And let's just do low dash for now. And then we'll, we'll, we'll see the differences of the different ones. Okay. So now we're going to do is go back to our code in barbarian. We will come up here and what we're going to do is we're going to import. And then let's actually look at their, um, you know, preferred way. They have a import script here. Yeah. So they want to do underscore and then require, and in our case, we can do import. Right. So come on back here. We're going to say import. We'll do oops, underscore and from, and they just name it underscore, and then we'll do this from low dash. All right. So what we're going to do with low dash is I'm going to use the low dash get method, which is one that I still haven't been able to get away from. And I'll explain it as I go. So first we'll make an object. And this object is going to be.", "title": "Know your Webpack bundle better with visualization", "url": "https://www.youtube.com/watch?v=oAgHZ9zlmaY"}, {"text": "Object is just going to be stupid. It's going to be a nested object. One, two, three. And what low dash get is going to do one, two, three, four. One, two, three, four. Great. So what low dash get is going to do is it's going to let us climb into this object and it will actually return undefined if it can't get all the way there. All right. So if we were to say const, you know, let's name this get wolf equals, and then we're going to do underscore, right? Dot get. Kind of weird. And then from here, what we'll do is we're going to say, okay, what do you want to get it from? The first thing you pass is the object. The second thing is the path, but it says a string. So you're going to do one dot two dot three. So let's not go all the way there. Let's say we expected, you know, actually let's do all the way there. I think this will be a little better example of it, but we'll just skip one. So this normally would throw an error. And what low dash is going to do is it's going to fail safely and return undefined. In this case, the get method. And you can actually pass a third argument just as a little bit of get knowledge here to return something else. Like let's say you want an empty object instead of undefined to what you get back or an empty string or something like that. You can do that too, which is pretty cool. So it's a very nice utility function. I like it a lot. So now we'll just console log, get wolf and I'll put a thing in front of it. I don't know if I'm actually going to print this out, but you know, I want to, I want to see if just in case. Okay. So now we're using it and let's run our bundle once again. So run stats. And then now that we're doing that, we'll come back here, go to this. We just refresh this now that we've started the server up again. And this is pretty crazy, huh? You can see that in our node modules, there is this like weird sliver here and this weird sliver here too, but look at source. And then this is our UUID. So apparently we've added something monstrously huge to our whole package and underneath node modules, which is this low dash. And it just says low dash dot JS. It doesn't say the methods or little sub dependencies or anything like that. Pretty crazy, huh? And if we look at our total size, we're now up to 545 KB up from like 13 KB. It's pretty wild. So that doesn't seem right. Right. So we know that there's a problem and we can see it pretty visually right away. And let me show you that thing I was talking about before. Now that we're in this view, if you do UUID, this is pretty cool. It will, you can do this. And unfortunately, it doesn't like, you know, change the box model or anything like that. That's probably too hard to do, but at least you can zoom in to each one and actually see them. So yeah, it's pretty cool. I like that. All right. Then you just zoom out, zoom in, zoom out. It'll figure itself out. Okay. So that clearly is not what we want. So let's do this because the other way that they recommend setting this up is instead of importing underscore from lodash, maybe what if we did the thing that we did before where it's import as. Okay. Let's run our stats again from the terminal. Sorry, got lost for a second. All right. And then from here, we will do, and actually while we're doing this on this mode, let's try this. Let's do npm run and I have this watch command to do webpack dash dash watch. And I'm pretty sure this will work. But what it should do is put this in watch mode and then start up our bundle analyzer server and then every time we save, it'll allow it to reset. I've done this with webpack dev server, but I've never done it with watch mode. Okay. So it doesn't look like that did anything at all. Right. Let's do a quick sanity check and say, all right, you know, you imported all that stuff, but, well, actually let's just delete it first because you're going to have an interesting surprise here. Okay. And then come back over here and look, this automatically updated. That's pretty cool, huh? Going back to our normal format and then we're back to 13.45 KB. So we know something's up here. So maybe let's undo all that and just import this. And actually I'm just going to comment these out for simplicity. Right. Sorry. I'm still on this different keyboard. It's kind of throwing me off a little bit. I have a split keyboard, so I apologize for the high amount of mistakes I'm making. Moving on. We're just going to import all as lodash. Okay. And then see what happens there. Look at that. Webpack can't figure it out. Like it could with UUID. Even though we imported the whole thing, you know, no matter how we do it, like if we go back up here and let's say we just do this, throw that back here. Doesn't care. It's still bringing in all lodash. So what this is, is when a library isn't properly set up to do ES modules, Webpack can't do what's known as tree shaking to throw away like dead code elimination or anything like that among some of the other bundle optimizations that it does. And so that's kind of our problem here. Now, what if we were to, I'll show you the way that they recommend to do this. If we bring these back in here and then what we'll say is we'll go to the directory and do that. So we'll say import get from lodash get. And then what we want to do down here is just get rid of this call to it and do that. What happens when we do that? Ooh, that did something. Now we have a bunch of little things. What's our size though? 62 KB. And it was like 500 something, right? So that's an improvement at least. It still seems like a lot of stuff. You can see it's pulling in all these things, but you might think, oh, maybe these are just sub dependencies. It's a lot of stuff to have sub dependencies of, but you know, maybe it is. And here's our get, which is pretty cool, but at least we're moving in the right direction. So that's a good start. So another package alternative that we can do here that's commonly recommended is to do lodash, oops, lodash es. And that stands for ES modules, ECMAScript modules, not Spanish, not espanol. And when we do npm run watch again, what we're going to do is see if we get similar or different results. So now we're at 62 KB, if you remember that, and then we come back to here. And then what we're going to do is instead of that, we'll do get it from lodash es. And well, let's try this first. Let's do it the same way. Come over to here, reload just in case. And it looks like it's the same, doesn't it? Now it's 84 KB. It's actually a little bit bigger, which is kind of crazy. But if we do this, and let's go back to here, and I'm going to wrap this. So I want to destruct this like we did with uuid and see what happens there. Same thing, didn't change. I mean, at least we can destruct and bring it in that way. So that's cool. And it's not bringing in like the whole library, which is great. So you can see that I guess the minor advantage here with lodash es is that if we just import from this directory, and we pull this off here, we at very least are getting closer to the smaller sizes, not the 500 KB of the whole library or whatever. So that's a good direction. You know, at least we can do this nice syntax here. But what I want to show you here is what if we were to go oops, what if we were to go back to this instance where we're like, hey, I just want to do like underscore again. I keep doing that. And then come over here. Ooh, look at that. It actually works now. So at least this package is in the right direction sort of, because it is making it to where we are getting that dead code elimination. We're back to our small 13.5 KB if we just import it, unlike the regular lodash, which just brought everything in. And they say it's because they have backwards ES5 browser support built into it. And I'm kind of curious, because a lot of packages do that as well, from my understanding. And, you know, they just work with imports, exports, like UUID does. So I'm not sure what the full scoop is there, but it's not working too great. So from here, what you could do, there are some other options. I don't remember if they list them right here. Oh, yeah, right here. Module formats. So they do say lodash ES. There's a Babel plugin and a lodash Webpack plugin. And I've seen some success with those. I'm not going to cover those today. It'll be a little bit more involved to do that. But I just think that's crazy. I think it's pretty nutty to have to set up a whole Babel and Webpack plugin chain for a single set of packages. That's just kind of wild. Let me show you an alternative. If you happen to be using only a few methods in lodash, like in my case, I'm just trying to use get maybe that's the only one you use. I have libraries or I have projects that are like that. So what we could do here, come back down here and say npm i and then we can just do lodash.get, which is nice of them. They've actually exported it by name that way. npm run watch again. So now what we can do is we'll go back to that get format where it's lodash and then this will be.get like so. Scroll down here, re-enable those and then let's see what happens. Come over here, reload this. Oh, look at that. So now the whole size is 37.96 KB and you can see that we're only getting this lodash get.\n\nAnd it's much smaller than it was before. You know, our other sizes we got up to like 80 KB with the lodash ES all the way to 500 plus with all of lodash. So this seems to be the best bang for buck. If you're just maybe you just have a couple of these, this is pretty nice. It's just modularized and it's a lot easier to view. So I think that you can see the value of visualization with your bundles right now. It just makes it a lot easier to kind of hone in and get a nice little mental model of what's going on under the hood here instead of just size, you know, raw size output. And I think this is fantastic. But what I want to show you now is the thing that I said that I would address in the beginning of the video where I said, OK, remember that UUID it brings in stringify, brings in range.js and all this stuff. Well, where do those come from and do we actually need those? Is this exported improperly? This is something that you can do that's kind of cool. If it's a well-made package, you can go to their GitHub repository and I invite you to do this early in your career or or later, you know, if you're in my position and, you know, it's never too late to learn is really what I'm saying. But you should go and look at packages and try to dig in and see if they follow some best practices and you can find your way there. So what I want to show is if we go to their GitHub for UUID, we go to the source folder and that's normally where their code is going to be. Right. We can look down here and we'll see that there is a V4.js. What I want to point out first is that there's this index.js. If we go to that, that's the common most entry point that would let you know that you could destruct variables. And this might be a little bit weird to you if you've never built this type of library before, but this is a pretty normal practice to say each of these files has a default export. And then we're saying take that, take that default and export it as a named variable. So what I want to do is this is a neat little GitHub feature. You can click this and see where it's used. They have a test for it, which is pretty cool. And then in this source V4, you know, this is probably a little bit small for you. I'm sorry. I can bump that up a bit. I'm going to go to the source V4 function, jump into here, and then we can see the actual function, which is really neat. It's pretty lean to randomize this, but it does rely on two packages, rng and stringify. Let's go back to here, stringify, rng. Looking familiar? All right. What about validate? What about regex? Okay. Well, go back into here. We haven't gone into those yet. Sorry, I had a weird browser hiccup there where my highlight wouldn't work and I had to hard refresh. So if we go to rng or stringify, let's start here, and then we'll say, okay, well, I just want to see the source rng, right? And then if I open that, we can see that it imports this crypto package. Okay. And you can kind of just keep going, you know, infinitely here. But in this case, I want to come back here. I want to go to stringify. I just want to check this out. Oops, did I go to the source of stringify? It should actually be that big. Yeah, it is. Cool. And then up to the top, here's this validate. Okay. You can keep going. I'm not going to get that crazy. But here finally is regex. That's where we'll stop. So you could follow the trail to see, oh, well, now I know that v4 is actually directly importing these. And so that does make sense why they came along for the ride. So the last thing I want to show you here before we wrap this up is how you can make it to where your bundle analyzer isn't running every single time. Because that was pretty annoying for me to figure out the very first time. So if you come over here to \u2011\u2011 well, let's just shut this down for now. If we come into our code and we go to our package JSON, what we can do is for this stats function, let's say that's the one I want to run it. And if you don't understand the problem, actually, real quick, if I do npm run build, like say this is what my server runs, it's still going to start up that webpack bundle analyzer. It doesn't distinguish it, which is kind of annoying at first. So what I want to do is come over here and say I'm going to make up like an environment variable. This is the way I do it. There's other ways to do it. I'm going to make a stats environment variable. Can't talk. And that's going to be set to server. All right? Now with server, if I come over here to my webpack config, what that will allow me to do is this actually takes an object. And there is a setting here called analyzer mode. Oops. Analyzer mode. Oh, look at the nice descriptions here. Thank you for whoever built this package. And then from there, what I can say is process.env.stats. And then we'll say let's set it to that. But if that doesn't exist, we will set it to disabled. And that's pretty oh, that's cool. Look at that. Is this built on TypeScript? Anyways, nice. So they give us all the options here. So you can see there's a static, server, a JSON, and a disabled. And so that's why here in the package JSON, I'm setting it to server because that's the default. You could just do static and that will put it out to a browser file, an HTML file you can just open if you prefer that. Sometimes that's nice. But here, especially for archival purposes, here what we're doing is we're saying if that's passed in, run it. Otherwise, disable this plugin. Now if we go back and do npm run build, it will not start that server up as you can see. And that's really cool. And then if we do npm run stats, it will. And come back over here, and there we go. So yeah, I think visualizers are awesome. And I hope now that you've seen them, you will find some use for them in the near future. And hopefully they can level up your game. I will see you in the next video.", "title": "Know your Webpack bundle better with visualization", "url": "https://www.youtube.com/watch?v=oAgHZ9zlmaY"}]