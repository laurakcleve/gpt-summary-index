[{"text": "Welcome to Swashbuckling with Code, I am Jimmy Cleveland, and today we are going to uncover the arcane mystery that is polyfills. Now you may have run into a situation where older browsers are throwing errors for newish JavaScript methods such as Object.values or Array.includes, and you're wondering, why isn't Babel preset env taking care of this like I expect it to? Or you may be unaware that this is even happening in your codebase and that you need to take extra steps in order to transpile old methods. And that's what polyfills essentially are, it's a community-written code that's written to an older spec of JavaScript for older browsers that is made to support newer and upcoming features that those browsers do not yet support. Now just know that this is a little bit more complicated of a setup, and it took me a fair amount of time when I was researching it to figure out the proper ways to do it, so I'm just hoping to pass on some of that knowledge to people that are in the same position that I was. I'm going to be starting from a basic webpack setup with Babel and preset env. If you're less familiar with that, I have a video going into more detail on how to set that up that you can check out in the notification or in the description. I'm going to show you some different options for polyfills, and at the end I'll show you a cheat code once you understand what's going on a little bit better. But otherwise I think it'll be worthwhile to you to stick around and check out the video so you can end up with a better understanding of how to accomplish Babel polyfills in webpack. Let's start out with a quick overview of the project. Now I'm going to have a link in the description for some reference code on GitHub in case you want to check that out. But to start into here, just so that you know, we have in our dev dependencies webpack, webpack CLI, we've got our Babel core, Babel preset, and Babel loader, the standard culprits. Now I've also got some scripts, and the main ones that we're going to look at right now is just build and build dev, probably just build but we'll see. And that's just going to, in production mode, run webpack and do a minified version of it, because we're going to take a look at our bundle size all the way through, since that is an important habit to be getting into. Okay, so next, webpack config, pretty straightforward. You might have seen from my other videos, we have the mode being dynamically set since to the node env. And then we're looking at all our JavaScript files, we're excluding node modules, and we're running Babel loader on them. And we have some source maps, nothing crazy there. Okay, then you have an index.js. That's pretty simple. I've kept it lean, just for this demo purpose. What we're doing is we're creating an object of a recipe. And then I'm going to show an object spread syntax that is not supported in IE 11, just to show this whole process kicking off. And this is not a method. So normally, this will polyfill, but I'm gonna show you a little gotcha that happens without a browser's list right now. But the last file, before getting into that, is just the index.html. And all it's doing is loading in our script, main.js, and running that. Okay, now if we jump over to our terminal, we can do npm run build. And you'll see that it builds successfully, just so that you know. And the 881 bytes is what we want to pay attention to. We want to keep an eye on this, just so we can see that size is going to be a factor as this process continues. And it's a good habit to always be looking at that. If you're on Linux or Mac, you can do ls-lh for longlist human readable, and then look at the dist folder, since that's our output folder here, and you can see this 881 bytes. If you're on Windows, I think you can use the dir command, but I'm not positive about that. So kicking on over here to IE, I've already loaded this once, but if I reload, you can see that we're getting a syntax error on main.js 1,4. Alright, well, let's take a quick look at our code here, and look at the main.js, and you can see 1 somewhere around here, 4, it's at the bottom here, it'll say line 1,4, I don't know if you can see that very well. But we're actually getting tripped up on an arrow function. And that's interesting, because Babel presetenv should be taking care of that, but this is the gotcha that I was talking about. What you want to do is make a new file called.browserslistrc, and then you can just put defaults in here. This is pretty weird, because if you're using Babel alone and not Webpack, I don't have this problem. It uses the browserslist defaults without having a browserslist file there, but it doesn't do that in Webpack, and I'm not sure why. But, okay, so no big deal, let's just put that there, and then if we run our build again, we're going to see a slightly different build size, 886 here versus 881, okay? And then if we were to go back to IE here, and we reload, we will see that the code actually runs here. And just a quick note on this, you can see it running, but if you do have access to IE 11, there's a weird little thing that they do where if you go, I went to emulation here in this little drop-down menu, and it defaults to 7, which are IE versions, and I do not know why that is. It confused me so much, because I'm not transpiling to IE 7, and I don't want to support that, but that's what it starts out as. So just a quick note there. Now, if we go back over to our code here, if we go to main.js, and let's actually format that just so that you can see it, list it out, you'll see there's a bunch of code that's been put in here pretty much to cover this function. Let's put it down here. There's this R function that we're doing for our object spread, and this is all minified and mangled, and that's why it only says R, but that's essentially what this is doing for us, and that's why that's allowing it to run. So that's just that gotcha for you real quick, and nothing crazy. It's just, yeah, it threw me for a loop the first time. I thought you should know about it, and we're going to need a browsers list moving forward, so there you go. Now, a pretty cool little trick here is that you can go into your terminal and do npx browsers list, and if you do that, it will actually read your config and tell you all the browsers you're supporting. So if you want a little sanity check there. Now, there is another little gotcha here that if you do this in just like a random directory or whatever, it's going to list out the browsers list defaults. So if you want to make sure that your browsers list config is working, try doing something like this, you know, IE 11 or whatever, and that's all we're targeting, and you'll see that that's all it prints out. Cool? Okay. So that's all there is to that. Just wanted to show you that. So we're just going to leave defaults. We don't need anything custom for this one, but, you know, that's a whole other topic. So next what I'm going to do here, I am going to add a method that I know is not going to be supported here. So what I'll do is I will make another console.log, okay? And I'm just going to put es8 object.values example. I just happen to know it comes from es8 here. And then we'll just do object.values, run that method on our newly created thing, the gauntlets recipe here, okay? And so now when I run npm build, where's that? You'll see that we get 994 bytes, so it's going up a little bit in size just because we added those files. But then if we kick on over to IE, I have these windows split, it's really annoying, but it's a nightmare to deal with there in Spectre otherwise. So if I reload this, we're going to get a new error, and it says object doesn't support property or method values. And that's unfortunate, and that's because this is actually a method that requires a polyfill. So let me show you the first way to fix that, and then I'll kind of explain why you need to do this. So if we jump back over to our terminal, what you're going to want to do is npm i dash s for save. We don't want a development save dependencies, we want regular dependencies here. And then we're going to do core dash js, and we can just do the newest version. That's what I'm going to do here. And then what we can do is pop on over to our code, and at the top here, we know that we need this specific method. So we can actually just import it from core js. So we can do core js, and then it's going to be slash modules, and then it's going to be es, and there's even es next in here if you're using some future proposal stuff, just so you know. But you can do es, and then we're looking for the object. It's really nice how they've written this out. And then from there, what object are we looking for? Well, it's the values method, right? Okay. So we're just straight up importing that. And then we will npm run build. And you can see we now have 9.13 KB. We went from 944 bytes to 913 KB. It's a pretty significant jump for something so small. You might be surprised at that. So then we go back over here to IE, and from here, I will reload, and our code should work. I don't know why it takes a while, but it does. Cool. So there it is working great. You know, if you're curious about Chrome, it's also working, and you can see this 9.3 KB. So yeah, we were getting close to 1,000 bytes, and now we're at, you know, over 9,000 bytes. So hopefully that illustrates to you a little bit of the why or clues you into that. Because a lot of people, when they set up preset env, I know that I was one of them, from Babel or Babel, whatever your preference of pronunciation. It seems like it should just do all the things, right? Like it targets the default browsers that it decides it's going to, and then it transpiles all your code to old JS.", "title": "How to get polyfills with Babel 7 and Webpack", "url": "https://www.youtube.com/watch?v=YXtQms2msZQ"}, {"text": "And, you know, then you go to run it and it doesn't work, and it's very confusing. And that's because they're opting out of that as the default, because there is a lot of file size increase that's going to happen. This is just one method. Imagine if you were using a bunch of methods. It can get pretty crazy, and you're going to see that. So the reason is the one of the reasons, at least, I think it's the main one, is that the size can get nuts, and they want you to have to opt into that so you aren't just exploding, you know, your users' download sizes. All right, so that was the leanest way to accomplish what we want. Let me show you another example to kind of build on this, though. Now, if you happen to want to do some async await, for example, this is kind of a strange one. It's different than a lot of the other things that you have to do, because normally you just import, you know, whatever method that you need from core.js modules, and you'll be good to go. But in this case, what I'm going to show you is that I just taken the example from MDN, where they just wrote a quick async function here. It's going to await this resolve that creates a promise, does a set timeout and all that nonsense, and then it calls a sync call. Okay, so we're just trying to get some async await funness in here. Now, let's pop back over to the terminal once again. We're always popping. I don't know why it's pop. I just like it. And then we're going to run a build. And you know, 9.84 KB, not a huge increase for what we're doing. But then let's reload this. So yeah, regenerator runtime is undefined. What a weird error. I've gotten this in the past, just like trying to do NPM installs and like what on earth is that? You know, once upon a time when I didn't know what it is, and now I do. So let me show you that. So we're gonna want to do here is you're going to want to install. And this is going to be saved as well. And the reason is because these are actually getting bundled into your final output. That's why these are saved and not dev dependencies. So you're going to want to do regenerator runtime. All right. While it's installing, well, it's already done. It's pretty fast. We'll go back over to our code here. And at the top here, you're going to import regenerator runtime and it's slash runtime here. It's kind of weird. All right. One more time. Run a build. Let's go back to IE. We'll reload this here. And this time it should work. Oh, no, it doesn't work. That's right, because we need promise as well. I'll add that and I'll then I'll show you the code. So in this case, we actually already have the package we need. All we need to do is say import and then we're going to do core JS modules. Yes, dot promise. It's pretty straightforward, right? And notice that our I almost forgot our bytes here. 16 KB. We are up and climbing with all these things that we're importing. Now we're all the way up to 26 KB. So you can see how adding one feature after another is starting to bloat up our builds. And that's just something you have to be aware of. You know, you want to start early paying attention to that because it'll sneak up on you. Okay, there you go. Boom, calling and resolved. Isn't that awesome? So we've got it working now. And let's take a look at our code, the output code here. So if we go to our main JS, who is getting nutty, I might have to build dev on this one. I don't know if this is going to work quite right. Otherwise. Yeah, let's do that. Let's do that. So I'm going to do NPM run build dash dev just so it's a little more readable. And that's you can see the difference here between running production minified. You've never never looked at that. And running a development build. Whoo, big old difference there. Alright, so go back to main JS. And I guess I need to close that because I formatted it. So wants to save me for myself, I guess. And here's what's interesting. There should be a async generator right here. And you we don't need to get too nuts into this. It's just from what I've learned is that a sync way is not itself. I don't know I'm saying async, async away, you can say it either way, I guess. Async away is not built on generators like in the actual way that it is in the modern JavaScript versions. But the way that they transpile it is through generators actually. And so that's why you need that regenerator runtime, because that adds all of the generator fallback code and you need that and then it's still using promises. So you need the promises as well. And that's why we need all that stuff. Whoo. Okay. So yeah, so this is great. And it's kind of cool that it's lean. You know, we just have them at our entry point right here. We could if we only use it in one file, we could import them there. Or we could import whatever ones we want here at the root. But it's gonna get pretty hard to maintain this and really annoying to constantly do that back and forth. And so we've got some other options for accomplishing this. So the first thing that we could do is if we we want to keep our regenerator runtime, but let's say we're not worried about all of the different methods that we don't want to import them individually, we're just going to import all of core j s. Let's see what that looks like. Doing a real naive move here. 176 k B. Yeah. And that was you know, 120 was from the dev. This is this is minified. So 26 k B. We've jumped all the way up to 176 k B. That's a pretty good jump there. So that doesn't seem like the option that we want, because we don't want to be super lazy. I guess we could and just fill all the things. But that's getting a bit wild. And I think we should be a little more respectful to our users. This is where Babel can start having our back. So if we go to the Babel RC file, and this is going to be a little bit weird, but you actually want to put a another set of array brackets here. This is just how the syntax works. Because we want to add a config object here now. And so this config object is going to have what I'm going to do is I'm going to throw debug true on because I think this is a cool little hack you can do to get some nice output. But the thing that we're wanting here is use built ins. And we're wanting the entry property this time. Okay, so let's run that. npm run build. We got a bunch of output and we got some errors. Okay. So this is a lot of stuff. Let me actually. Okay, so coming up to the top, they actually give us a clue here at the top of what our error is going to be caused by in this situation. Let's say we noticed that you're using use built ins option without declaring a core js version. Now they assume so if I didn't install core j s, this would work at two because they assume two, but three is a little bit better for various reasons. It's a little more modularized modularized as far as I've read, and we're using that newer version. Okay. And so what we need to do is go back to our code and put this simple little change and say, Okay, core j s is at three. And this is a JSON. So Oh, God, I don't have that anymore. core j s. There you go. So we just need to set it to whatever version that we have installed. And if you don't know, you just go into your dependencies here. And here you go. So you can just set it to all of three, I think you can set it to the exact version as well. But I just do it as three there. Okay, let's try and run that again. And then we'll look at our output again. But the camera on the build, you can see as we're doing this, that's why it's getting all of these errors here is it couldn't resolve from two. So 153 kb. Well, that's not as small as we had before, unfortunately. But it is a little bit smaller than let's see if we can find that old one here is before that error. 176 kb that we had before. And what's essentially happened here, as far as I understand, because this is not my preferred way of doing this. But when you use the entry, what it's going to do is it's going to look at your your browsers list setup or whatever your target configs are. And it's going to polyfill for all of the things that it would need from that. So it's taking that core j s import that we had, and then it's going to output all of that, all the different various polyfills for well, let's look npx browsers list for every one of these browsers that it needs to support. But there is a better way that we can do this with this really cool cheat code feature that I'm going to show you here. This is what I usually use in my setups. And if you've if you're used to this in the past, or you come up in the docs with it, let me actually show you this before I get into this. It used to be called Babel polyfill, there was this plugin at Babel slash polyfill. And that was the way that you used to do it. And that's what I'm used to. But now, as of Babel 740, it says this package has been deprecated in favor of directly including core j s slash stable, regenerator, runtime, etc, as needed, and then it shows that. So you could, you know, do just core j s or slash stable here. So just just so that you know, this is the new best practice. And I think that it was mostly because they do not support proposals anymore. And I think they used to and core j s.\n\ncorejs3 did some cool stuff when they upgraded from two and the upgrade path wasn't straightforward. So they they decided to just do it this way for support. So coming back over to here in our config, what we can do is go to our Babel RC. And here's our little cheat code here. What we're going to do is change this to usage. And now when you do usage, you actually do not want to import over here in index js. You don't want to import any of these things anymore. Okay. And then if we go back and do npm run build, boom, pretty cool. So now look at that, we're back down to 27, four kb. All right. That's pretty awesome. So what this has done, this is the reason that I'm doing debug here is that this really nice thing will tell you, this is the plugins that are just being used, you can kind of skip that for now. But it's nice to know. And the main part that I'm looking at here is using polyfills with usage option. I don't know why that was hard to say usage option. And then here, it tells you the file that it found some methods added following core j s polyfills. And then here you can see defined property to string values and got our promise, and then some web timers. So it found all the things that it felt like it needed, and it polyfilled them. So yeah, we're still down quite a bit, especially compared to the 170 kb. So I think that this is a pretty reasonable approach. And it's pretty cool that it just does it for you. So why it's called usage is it actually looks at your usage of each thing, pretty straightforward. But it was a bit confusing to me when I first read it at the entry is saying, Hey, where's my where's the entry point here, we're going to import them there. And I'm gonna look for that. But usage is a fancy one that will go and look at each of your things. Well, actually, let me show you this pretty cool thing real quick. So if I were to create a new file, and we'll call it includes example, j s, not the greatest name, we're going to export default includes or actually, we'll do a function includes example, that is going to take in two arguments is going to take in an array, and then like a target that you're looking for. All right. And then we'll just console dot log pretty straightforward, our dot includes since that is a newer method. And we'll say does it include the target? All right, come back over to here, in our index j s. And let's import that. So we're going to import. And then we can call it whatever we want. But we'll call it includes example, just to stick with it. From dot slash includes example. And then we're just going to run that immediately. So we'll say, let's call includes example. And we're gonna write an array on the fly here. And I'll just pass it, you know, like a, b, c, pretty boring stuff. And then we'll say, does this contain B? All right. So then we'll go back to here and we'll run it. You're gonna see something pretty sweet. Now when we look at the using polyfills with usage option, you can see that it looked in the index j s and found the same things. And then it went over here. And it said, Oh, well, I added these polyfills, radar includes and string dot includes here. Pretty cool, right? So it's going into each file, and it's telling you, hey, I found this method in this file. So I went in ahead and I added that for you. Pretty cool. So let's see if that runs in IE. Now, if we have backward support, we should see that at the top here. True, it did include it. All right. And this whole usage thing, I believe that this is a might be specific to webpacker bundlers, but I'm not sure. But they say in their docs that it takes advantage of the fact that a bundler is not going to load the same polyfill multiple times. And so that's why they can do that. And it's pretty sweet, because otherwise, you know, if you had the same method in a bunch of different files, that those might get duplicated every time it needs to polyfill them. So this is neat. And it's really cool little cheat code here that I like to call it, or you just throw that in and it goes and it looks for old polyfills and it bundles them all together. All right. And did we check our size on that last one? Yeah, 29 kb. So we're up and climbing. So I hope that one, I just wanted to instill that habit of like looking at your bundle size is really good, really valuable. And I wish I was a lot more focused on that when I was newer as a developer. But it also is really good to understand why polyfills are included, because we started out in the bytes range of our code. And now we're we're up to 29 kb. And that's pretty insane. And we're only using a few methods, even with this awesome cheat code usage, you could see it could get pretty big pretty fast. Now if you just a little note, if you want to use like super cutting edge new features that aren't stable, and their proposal JavaScript features, there are some additional steps that you'll need to do. You can look that up in the Babel docs, but I'm not going to cover that today. All right, well, I think that covers it pretty well. Hopefully this is a little bit less magic to you. It's still gonna be magic. Of course, there's there's a lot going on here. But you can kind of get a glimpse into what's going on. And I think that's kind of fun. For me, it gives me a little bit less anxiety, especially when I see these errors, like cannot find regenerator runtime. And I'm like, what in the world is that and I have to go search about it. And now I know what it is and what it's used for. And I know that it's involved with a single weight, and maybe other things. And that's cool. And so just little by little, we start to kind of get do delving under the hood, we can see that core j s if you ever see that pop up, you now know what that's used for, for these polyfills and all that type of stuff and how Babel uses it. And I think that's pretty awesome. So I hope you walked away with some sweet learnings from all that. And I will catch you on the next video, hopefully.", "title": "How to get polyfills with Babel 7 and Webpack", "url": "https://www.youtube.com/watch?v=YXtQms2msZQ"}]