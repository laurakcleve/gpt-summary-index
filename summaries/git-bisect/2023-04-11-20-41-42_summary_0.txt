PROMPT:

The following is a transcription of a video for web developers called 'Using git bisect to quickly find the origin of a bug'. Write a detailed summary of the video, providing an account of the steps taken and topics covered. Include any names that would be useful for a keyword search: names of tools, specific commands or messages, etc. Use the first person point of view, using 'I' instead of referring to the speaker as 'the host' or 'the speaker'.

---
TRANSCRIPTION:

Welcome to another exciting episode of Swashbuckling with Code. I'm your host, Jimmy Cleveland, and in this episode, we are going to cover git bisect, a mysterious command with many arcane abilities. So this is actually a really cool command that I learned about randomly in a Twitter thread. I'll show you that thread. It was kind of interesting. And what it is, it's a troubleshooting technique to locate errors that can be tricky to track down. It has a lot of uses, but it's really, really powerful once you add it to your toolkit. So I've actually set up a nice little git repository, which I will link in the description, that you can use to try the command out. And I think it's a good way to kind of introduce you to some of the different ways to use it. So let's get to that. Git Bisect All right, well, let's start out with the repository. So here it is. I will link it in the description. And I have this git bisect practice example readme that tells you the commands that you can run. I tell you the good commit to start on. That will make more sense once we get into it. And let me actually show you the tweets that led me to this. So Dan Abramov, you know him, you love him. He hates that you love him. But he made this interesting little tweet one night, April 7th here. I don't know, this was this year? I don't even know. I can't keep track of a time anymore. But bisecting is one of the most effective ways to debug problems. I'm not going to read this whole thing out loud. I'll link these in the description as well. But this kind of led to a really interesting discussion. And I was trying to figure out, what is he talking about with bisecting? He kind of clued me into it with understanding the layers and their order and how to cut them in half. That's really what clued me in. And so as I was reading down, I'll go down here. Someone said, you know, what does bisecting mean? Thank you for asking that. Walston, interesting. And think of binary search, but for debugging. So yeah, this is, I have this technique that I've used for a while. It's kind of a brute force technique. And what it essentially is, is that I call it a binary search. And this is what clued me into this. I was like, oh, I think that they're talking about this thing that I do. I didn't know this was like a named thing. So binary search is essentially if you have like a sorted list, you like cut it in half. And you see if the thing is at the left or the right. And then you know, you if you know, it's not on one side, you know, it's on the other, then you cut that in half, and you cut that in half, and so on, so forth. So it's an O log n really efficient way to do that. So what I actually do, it's a silly name for it. But if I know my code base well enough, I can comment out half the code or half the imports or, you know, any sort of situation like that. And, you know, this is when I'm like, I can't intuit my way toward finding a problem. It's just like, okay, I'm really, really stuck. And I just I have to figure out where is this bug coming from? It's not making any sense. So I comment out half of it or delete half of it. And I see when the code runs, if the bug surfaces, and if it doesn't, and I comment out the other half, etc, etc. Or if it does, doesn't matter. So then you can keep commenting that in half and half and half until you get to a reasonable point where you can kind of guess and locate exactly where that is. And it's actually a really strong troubleshooting method if you're just out of options. So this was really interesting. For him to say this, you can bisect commits to find a bug by finding a commit where it doesn't repro. So like reproduce here. Check the commit halfway between master and that one. So I'm going to show you that. So it'll make a little more sense. And I'll come back to this last tweet after I show you the manual way. So let me jump over to the code. So you don't need to know a lot about this code. But I'll show you the minimum points that you'll want to know for this repo just to kind of follow along on the example. So it has an index, JS. And all that does is really import this invoice printer. And when you run that, it's going to take some data from these JSON files and run it through this printer function that does some stuff and output an invoice, essentially. And I also, in this instance, I have a test that I've written for it. It's an inline snapshot test. So it's a really minimal test. And the idea behind this repo was that, let me show you in the history here. So if I go back to the beginning, you can press J to go down if you're ever doing Git log. But also if you know Vim at all, Vim shortcuts, you can do shift G and that will go to the bottom. So down here, you can see initial working commit with test. And then I have these refactor, refactor, refactor, refactor. And you can see I'm using these names like extract function to amount for previous. That means extract function, replace temp with query. I've got all these names. Some of these names might ring a bell for you because what I was doing is I was rereading Martin Fowler's book, Refactoring, because he made a new edition that he rewrote all the examples in JavaScript, which is really cool. So I was going back through it. And I read it a while ago and I mostly understood it, but there's still a lot that I could learn from it. And so as I was doing that, I thought it'd be cool to follow along with the examples with a test suite and do them myself because, you know, he mentions that's one of the important factors of having confidence in refactoring is having a test suite. So that's just some side knowledge on kind of like what's with the naming conventions and what's going on. This is an example actually from that book. Yeah. So I'll link that as well. Okay. So that's what's going on here. And if we quit out of this and we go node index.js, you will see that it prints out this invoice. Okay. Now, if I run npm t, which is the same thing as running npm test, I will run my test suite and you'll notice that we get a fail. Okay. And this is a really, I really like this example because it's a very subtle thing. It's just some math got off in the middle of it. And so this math here is causing a failure. And if you're not familiar with inline snapshots, they're really cool. I mean, snapshots in general are really cool. An inline one is nice because it will generate it out into the file. So if you just want to look at the output real quick, it's really cool. And all it does is it just takes an input. And in this case, we run the function and then we pass in the invoices and then it essentially runs the code and then captures that output. And then each the test will compare it to the passing version of it. And it'll tell you if it's different at all. And it'll give you this nice little formatted. This has actually come a long way. This is a just snapshot and just the formatting is really nice. So now that we've seen that it fails, let's take a look at this. What if I were to check out my initial commit, the very first commit, I'll check that out. And then I will run node index dot JS first. And you can see like, if you didn't have tests, you're going to gloss over this eventually, if you're doing a bunch of refactors, especially if you get fatigued, it's you could definitely miss like a small number difference like this or a text or something like that missing. And that's why it's really nice to have a solid test suite here or something because here you can see the original one passed. So somewhere along the way, I screwed up, right? And so if I get checkout master, again, we can look at the whole get log. And you'll notice that somewhere down the line here, I have this commit that says, I introduced a bug here. So this is the place where I purposefully put it in the middle of the commits to showcase this ability. So now let me get to the actual point of this video, which is get bisecting. So here's how it works. You are going to let me show you this again, you're going to want to find the good commit that you know, and it'll be a little bit faster if you can find a more recent one. So if you just like, you run into a bug, and you go back like five commits, and you're like, I swear this used to be good. You check it out, you run it, it runs well. So you would say, okay, this is the good commit. So in this case, I'm gonna go back to the very beginning, we're gonna say like, I do not know where this is, I'm just going to start from the beginning. Okay. So I'm going to start a bisect by saying get bisect start. Now, when I start this bisect, what I need to do is say get bisect. And I need to tell it the bad commit and the good commit. So bad, typically, you just write it like this without a commit, because it's probably going to be the one you're on, but you could pass one in. So that's the bad one. I'm going to say get bisect good. When did this code last work the way that we expect? Well, I pasted in the very first commit number, boom, and the bisect has begun. So now it'll say, okay, we are on this commit now. And we have five revisions left to test after this. So roughly three steps. So if we say refactor, change function declaration, okay. So now I'm on this commit, and I need to tell it, is this a good one? Or is this a bad one? So if I do node index.js, we'll see that it's 47. Okay. And if you don't remember if that was bad or good, because, you know, it's math, and maybe we don't know, we can run the test in this case.

(END OF TRANSCRIPTION)

---

SUMMARY 0:

In this video, I covered git bisect, a powerful command that helps to quickly locate errors in a code base. This technique is especially useful when dealing with tricky bugs that are difficult to track down. I started by showing a Twitter thread that sparked my interest in git bisect and explained how it relates to the binary search technique that I've used in the past for debugging.

To demonstrate git bisect, I used a git repository I created for practicing this command. The repository contains an invoice printer example, inspired by Martin Fowler's book "Refactoring." The main file, index.js, imports the invoice printer and generates an invoice using data from JSON files. There's also a test suite, which helps to ensure the code works correctly.

I began by running the test suite, which showed a failure due to an incorrect calculation. I checked out the initial commit, ran the test suite again, and it passed, indicating that a bug was introduced somewhere along the way. To find the commit that introduced the bug, I started the git bisect process.

First, I ran `git bisect start` to begin the bisect session. Next, I specified the bad commit (the current one) and the good commit (the initial one) by running `git bisect bad` and `git bisect good <commit-hash>`, respectively. The bisect session then placed me on a commit halfway between the good and bad commits.

I ran the test suite to determine if the commit was good or bad. If the test passed, I would mark the commit as good with `git bisect good`. If it failed, I would mark it as bad with `git bisect bad`. Git bisect then moved me to another commit, and I repeated the process until I found the commit that introduced the bug.

Overall, git bisect is a powerful tool to have in a web developer's toolkit. It can help to quickly and efficiently locate the origin of bugs, saving time and effort in the debugging process.