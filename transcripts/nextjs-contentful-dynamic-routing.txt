Hey everyone, welcome to Swashbuckling with Code. I'm Jimmy Cleveland and we're going to go through generating out dynamic routes in Next.js using some Contentful data. If you haven't watched the previous video yet, I highly recommend going back to that one which I'll have in the description. It'll be part of this whole playlist that we're doing of walking through and building up from scratch a Next.js plus Contentful site. However, if you're just here to see how dynamic routes work in Next.js and you want to hear me talk through the differences between get server-side props and get static props and setting up your get static paths and all that good stuff, then I think you should be fine just starting at this video. If you're unfamiliar with what dynamic routes means in this context, the quick version is that you can imagine that we have a series of pages or a collection of data or records that we want to generate out a bunch of pages for, rather than creating each of those pages one by one, you know, requesting the data for that or whatever we're doing. We essentially want to react to however many records we have, we want to loop over that data, and we want to build one page per each. And that does mean also generating out the route based on some sort of ID or slug or something like that. So that's why it's called dynamic routing, and I think the rest will make more sense as we jump into the code. Okay, so we're picking up where we left off from the last video in the series. I have the playlist in the description as well. And I'm going to be on a new branch here, dynamic slug. So I'm exactly the commit we were before, but I've made a new branch called dynamic slug. And I'm going to be using this pattern for each of the videos in this series. I think it's just the easiest to have one branch all in the same repo, one branch per video. That way at the end, the main branch will have, you know, the end of the project or wherever I've kept it most up to date. And then you can go to each individual branch for the end of each of the videos to see, you know, if you want to compare your code to mine. So to start this off, I'll just start up our server with npm run dev here. And we're going to open this in our browser and just see where it was where we left off. So we never touched the homepage, we are going to go to slash product one, and make sure that our content still rendering and it is so this is still coming from Contentful. And then here, let me show you in the code. We're on this product one page. So we have hard coded this page right now, or just made this file, I should say. And you scroll down here, and we're just getting the entry for a very specific ID, right. So the next thing that we're going to want to make this a little more real world is we're going to have multiple entries. In this case, we're kind of simulating we're doing product reviews. So we're going to have multiple pages of product reviews. And we're going to want to generate them all out. Now we could go through and make each file for each one, you know, in a really, really classic HTML way. So I can make a product two page, I can make a product three page. But then I have all this duplicate code that I've figured out how to abstract. And it's just kind of silly, when I could just fetch all of those entries and dynamically generate them all out as pages. And that's what we're going to do. So it'll probably make the most sense to go over to Contentful and make a couple of those pages. First, let's do that. So here in Contentful, in my space, we the only type we have is this product review. And so I'm going to do add product review. And that's on the content and go back here. So you click content in your space to go create some new entries. And here, what we'll do is we will have a new product. And we'll just say this is product two. We'll keep with the same convention. You know what, maybe I'll actually make something just so you can kind of see sort of dynamic difference. We'll make like XF Z dash 331. You know, let's just make up some like product ID here. Then I'm gonna make a heading. And so this will be the fantastic second product or something. Subheading does not matter. We're just going to fill all the things in. So we'll publish this. And now we're ready to fetch this. Okay, we'll go back to content. And you'll notice that when I made that one and backed out, it made an untitled draft. So I'm going to go back into that. And I'm going to finish that off. And we'll just make this one, you know, ABC 123. I don't know why I wouldn't just do that in the first place. Product number three. Okay. And woof. I don't know why. So now coming back to content, we have these three pieces. And you can see what's kind of cool is we can sort this by updated in case we ever want to see like, you know, if we or anyone else came in and updated this, what was the last change that happened? I do this a lot. I just pointing it out because I do this a lot when other people are editing a bunch of content and something for whatever reason, unfortunately, has an error that, you know, breaks the build, or you got something weird happening on the site, you can come in here and kind of see who did the most recent changes and go look at those articles and see if anything stands out. Now, I know these IDs are going to be hard for me to remember to test things out. So I might copy those over in a moment. But let's actually get some things working here. So we have these three product review pages. And we want to say, okay, I want you to go fetch those and build them out for me. And what I'm going to do, which might be a little weird at first, but I hope that it will kind of make the whole picture a little more clear by doing it this way, is I'm going to switch our get static props to get server side props. Okay, I'm going to explain why. So get server side props, just like that. You can also find that in the next js docs if you want. Now, as far as this is concerned, nothing should really change. Like if we go back to our website real quick, and reload the page it from our perspective, nothing's really different. Okay, the the thing that is happening different is that we are essentially generating this content out at request time, it's not going through and building up the pages out at build time ahead of time, and then you know, having them as a bunch of flat or static files, as they're commonly called. So we're behaving a lot more kind of like a traditional server here, except we are, you know, still generating out all of this, what normally would have been react client side code before, you know, into the document before we give it to the user. So we're doing this on request here. And the reason I'm doing this is because it's a little easier to set this up for multiple pages for a particular slug. And let me show you that. So if I rename this, and I promise I'll explain this and the when we transition back to get static props and why we're doing it and show some examples. So we can change the name of this, we had it as product one, right, we can change the name of this to brackets slug, this is a next JS convention. Now it does not have to be slug, I'll show that in a sec. So we will name that whatever we want. But it's a really common convention to name a slug. And if you're not familiar slugs, pretty much a common term for sort of like an ID, something that you throw on on the end of a URL. So for doing you know, whatever page we're on slash whatever. So in this case, this is saying any routes that since I have it in the root of pages, any routes after just the homepage route slash whatever, are going to resolve to this template. So let's test that out and see if that's actually working. So we go here and we refresh. And you'll notice that we do get that right product one, but we could actually type whatever we want here, we can type ABC, see it wasn't even one of the ones that I had, it's always going to return the same thing right now. So if I go back to product one, and then I go back to my code here, what I can do is there is an object here called context, you can name it whatever you want, of course, and we're gonna log that. Whoops, context. Probably should just put that in an object. But then what we'll do is we will hit our server. And we'll look at the actual server output. And you'll see that we get this big dump, right? So this first object has a ton of stuff on it. So if we go to here, it's even further up, sorry, lots and lots of data. And this is like a, this would probably be familiar to you if you've done some Express stuff before with the request object and all that stuff coming in. So you can see it's context, all this stuff comes in. And some of this is really, really useful. And this allows you to, you know, respond to let's say, like the user agent, if they're using Firefox, or whatever they're using, if you want to base it on like the type of device they're using and their location, all that type of stuff. We're gonna keep it pretty simple here. What we're particularly looking for is going to be down here, I think at the bottom. And you'll notice there's this params property. That's what we're interested in. And it is very similar to query, but query will have additional stuff like what's on the query string. Whenever we pass, you know, slash whatever, and it's going to come in in our params object as whatever we named that little file. So let's go back to our code. And we can just simply log out context.params.slug. Okay. In fact, I'll just log out params from this point on just to show up for there. And so all we need to do now is figure out, okay, so whatever the user typed in, that's what we want to go and request, right, like that product ID. And it will just to show you if I rename this real quick, I'll name this to, you know, I'll rename this to, you know, I'll rename this to, I don't know, we used wolf earlier, so let's just use wolf. And then we'll hit our page again, go to our server. And then you'll see that params object here is going to be wolf. Okay. So we do have to match it, I'm going to change it back to slug. We do have to match it to whatever we named this file. And since I'm editing this currently, it would probably make a lot more sense if this file resided in a like slash product slash whatever the ID is, right. So we'll create a new folder, we'll call that product, new product or plural products, whatever format you want, move that file into there. And now what's going to happen is when I refresh this, this is no longer a valid route, because I need to type in product slash and then whatever we want. So product slash one or product slash product one, you know, whatever the whatever the key is. Now, a quick note, I was going to leave this to a future video, and I'll cover it a little bit more later. But just in case, just so people don't get confused, you might see a format sometimes in the docs that's like dot dot dot slug, right, like brackets, or even double brackets. Okay, so what that is, essentially, let me give you an example, just so you know, is that if the limitation here is that if you do product one, that works fine. But if you did product one slash two or slash whatever, that doesn't work. So our bracket slug is only catching this first param here. But we would do the dot dot dot if we wanted to catch multiple paths. And there's a lot of different reasons why you might want to do that I'm not going to get into right now, like maybe you're doing some sort of crud or whatever model where you know you want to have you're fetching the thing for an ID, but you have like an edit view or a show details view, you know, the read view. And there's other reasons as well, you can kind of come up with all sorts of different paradigms that are pretty common for that. But a really common simple format is just to use this bracket slug. So we're going to keep it simple like that for now. Okay, so now what's really left to do is to go get that content by the ID that we're requesting, right before we switch it back over to get static props. And I'll show you how to do that. So we go back into our browser, I have these docs up earlier, and these will be in the description if you want to go find them. But there is these there are these using JS CDA SDK. So using the JavaScript SDK for Contentful docs, and we had previously used this get entry to get a single entry. So if you scroll down a little bit, there's some more about get entries. And they do talk a little bit about it, how you would do pagination, there's some useful things here. But in particular, probably the close, let's find the closest that we want, we want to get something by content type, this is a really common way to use this and how I usually do it. So I'm going to copy this part, I don't need that that after part, come back into here. And for this client dot get entry, instead, we're going to do you know, I actually got rid of all of that client dot get and trees. And that takes an object of options here. And you can do by product type. So how do we know our product type? Well, if we go back to Contentful, and we go to our content model, you can click this. And you can see right here, this is the content type ID. And that's in particular what we want. So we'll just paste that here. It's a string. And now we're going to get entries for that. So let's look what that returns with that, you know, this is going to break. But for now, let's just do product. And this is actually products in this case, but let's do that. We'll call it product. I'll just leave that for now. And we should still even though it breaks, we should still get a response here. So we refresh this, we should get an error, I think, oh, actually, we just get nothing. Let's go back to our server and see what we got here. Okay, so we did for the context, we got the slug of one, we just went and got all products, we didn't look up that particular one. And you'll see we get some data back, it says we got three entries, and we do have three total. So it did get all entries. The skip, that's just when you're doing pagination, it's limited to 100 at a time. And then you can see items. So items is usually where it comes back on. And so that's how we would get all of those things. So of course, like we could go and get all the entries. And then we could just, you know, search through them for the ID that we're looking for. But a better way to do this is actually to to do this, you can throw another property on here, it's a string. And that's fields and dot, and then whatever the field is, in this case, it's product ID. And then that's going to be equal to let's just set it to product one for now, just to make sure that we get something. And let's see what we get. So we come back here, and we'll refresh. And this is still not going to work, because I haven't got it out of that array yet. But here, we should see products, notice, we only got one here this time. And we have then there's that array. Okay, now really quick, how we would know that we were using product ID, well, you could go back to your your thing individually. And you could look at whatever you're trying to grab it by, in this case, we want it by this ID. And so you can enter, you can click settings for that. And it's right here, this field ID. And I have tried this, just so you know, to write this as an object instead of the string, and it doesn't work. So you do have to write it this way. So it's always fields. And then it's whatever your field is, this might seem a little weird to you. At first, it was a little weird to me that we're kind of getting entries instead of having a get entry method for a particular type of field. But that's just the way that there's works. I haven't found a way to do it with get entries. I've been looking at the signature. And it looks like it still just takes the product ID requires that and then whatever options you want. And I've seen it in some docs somewhere, I just couldn't locate it to link it to you, that this is a potential way to do it. One thing you could do as well, as you could look into their, I'll probably link this as well, their content delivery API, this is like the generic docs for their, their whole API, not just the JavaScript one. And the SDK that we're using is just a wrapper over their restful API. So you can come in here, it's really nice docs, they will see if we could, I'll do like fields dot, you can see this down here, they have these sort of examples, it doesn't quite give us exactly what we want. It tells us some common fields and stuff like that. I just couldn't find the spot where I had found that before. But if you look up this, like, get single asset type, you can sort it by, you know, different, you know, select your platform for generic stuff, you can see all the parameters that you can pass. So you might want to just dig through here and kind of see, you know, what are some common things to pass to it. But this is the way that I do it. So you know, if you just want to follow along here, you can just stick to this format, you will still get an array back. But that's also the way they do it with GraphQL. But their API, you also still do a get all of the collection, and then you just put like a limit one, and, you know, filter by the ID and all that type of stuff. In fact, you'd probably want to throw limit one on here, I might move this up. Because just in case there's duplicates or whatever, you still only want one entry back, right? It should never be duplicated, because it's a unique field, but a unique field. But just to be sure. So now what we really want here is we get this product back. And what we're going to want to do is return. So we'd say, okay, well, I'll do product at zero, it's actually dot items, if you remember, at zero, and then dot fields. And this should still kind of work. It's a little dangerous way to do it. But let's try it. There we go. Okay, so it is working, we are, you know, hard requesting that one. But this is a different way to fetch that same one. If we go back into here, we can see that we do have our limit one here. And we have this items that we're pulling that off. And so items is going to have all the different types of that content type, I think you get it. Okay, well, let's actually change that, right, to be realistic here. So we go back to our code, let's take that context dot params and use that slug. So for here, for product one, we use context dot params dot slug. And of course, you could destruct this or whatever. I'm just leaving it here because I think it's a little more transparent when you're just barely learning it. But if you want to clean it up, go ahead. We'll kill that. And we'll still log out the product just to see. And then we'll go back here. And we'll refresh. And we'll see that we get an error, right. And this is because it doesn't actually exist. Let's make sure it works with the happy path first. So let's do product one. And it does work. Okay. And if we go to let's do one of our other types. So we had content and we had this ABC 123. Well, that's an easy one to remember. So let's just do that. ABC 123. Boom. And there you can see that one working. So this is working. But we noticed a flaw here. What happens when we go to request a slug that we don't have? Well, we have a problem when it comes back. Okay, so there's a number of ways we can handle this. But you know, it's a little unrealistic for us to, you know, limit what you know, we go and fetch, we're still going to end up doing this little request here, because you know, it's constantly updating and we don't really want to maintain, you know, a matched list where we have to keep track of every little ID that's in our contentful thing. You know, that's just a disaster waiting to happen. So, you know, an easier way to do it is, let's hit it and request it. And when it comes back, let's check if it's even there. Okay. So what we could do is we actually could cheat and just do these little optional chain operators, which are cool. You can even do this with an array if you didn't know. And we can just do this all the way here. And just this seems like this would fail because it would spread on undefined, but actually won't do anything. You can see that right here. So we're re refresh that. And you'll see that we just get this empty page, right? Now that's not ideal, but at very least, it's not breaking. And does the, you know, correct one work? Yes, it does. Hmm. So what could we do to, you know, give the user a better feedback loop? Well, we could do something like, you know, let's put an error on the object if we have one. And we could say, okay, well, if there's not product.items.length, and I happen to know that you just get an empty array back, by the way, if you don't, but you could check that yourself. You get an empty array back if it doesn't exist. So if that doesn't have a length, you can do an and and here. And then we'll just type some message like, let's actually interpolate it. And we'll say no item or no product with ID. And then we'll do context.params.slug. Okay, now I'm going to wrap this here, just to make it a little easier to read. And then, of course, we need to put a comma here. All right. And so now what's going to happen is this going to come back false. If we, you know, did have a item come back, because it'll check the length. And otherwise, it'll come back with the string. And so what that will allow us to do is we could just check our props here. And we could do, you know, something simple like if props.error. Okay, we'll return just a simple thing here, we'll do an h1. And we'll say an error occurred. And then h2. And then we'll actually print out the error. Okay. So if we get an error, let's print them something some different render. And otherwise, we'll just continue on. You could, you know, clean this up and abstract it however you want. And it is a pretty simple primitive way to do it. I'm just giving you kind of an example. So we could refresh this, this will still work. If you type another thing, it'll be like an error occurred, no product with ID ABC 123. If we go back to our terminal, we'll see that when we got back products, we'll see that here's this items with an empty array. And that's what we were checking against. Okay, so that's just a really simple quick way to have a fallback while using server side rendering. And when the user is requesting something that doesn't quite exist. Of course, there are a multitude of ways that you could handle that. But I'll leave that up to you and the concerns of your app. So now what we've been building up toward is we want to use get static props, because we actually want to render this ahead of time. Okay. So why I went through all this, you'll see right now, when I save this, I just flip it over to get static props. And I go back and I'm going to make a request here, we're going to get an error that says get static pass is required for dynamic SSG pages get static pass, that's a new one. So when we're static generating pages, and saying it's missing for this, you know, path that we made, and they give us some docs here to check, right. So we can go over to the docs, and they will kind of clue us into here, what our particular issue is, but I'm just going to walk you through it. So what it is, is I did the get server side props first, because you can see that, when we are doing it server side, we're doing it on request, we can essentially respond to any of these IDs, we can say anything slash product, whatever the user types in whatever link they clicked, or whatever, however they got here, we want to go and request that particular ID. But how do we do that ahead of time? If we don't have anyone to go in and type those numbers or, you know, any requests coming in, how do we say, well, you need to build out all these pages, it has no way of knowing that, right? It doesn't know what all our product ideas are, or how many we have or anything. So what we need is this get static pass. This is kind of the mental model that helped me kind of figure this out why it was needed. So I hope that that explanation makes some sense to you. So what we're doing is we're now going to make a function export async function in the same file called get static paths. So you need this whenever you use get static props with dynamic generation, we didn't need it before, because we were just rendering out one thing. And next is smart enough to realize that and give us a nice error. So you can think of get static passes, the thing that runs when our build starts, it's going to go and for each of these paths that we give it, it's going to run this get static props on it. So what it expects here is we're going to return an object, and it's going to have paths on it as a key. And if you actually hover over this, you can see it does have, you know, it expects a promise back with paths of any I wish it showed more than that. But so we know that it wants paths back. And what it actually wants is an array of objects here. And that has a familiar signature of params. And in this case, whatever params we want to pass, so that we'll do like slug, and we can really pass any params we want here, it's the same as when we looked at the context params before. So we're kind of, you can think of it like we're simulating a user going through and passing in each of these things or clicking each of these links or whatever, making these requests. So for this first slug, let's do product one, okay. And then we just need to copy this. And we'll paste another. And I guess we'll just do we'll do all three here. This is ABC 123. And that it doesn't really matter the order per se. Yeah, we don't really care that as product 123 or whatever. I'm just hard coding it for now. Let me go get our other one, because I already forgot it. As I said, it would X F z 331. Okay. X, C 331. Okay, now that's almost it. So it's going to go through this array. And for each one of these, it's going to call our get static props with these params and that slug. And then you know, the rest of it's all wired up, it's going to go ahead and make that fetch per one, build out those pages ahead of time. Now there's one more thing that's required here. And you have to have a fallback key. And it would have given me an error if I tried to go ahead for that. They're really good about that. Now fallback, we're just going to do false. And I will briefly explain that after we see if this works or not. So we're gonna come back out here, and I'm gonna do npm run build just so you can kind of see it happen. Okay, so finished up, you let's check our logs first. So you can see that we got these products. Let's see. So for the first one, the error was false. We got this data. Same thing here. So we got the very first product. And then here, here's our other product. Cool. So we looks like we got each of them, the build was successful. And I wanted to point out this really nice little output that next JS gives you. So you have to see how they have this legend here. And it tells you that this static site generation, you know, using get static props is a filled in little dot. So you can see our 404 page is just regular static here. We have this sort of little lambda type thing, where it's slash API slash Hello, that's just our API route. And you can see that's a server one. Our homepage is also simple static. You know, that's just saying that we just wrote the code, we're not doing any sort of dynamic generation thing. But then here, everything under product and even prints out the ones that we made are all under this SSG using get set of props, right? So that's pretty cool. What if just to kind of see the output real quick, before I load it up? What if we were to just do get server? Oops. Side props, I moved my hand and messed me all up. I'm going to comment this out just in case. I don't know if I'll be mad or not. And we go and we rerun that build, we should see that we should have that little symbol here for Yep, product slug. See, it doesn't even bother printing them out, because it doesn't know ahead of time what they're going to be. You can request any ones you want. It's dynamic. So that'd be requesting it from the server, right? Okay, so let's go back one step, switch this back to get static props. And let's actually see it working. Now I could just start up my server here, but I'm going to do npm run and start up the one that I had built for production. I mean, let's come back to this. We'll refresh the page. If it's done, is it done? Oh, oops, that's the bad one. Okay, so here, we've got that. And then we've got one, or is it product one, right? Okay, and it's all working. So that was statically generating it. So there's the trade off, right? Like, you know, time to first bite and all that's going to be a little bit worse with server side rendering. But we have less build time to do it that way, because we're waiting for the user to request it. So it's a little bit slower for them. It kind of depends on your use case, if it's noticeable or not. At scale, it can be very noticeable, if you have a lot of things going on. But we're using static generation, which is basically what they recommend for Next.js if you don't have any need to do it on request. So we're going to incur sort of the penalty for the users, you know, we're going to take the blow for them. Our build is going to take a little bit longer, because we have to build those out ahead of time. But they're going to get a better experience overall. Those are the trade offs that you have to decide when you're choosing between these things. Now, you might have noticed that if I typed a bad product ID, I just got a 404. Okay. And so that's what we wanted. And that's what this fallback false does. And you have to choose this, it's required, these are the two things fallback and then pass. Okay. So the fallback, I said I was going to explain this. So what it is, is when you set this to true, it is setting a fallback and you'll you can kind of see it right here. If I were to refresh this, notice that we got that little error occurred thing. So that's how we could sort of still have this behavior where we static generate out the pages that we told it to. But if they want to request something that we haven't static generated out, it's still going to let it through, you can think of it that way, and do our normal flow and kind of render it as a server request, basically, it's still going to try to statically generate it for future use. But the reason that you would want to do fallback true, which you can look up in the docs if you want to read about it a little bit more. But the quick and dirty is, if you have a ton of things that you're rendering, that's a really common use case where you really don't want to wait for this gigantic, you know, multi 1000 page build, you might but a lot of the times you won't. And so what you can do is you can use fallback true to essentially say, Okay, well, I want to generate out the first like 100 pages, because those are important to me, or maybe I'll pick and choose which ones are really important and put them in my little array that I pass and get static paths. And then if the user ever requests one of these other ones, and they exist, like go ahead and and build that statically for future users, but don't build it in the initial build. This gets a little bit too much into the weeds, and I'm not going to go too much further. But there is also like incremental static regeneration, which is another cool feature the next 12 has, you don't really need to worry about these things. When you first start out, those are things that will give you some cool solutions to some problems you might have down the road. But when you're just starting out, you can be pretty solid. Just using fallback false is what I would recommend until you, you know, need fallback true. That's my personal preference. If you have a, you know, a small amount of pages starting out, start out with fallback false, you know, come back to it and read a little bit more about it and build up the complexity of your app when you actually need it. So for now, we're just going to say, hey, if you hit any, you know, product that we don't have, we're just going to 404 you. Okay, we're almost done with this one. There's just one last thing. We hard coded these. And like I said, we don't want to maintain this list of all these different slugs. So what we want to do is do this get entries request here. We're going to strip it down a little bit. And we'll say, you know, products in this case, because it's going to be products. And we're going to do still by content type, but we're not going to do a limit or anything. We want to get all of them. Then when we get products back, what we could do here, and I'll do it outside of the object. It's really common to do it in it into the return object, but I'll just do it here to make it sense. So I'll do const paths, let's call it equals. And so we're going to take this products that comes back. And remember that products has items on it. You can look it up in the console if you want to check it out. And the items is an array. So we're going to map for that array. Okay. Now with that, we're going to say for each one of those, we have a product, we could call it an entry or whatever you want. It's really common to call it an entry since we did get entries, but I'm going to call it product. And for each product, I want to return an object. And what I'm doing is I'm making my object look like these objects so that I can simply return paths really simply. So I'm going to say for each product, I want you to return an object here. So we're going to have an array of objects that has params on it. And it has slug on it. And that slug is equal to product dot product ID. Okay, then we can replace paths here. And actually, we can just do comma. So you know, it'll be the the key is the same as the value. We can also do this inline down here, however you like, it's fine. And that's it. So now if we did this, right, let's actually, you know, run a build real quick. See it print them all out. Nope, no, I did something wrong. Let's log this out. Let's make sure that it's right. Let's do this on the fly here. So we'll say paths, paths. And we'll run build. Oh, slug is undefined. You know what, I know what I did wrong. It's product dot fields. Silly me. Product dot fields. I'm sorry about that. Cool. Okay, so that worked. So now we can, you know, just double check that we're good. We can have him run dev. And now we're requesting each of these things. And we don't have a product one, three, we have product one, though. And we could very simply to test this out. Let's go make another product. And we'll just do product for I know we're being silly here. The fourth product. We'll publish that. And then when we come back here to our dev server, actually, I didn't have to go to the code or anything like that. I should just be able to request product for now if we were statically building it, of course, we would have to build it out all over again. But with the dev server, it kind of live requests it. And there you go. So now you've seen how you can dynamically render these and you can do it server side or you can do with static generation for each product with whatever format that you want, whatever, you know, sort of path URL and slug ID, whatever you want to call it that you'd like. Now, I'll just give you a little hint of kind of the next thing that you normally might want to do. In this case, you're probably fine with product reviews just to have product and slug. But a lot of times you might have a, you know, slash product page, right? Without another slash and a URL slug, because that might be a sort of list of all of the articles or something like that. For that, all you need to do is get a new file and do index dot j s here, and then do your regular song and dance of next JS and put whatever you want there. So I'll leave that as a little challenge to you if you really want to do that. But you pretty much have all the code in here to point you in the right direction to pull that off. You just remember you don't need to do get static paths because it's just a single path. So you could just do it, get all entries, dump those out however you like. Just don't forget to use next link when you do it. You know, make sure that you look up in the docs next JS link. Make sure you look this guy up because you're going to still want that fast single page app behavior. But that's all I have for this video. Once again, I hope it has been useful, and I hope to see you in the next video where we continue to build on to this little project.