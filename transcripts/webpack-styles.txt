

Hello and welcome to Swashbuckling with Code. I'm Jimmy Cleveland, and in this episode, we're going to be covering a bunch of different ways to get CSS working in Webpack. We're going to start by creating a Webpack project and then getting CSS imports to work right away. Then we'll add some spicy Sass support, as well as source maps so that you can see your original code in the browser. I'll show development and production builds with minifications so that your users can download less and have a faster experience overall. We'll cover inline styles being injected into the document by our JavaScript bundle, as well as an alternative creating an actual CSS file from our output. In the last segment, we'll add post-CSS so that we can modify and extend our final CSS output. That'll allow us to do some pretty cool stuff like auto-prefixing, polyfilling, or fallbacks for cross-browser support. And then we'll read from a browser-list-rc-config file in case the defaults that post-CSS give you are not covering enough browsers for your user demographic. Finally, we'll top it all off with a quick addition of Tailwind CSS just to show how easily we can add things to our pipelines now that it's all set up. My goal with this video is for you to walk away with some confidence in the multitude of different flavors that you can set up for CSS inside Webpack. Alright, time to code! We're going to start with creating a project here, and I'm going to be cruising through this until we get to the CSS-specific details, but I do want to show you me setting it up from scratch just so that you know. But if you're interested in me going through each package that is required for Webpack for a basic setup to work with Babel, and going through all of the different snippets of code in detail, I have a video that's better suited to that that I'll link in the description in a pop-up, so feel free to check that out if you are interested in that. But let's move on here. So let's create that directory. I'm going to name mine Webpack-styles. You can name it whatever you like. And then we'll cd into that directory. And from there, we're going to init up an npm project or package json. Dash y is to say yes to all the answers, so you can just skip answering them individually. And then we already know that we're going to use Webpack, so we'll just add that as a dev dependency. We're going to do Webpack, and then if you use Webpack and you're going to run the commands for it, you need Webpack-cli. Those go together. Now that that's finished, we can open this in our favorite editor, whichever you prefer. Mine opened in a different window, so I'll bring that over here. And we can see what we have here is a package json with just these two packages, so that's good. And then what we need next is we want to create a source folder with an index.js. And if you select to create that as a file in VS Code, it'll actually create the whole path for you, just so that you know. In this file, what we can do is we can just make a variable real quick. So we'll say const headline equals welcome to the web page or something dumb like that. Now, with Webpack, you don't need a config if you are going to use the defaults, which is the source index.js as the entry point. So that's why I've placed it there. And if we come back to our terminal, we can run npx webpack. And if you're unfamiliar with that, npx is a way to go and get the most recent or current version of a package and run it, or it'll use your local one if you have that set up. So you can see that this built properly. We do get this warning that tells us that the mode option has not been set, and that's expected. We are going to be building in production by default, which means that you'll have everything minified and mangled and all that good stuff. Now, if we go back to our code, we'll see that it has created this dist folder and a main.js. And you can see that it's empty, which might surprise you if you're not super familiar with Webpack. But all you need to know is that in the end, if it's for a production build, it's only going to put into the final output file what it actually needs to run. So what we can do here is say document.querySelector, because we're not going to be running this in the browser. We can find the first h1 tag, and then we can do, no, I don't want text content. Thank you. I want inner text. And we can set that equal to headline. So now if we go back, we run our mpxWebpack again, and we come back here, we can see that our main.js has built out that script. It's put it all together. Notice that it didn't need to keep the variable or anything like that. So just a real quick rundown of that. Now let's get on to adding some styles. So we'll create our CSS file here, and I'm just going to call it style.css. It doesn't really matter because we're going to import it by name. So here we'll just set some basic styles here. I'm going to do background color. Hey, why'd you go away? We're going to make that salmon, and then we're going to make the default color of everything moccasin for fun. And then we're going to take the h1 tag that we're going to create, and we're going to do fz for the shorthand, and I think we'll do 68 pixels. And then from there, we'll just say, can I do tac here? Yeah, nice. Cool. So text align center. And then we can go over to our index file, and we'll just simply import that. We don't need to actually name it because we are just trying to raw load all those CSS variables. We're not going to use that variable or anything like that, or those CSS styles, I should say. So we can just say style.css, and that will load our styles onto the page here. And that will make a little bit more sense, if that's confusing to you, once I actually render it out. So just bear with me for a moment. So if we go back to terminal once again, we go to build. We can see that we're getting an error, and you want to look here first at the side of the error where the file, which file it happened in, which is style.css. It tells us that it's an unexpected token, and it says, and it gives us this little hint that I think could be a little bit better, honestly, but at least it points us in the right direction. It says that you need an appropriate loader to handle this file, and that is true. And you can see that it's getting hung up on basically CSS syntax because it's not JavaScript in this case. So let's add those loaders. So we're going to need CSS loader, so that's going to be our loader to tell Webpack how to deal with this type of syntax or file. And then we're also going to use style loader because with CSS loader, that will build it, but it won't give us a way to really output it. So style loader is a way to inject inline styles onto the page. And I will show you how to create a CSS file separately afterward, but we're going to stick with style loader for now because that's a pretty big norm. So now that we've done that, we need to actually set it up in our Webpack config. So this is when you do actually need a Webpack config. So webpackconfig.js is what we're going to create, and then the normal format for this is you're going to have a module exports, which is going to be an object. And in here, you're going to have a property called rules, which is going to be an array of rules, and each one of those is typically going to be an object. And you can think of this as like each one is a rule to tell Webpack how to process a certain type of file. So to tell it what type of file, you use the test property, and typically you're going to use a regular expression. I don't even know if it takes another format, so I'm making a regular expression that's case insensitive here, and then I'm going to do CSS, and I'm going to say it ends in CSS. But we can do a little escape this dot here just to say I'm looking for anything that ends in a dot CSS. Cool. And then from there, you're going to use the use, use the use, and what that does is it makes it so you're saying, how do you want me to handle this? Like what is going to actually handle this type of file? So we'll say CSS loader is what we're using, and I'll show you that just working first, and then we'll add style loader. So that will actually get us past this error. I like to do a little bit of a red-green approach too whenever I'm demoing stuff. Red-green just means that I want it to fail first, and then I want to fix it. It's kind of like a test-driven development methodology so that you can just see what's the minimum that's needed to run something. So here we ran Webpack, and it says invalid configuration object. Webpack has initialized using a configuration object that does not match the API scheme. Okay, so, ooh, you know what? That's great. It's not rules. Yes, it is rules. Oh, ha-ha. You know what it actually is here? I'll leave this mistaken because this is funny. So it's module first is the first thing that we need. There's a module key that has rules, and that's how you're going to handle each of those. Let's try to run that one more time. There you go. Beautiful. So now it will build and everything, and let's actually take a quick look at our output here. We can see that it now has this big old minified bit with a lot more code. So you can see it is putting in a bunch of code that essentially is it. Can we prettify this? Let's see. Format. There you go. So we'll just format that real quick so that you can see the final production version of it, and you can see there's a bunch of JavaScript that's been added, and it's essentially like how to deal with all of this CSS, but you can see the CSS inlined as a string here. You don't need to understand how all this works. I just think it's a good idea to get a little bit of exposure early on so it's not so intimidating or anxiety of what's going on under the hood, and then you can kind of build up as you go, you know, taking a look at each of these things. So don't think that I know how all this code works. I do not, but it's nice to every now and then when you have a little bit of extra brain power come and take a look at each piece and get a little bit more familiar one step at a time. That's just my two cents on it. Okay, so we can see that that's working, and like I said, this does actually work.

I'm going to output it, but it doesn't give us a way to put it on the page. And so that's where we'll add a style loader in front of that there, and that will do it for us. And in order to show that, we'll actually need an index HTML file. I'm going to manually create this in the distribution folder, and the reason I'm doing that is just for demo purposes. It is a common practice in some of them. Sometimes you'll just generate out your HTML files, and a lot of times you won't write your own HTML. If you're using Vue or React or any sort of utility library or framework, it's probably going to be processing all of your HTML for you. You'll just have the starter file. And so this is what it'll look like here. I'll just use this little snippet here. We'll make a title, why not? It's just Webpack CSS examples or style examples. And then here, this is where you'd normally have your div with an ID of root, but we'll make a container class, and then we will make an h1 tag. And in that h1 tag, I'm just going to do some nonsense here. Doesn't matter what, because our script is going to override that, and that's how we'll test that our script's actually running. But in order to get the script here, we will say script, and you can use this snippet for source, and then we'll say, oh, yeah, let's go grab our main JS and run that. So I could set up a dev server at this point, but for this demo, we're just going to raw load this index HTML in the browser. So I'm going to do reveal in Explorer, and then I'll just pop this open here. And here you can see it loaded up. I'm on WSL, so it's got this funky little thing in front of it on Windows. You can see it running our script, but not loading our styles yet. And I believe that's because we didn't rebuild after I added the style loader in. So yeah, cool. So let's go back to the terminal, and we'll run npx webpack again, and we're going to add a build script for that right after this. And so now that that's there, we should reload this, and every time, there we go. So we can see that our styles came in, and if you're curious where those styles come from exactly, you can check in the head, and what it's done is it's injected the style tag at the top of the head, and that's how it works. So you can also inspect just as a side note. You can scroll down here to the H1, and you can't see this because my head is in the way, but there we go. That work? So here, with the style tag here, you can click on this style tag, and it'll jump you up here. So let me actually show you that again. If you go to the H1, you can click on this, and it'll take you up to that tag. Cool. All right, now that wasn't too hard, right? So next what we'll do is we'll add SAS or SCSS to it. So let's start from a code-first approach here, and then we'll add in the terminal the things that we need. So we want to now have access to SCSS, so we can rename this file to be SCSS, and that means that wherever we import it in this script, we also want to change that to SCSS. And if we try to run this in the terminal, of course, this isn't going to work. So yeah, you can see that we're getting the same errors before. It doesn't know how to process it, just because of the file extension. And that's really because in our webpack config, we only told it to look for this type of file. So we, of course, could add this SCSS, and then that will work. But let's make that work, and then I'll show you the next step. But we want to go to package.json real quick, since we're doing this a bunch. I'm going to add a build script here, and then I'm going to just make webpack as the thing. And I'm also going to add a build watch. You can name them whatever you like. And this is going to be a webpack, and then dash dash watch here. So the first thing that I'm going to do is run over and show you that if I do run build, it's the same thing as our mpx webpack, and that's just a little more normal, because you're going to be reusing this script all the time, and you want it to be able to build on your server that ever compiles it. And you can see that it actually builds now, but we're not using any SCSS. So that's not really that great of a win. So let's do something here. Let's create a variable. We're going to name it light text, and then we'll make that our moccasin. Can't type for a moment. And then down on the color, what we'll use here is we'll just be able to do light text. And then we can also scope this underneath this here, because that is another functionality of SAS. I'm just throwing in a couple things that would normally cause our CSS to fail. So we haven't actually added any loaders in yet. So just really quickly, if we just do npm run build, it will build, surprisingly. But then when we go back to the browser, you can see that it's just tried to load in this non-viable syntax that it can't read here. I wonder if we get a console error from that. No, we don't. OK, so let's add our loaders in now. So in order to get SAS working, we're going to need to install SAS, which you can also do with Dart if you like. I'm doing node SAS here. And then we're going to do SAS dash loader. And that's actually all we need. Pretty cool, right? And then come over to here. And if we go to our webpack config, we can tack on the end of this. We can do a SAS loader. And that's all we need. So now let's do npm run build colon watch. And then we'll go over to the browser. And we reload. And it's working again. And you can see that our output is just a regular old CSS, even though it's inlined here like this. It doesn't have those variables or anything. So in the end, it's compiled SAS into CSS. And that's how that works. And now that we have watch open, I can show you I could make a colon root tag here and then say that I want a main BG. I'm going to use a CSS variable here just to show this. And I'm going to make this that salmon that we made before. And then for the background color, I'll do var. And then we'll use that main BG. And all I have to do is save that. And then if I come back over to here, it'll still work. And in fact, let's actually change it to something. So let's do medium purple or something like that. Come back over here, reload. There you go. Now, you can use webpack dev server if you want to get that live reloading. But we're not going to cover that in this video here. So let's revert that back here. So now, what if you wanted to process both regular CSS files and SAS files for some reason? Or you want to handle both types of syntax, SAS and SCSS, or whatever. If you want a global fix here, let me just show you this. So if I add, let's just do a woof.css page and pretend in it, I'm just going to make up a rule that the regular font size is like 18 pixels or something like that. It doesn't really matter. The point here is that what I want to do is go to my index.js and I want to try and import that. And if I try to import woof.css, we have set it to where it will only look for SCSS here. And we want it to be able to find both. So if I come over here, I'm going to shut this down real quick. And then I'm just going to run npm run build. You can see that has a failure as expected. And that's going to be the same error. And so let me show you how you can do this real quick. It's pretty simple. What you can do is you can say, all right, let's start at the top here. I want to wrap this whole part because I know it's always going to end in an SS for CSS or SCSS. And I can actually say it either needs to be SC or it needs to be C at that point. And then if I run a build here, that will run now. And if I wanted to be able to support, let's say, SASS as well, I can add a bracket here, which is interesting. And what that will do, it'll say it's got to start with an S if it's going to be on this side of the pipe. And it could be an A or C here. And then otherwise, it's going to start with a C. And then SS. So that's just breaking down the regular expression that you might see sometimes in case you're unfamiliar with that type of stuff. So that'll make this work pretty robustly for all different types. So next, let's show creating an actual CSS file in here rather than just doing the inline styles. So just a quick note on that. When you're using Webpack, very commonly, it's used for single page apps nowadays. And that would be the standard format for injecting that. You have one entry point here. And it's OK to just have your styles inlined here. Or you could have separate files if you like. That's fine as well for CSS files. But Webpack also does support multiple entry points in the config. And I'm not going to cover that. But I just want you to know that if you set up your entry points in here, you can point to multiple different JS files. And then you can import them individually. So you could have an about page. And that about page loads an about.js script. And that script loads the about.css file or whatever. So just so that you know, it doesn't all have to be through this one entry point. I'm just showing you the most common way to do this. So what we're going to need next is we want to add a new package here, which is going to be mini-css-extract-plugin. I always forget the name of that one. And this used to be the extract-text-plugin, if you're familiar with that at all. But since, I think, Webpack 4, they've switched that over.

And so this is going to be our first plugin. So we're actually going to need to bring it in. And it's common to use this uppercase, but I don't really know why, probably because it's like a class or something. And then we're going to do extract-plugin, and that's equal to a require statement here. And then that's going to be this mini-css-extract-plugin. And then you need an extra property here. You're going to do plugins, and you, from there, will new up this constructor here. If you don't know what that means, don't worry about that. It's just the syntax. And I think you can pass some options here, but I never really need to. So from there, you're almost done, except you're going to swap out your style loader. And instead, you're going to do mini-extract-plugin.loader and pass that in. And that's the whole setup for it. So now what you'll see is, next time I build, we're going to have a actual CSS file here, instead of the injected styles. See, it created this right here. And you can see it's all minified and beautiful. And then if we go over to the browser, you can see that we don't have it yet, because we haven't imported it. And so what we'll need to do is just run it like a regular CSS file at this point. So we could just say, OK, let's make a link that is a CSS type. And then that will just point to main.css. And you can see, without any configuration, it just, by default, chose main.css to be the output there, which is pretty cool. And then now, if we go back to our browser, boom. Everything's working just like usual. And the big difference we're going to see here is that it doesn't have those styles in the head anymore. It actually is going to have a CSS file. OK, so I'll move that just a little bit so you can see. Here, this main.css is what it's going to be. So you click that, and then here you go. And you can use this little Click button to prettify it. And it's giving you the final output. Now, you don't have to output a CSS file if you don't want to. It just kind of depends on your use case. I'm just showing you the two different ways that are the most common that people want to do. So this is a pretty good segue into source maps. Because what if we have a bug in our code, and we want to know where it lines up with the original code? This is actually just the output CSS. So what we can do for that is actually pretty neat. We only need to go to our webpack config, and you can add this property called devtool. And if you set that to the string source map, that is going to generate source maps out now. So we'll rerun that build, go over to our browser, and we'll reload here. And we close that, go back to the Elements tab. And then you'll see now we actually have an SCSS link with the proper line number. So that's pretty cool. So if we click that, it will take us to the SCSS version, where in comparison, let me show you this one, the CSS version. You can see that it kept our CSS variable, but not our SAS variable. And it also doesn't have things nested the way that they are. It's the final output. Whereas, where did that go? Go back here. Whereas in this one, it will reflect our actual code and the different line numbers. It's just a lot easier once a file gets really big in order to be able to track down bugs or just to see quick references if you're trying to look something up in a file or something like that. OK, so that was pretty simple, right? Just a quick note about source maps. We should actually probably go to Webpack, Source Maps. That was a weird search. And we go to this, just so you can see. I had a hard time learning this at first or figuring out what type to use. And from what I've learned, a source map itself is the most robust one as far as it works in development and in production. And it also is the most accurate to line numbers and all that. The problem is that it's slow. And it is nice of them to put this documentation in here to show us the different speeds in this table. But I feel like it's a little bit overwhelming to look at all these and just have no idea which one to use. So the main things to think about are just whether you want a production or a development only source maps. And that's a big debate online. The main arguments, one way or another, are essentially that if you put your source maps into production, it will allow you in your production code to actually track down bugs in the final format. And that's pretty powerful and useful at times, if that's what you need. No. But some people argue that you might want to hide your code. You don't want people stealing your code. So you're going to mangle it all up and minify it and all that stuff. Or it's a security thing, security through obscurity. And I don't really have a stake in the argument either way. I think it's fine to leave it in both. And some people think that it, I used to think this, that it adds extra file size to it to have the source maps. Because if you look in your code, it does have to generate out this map file. And so that makes the user download more. But that's actually not true, as far as I've learned, is that the source maps aren't downloaded until DevTools is actually opened. So even if you look in the Network tab here, it's showing what the user normally downloads in their network experience. And that source map file is not in here. So yeah, that's not an issue. It's really just a matter of whether you want your source maps to only be in development or only in production. So that's how you can choose which type you need. But if you're not sure, just stick with source map and then deal with that later. End rant. Let's move on. So next up is going to be PostCSS. Now, if you're not familiar with PostCSS, I'll give a quick little explanation to it. So it is a way to make final modifications to your CSS output. And the most common uses that people are familiar with would be something like auto-prefixer. So when you're using modern CSS style rules and you need cross-browser support for fallbacks and stuff like that, auto-prefixer will go and add those little dash dash webkit or dash dash MS or all those flags. You can also use it for polyfills or fallbacks, in some cases. And that's what we're going to start with. So let's pop on over to a terminal. And let's just install what we need first here. So we're going to add PostCSS. And then we're going to add Post, I always want to put a hyphen there, CSS loader. And then finally, we're going to have a preset here. So we're going to do PostCSS preset env. Those are the three packages we're going to need here. And this is a really powerful step that allows you to do a lot of really cool things past the point of just writing styles in a certain way. You can do a lot of transformations and stuff. It even allows you to do linting, if you're familiar with that, with style lint and all that stuff. So in order to set that up here, what we can do is tack onto the end of this chain. You can see we're kind of composing these loaders together one after another. And it's a pretty neat format here. And so what we're going to do is PostCSS loader is going to be the last step here. And you can actually set up PostCSS loader right here. So if you're not familiar with loaders in general, you can actually open up an object at any point and then select your loader and all that stuff. And then you can pass an options config to it. But I like to keep this nice and clean and readable here. And so I'm going to do kind of what the standard convention is for PostCSS is I'm going to create a PostCSS.config.js here. And what that will allow me to do is make a sort of config object that is just related to PostCSS. And well, let me show you how to do that. And then I'll kind of explain my take on that. So we can just do a require here. And then we'll just do that Post CSS preset env. That's all we need. And actually, we need module exports equals. There we go. And that's all we're going to need. And then how this works is that there's certain plugins like Babel or PostCSS that when you pass this here, they'll by default look at the root for a config file. And so you don't need to actually pass any extra options if you want to just do that here. The reason why it's nice, and this is my take that I was talking about before, is that I kind of think of this as like modularizing your configs. Because this webpack config can get pretty big and bloated full of stuff. And I think it's nice to kind of think of it as like a series of operations that are happening. And if you want to dig into how they work, then you can go and look at this config file. And we're about to do a browsers list to show that. And that's really convenient to have as a config file here, because both Babel and PostCSS both look at that file. So if you have multiple things that use a type of config, it's nice to abstract it that way as well. That's just my preference, but you do it however you like. So what I want to show here is if we go over to our SAS styles, I'm going to start writing in a bunch of extra styles here so that we can see PostCSS in action. And I want to kind of talk about the defaults in the browsers that it hits. So first, I'm just going to add some silly stuff here. Let's say I'm actually going to move this h1 out of the body, because that was silly in the first place. But maybe we'll do like the container that I had created before. And then we'll move this up here. And then what I'll do is I'll say, let's do padding, one rem. Let's do display flex. And then perhaps we'll do really silly background linear gradient. And I'm just going to be like to top black to white. It's going to look terrible, but let's do this for speed purposes. I always do that. Want a semicolon there? Boom. OK. Cool. Woo. OK. So now that I have a few styles here that I know aren't completely.

Backwards compatible. I'm going to show what happens when you run them through post CSS. Now the thing that you're going to want to know here is that it's actually a lot of things that you use in CSS, the adoption rate's been a lot faster. And so it's harder and harder for me to find things that need cross-browser support or a lot of it. And so what I think the default for post-CSS is for this preset env is that it will go two browser versions back. And then if a browser has greater than 1% of traffic, then it will use that. Otherwise, it won't. And you would think that that's pretty restrictive, but most things actually work. And let me show that here. So now we can do npm run build again. Now if we open our output, this main CSS file, we move that to the side. And actually, that's not that useful to read. So let's drop that back to development mode for the first time. And so let's say development. That's what we want to set the mode to. And you'll see right here that when I rebuild that, it will output this in a more readable format. So this isn't what you'd want to serve to your users, of course. This is just for you developing. So now we can see that it has actually added from the original. Let's put these a little bit side by side. So it has this background color. And you can see that it did take out this. But it added this fallback here with the post CSS. But it didn't really change much else. It seems to be like the only fallback that it added, maybe to support CSS variables. So let's actually add a browser's list RC, which is a common thing that you'll do. In order to get a little bit more backward support, and I can show you post CSS actually working with the preset here. So we're going to say browsers list RC. And in that, what we're going to do is say last two versions. This is just the format for it. So I want to support the last two versions of every browser. And then I want to support greater than 0.5%. Oops. And that is essentially going to say if a browser has more than 0.5% of global traffic, then we will support it, which is pretty generous, honestly. And then we're going to throw an IE10 into the mix. That's what they show in some of their examples. And I think it's a good one. So this is the browser setup that we want to support. And what you're going to see now is if we go and rebuild that, I'll bring this back up, notice that we now have some auto prefixes here. This WebKit flex, MS flex, and WebKit gradient. So these are the prefixes and fallbacks that it was able to create for us. And that's how easy it is. It's pretty sweet. And so now we can say, I guess maybe if you're not familiar with this whole process, it's that it's expensive to throw prefixes and polyfills or fallback support for every single browser. It's just too much for everyone to download. And so by default, the PostCSS preset, env, is picking some what they consider to be very sane, normal amount of polyfills and presets for the browsers that people use. It's like over 90% of traffic. But if you're just in an unfortunate situation at your workplace where you need to support old browsers for some reason, maybe your clients happen to be of certain demographic that use very old browsers, you can actually come in here and say, yeah, I want my browsers list RC to say that we want to support IE 10, for example. And what's cool about that is not only will your CSS do that, but if you start doing Babel to use modern JavaScript, it will use the same config here if you have that set up. And so all your stuff will target those engines. And so that's why it's nice to create this file this way. So that was a lot of stuff. With all that said and done, we're in a pretty good spot right now. We've got a really good flexible setup. And to demo how cool our setup is real quick, just to wrap this all up, I'm going to really quickly run through how we would set up Tailwind, because that's a new and up and coming thing. And maybe in our pipeline, we decide we want to start using that. And we've actually got pretty close to having that set up. So I'm just going to really quickly speed through that. And in order to do that, so I'll show you is, let's close the CSS file. So I'm going to paste in some stuff from their docs here that they have. So this is just, oops, I lost my arrow there. Thank you. And this is just a real quick, if you're not familiar with it, I'm not going to cover the syntax here. It's just a way of using a bunch of class properties to style your stuff with very minimal CSS. Love it or hate it, it's becoming pretty popular. So now that you have Tailwind syntax here, let's actually go to our CSS file and do some of the stuff that they need there. So what you want to do is go to the top here real quick and paste these in. You can see we have this weird at Tailwind syntax. It's obviously not going to build normally for us. And then I can go to, let's say I'll go to the h1 tag, and I'll throw in a directive. And you can see that it has a real problem with this. But this actually will build once we set up the plugin, even though it's showing us a syntax error. That's just the editor not being able to recognize it. And you can use an extension to be able to read that format. So in order to do this now, actually, all we're going to need to do is npm i dash d Tailwind CSS. And then we'll pop over to our post CSS, because it is commonly set up as a post CSS config. We already have post CSS. So we can say, oh, well, I now want you to also require Tailwind CSS. And then we can go back. We can run a build here. And this one's actually going to take a bit, because it adds a ton of stuff. OK, so pop on over to here. And let's see what our final output CSS looks like. And you can see it got huge. OK, so there's a ton of stuff that it just added into here. And if we go over to our browser, I'll reload. And you can see I have this really ugly looking thing now. That's because of my background gradient and all that stuff. But you can see I have this button here and this button here. This isn't a really good way to showcase Tailwind. But I am showing, just for the point of speeding this up in brevity here, that with just a few lines, because we already had that setup and we understand our setup at this point, hopefully, we can just quickly tack onto it, oh, yeah, I want to be able to use Tailwind. So let's throw it in the pipeline. And I think that's pretty awesome. So I really hope that this has been informative for you. Please let me know in the comments if you have any suggestions for future topics or anything like that, or if you think some of the things could have been made more clear or any other general criticism. I really appreciate it. My channel is just starting out. And obviously, there's a lot of room for growth. And I've got great plans for it. So I hope you'll stick around for future videos. And I'll see you then.