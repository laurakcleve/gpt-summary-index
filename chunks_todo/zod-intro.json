[{"text": "So TypeScript has continued to increase in popularity and more and more companies are adding it to their tech stack, they're using it for their enterprise apps, they're converting old apps to it or using it for brand new apps. But there's one type of problem that TypeScript's not really equipped to solve right now and that's runtime type checking. Particularly when we're fetching resources from an API or something like that and we have to type check them, we really just have to tell TypeScript like this is what we expect them to be, but what they come back could be completely different and there's no way to do that until runtime. This is a problem that Zod is trying to solve which is a runtime type checking library and there's other ones around like IOTS that have been around for a bit but Zod is getting increasingly popular. You might have heard of TRPC, that's actually how I was introduced to it. It uses Zod under the hood. And what I realized that I wished I had known going back is that I would have learned Zod first and seen what it was doing and that I could add it to my project all by itself and get a lot of awesome benefits. And now as I'm using Zod more and more and more I thought I'd throw a little video together as an introduction to it, some of the properties of what its promises are, what it can immediately deliver for you, and some of the cool little helper utilities that it has. So if that interests you, let's start coding. So we're going to start off with a project that I've already created here to save some time. This will be up on GitHub and the link will be in the description. But all it is is it's a really simple just starter npm init with some TypeScript and the TypeScript init made so that we have our TS config going. You're probably familiar with this if you do any TypeScript type stuff. We do have Zod added, we're not using it just yet, but we will. And we have node daemon with TS node added so that we can watch our files for saves and stuff like that, and it'll automatically rerun. So we can use the start script here to start that daemon up. And here we have an output here. So all we have is this TSX or this TS file. And let me get rid of this and hide the sidebar so you can have some real estate here. So what's happening is we have an async function. And that's probably the one thing to note here on this project that might be a little weird for you is there's this experimental warning, fetch API is experimental. That's because I'm on node 18 right now. You might be further in the future, or depending on when you're doing this, but you don't have to use the native fetch. If you're worried about that, or if you're having issues, you can just use node fetch or isomorphic fetch or any, you know, Axios or whatever fetch library you want on node because it's not going to matter. It's all the same for what we're doing. In this instance, I'm just using the native one. So with async function, fetch person, we're just awaiting a fetch, and we're capturing it in a results variable. And we're fetching the Star Wars API, which is a sort of like open source dev API for kind of testing out different JSON queries and API responses. So from that, then we're going to call our function in the same line here, and then on it and we're going to get this person back and we're going to log it out. And that's what we're seeing here over on the side as a results there. So we don't have any types or anything like that yet. And that's on purpose because I want to show what the problem is and what Zod is solving or one of the things that it's solving. So the problem right now is we have this person and it's an any type. So I'm not really getting any TypeScript goodness. If I try to access name on this, that will work. But that's just because it happens to be there. If I did wolf on it, it's going to tell me that's just fine and that it exists or whatever. Okay. So what I want to do is I want to be able to go up here and let's add a type real quick. So I'm going to do an interface person. And on that, I'm going to say it has a name that's a string. And I'm going to use height here. And I'm going to say it's a number even though it's not. Let's just like make a little problem for us in the future so that we can showcase it in this demo. And then I'm also going to go a step further. I'm going to say lightsaber colors is a string array. So that's definitely that whole properties not on there. So the problem with this right now is that even if I type it like this, these properties are kind of a lie. And I'm going to show that real quick by saying, well, let's step down here and say there are multiple ways that you could type a fetch response. But really, a fetch is going to come back as any and you kind of I like to think of it this way, you're kind of lying to TypeScript, because you have to tell it I, hey, you know, let's for example, this results, hey, this is going to come back as a person, that's what you need to do. That's one way to do this. And when you're doing that, it's not really guaranteed that that's going to happen. You don't know even if you built the API yourself, you've done version updates. So the code itself is in a state where it doesn't know what the response types are or anything like that. You just have to tell it like, hey, I know what I'm doing. This is what's going to come back. So we'll just type based on that. If you work with TypeScript a lot, you're comfortable with it, you do API type stuff, you're going to be familiar with this. Other languages have runtime ways to solve this. But for now, this is what we have. And it can work fine, you just have to update it. But it can really as in a scaled project, it can kind of get annoying. And you can get some really nasty bugs that can be tricky to track down sometimes. So we could do it that way. We could also do, we could cast it as a person here, if we want to, typically, you want to avoid casting with as if you can avoid it other ways. But in this case, it's all the same thing. I'm going to do it the way that I like to do it. So we can move forward. I like to do promise person here. I know some other people do too. And really, it doesn't matter in this instance, it's just because, at least I don't think it does. It's because when I look at this function, I can tell what the return type is really quickly. So if I, you know, I'm perusing through the code, that's the only reason I like it that way. If we go to the fetch person here, we'll notice that it returns a promise person. And it would say that no matter what we did it, it would infer it because TypeScript is pretty smart there. So now I can do person dot name, right? And it's actually going to autocomplete for me, it's going to tell me all the properties that I have. But notice that it tells me I have lightsaber colors here. Okay, well, you know, what is that type? Oh, it's a string array. So I should be able to get zero on that, right? Your app crashed. Why? Because you tried to read a property on undefined, but TypeScript couldn't help you couldn't tell you that that doesn't exist because you lied to it, you told it that it existed. So this is where Zod comes into play. This is pretty cool. What we're gonna do is we're gonna just import Zod. We're gonna import Z from Zod, I'll let that complete itself. And then I'm going to get rid of this type for a moment. I'll just comment it out so you can see it for reference. And then what we're going to do is we're actually gonna make a regular variable with Zod. So we'll call this person, I'm gonna name it uppercase as well, you could do lowercase, some people like it either way, you'll see why in a moment. And then I'm going to do z dot object here. So when I call z dot object, it uses this sort of builder pattern in Zod, where you say, okay, you can kind of chain these methods on to each other, you'd probably familiar with this like map filter, reduce all that type of stuff. So we have a name, and we want to call it z dot name. Oops, not name, z dot string, please apology me. And so this is essentially how you're typing, you're saying this, I have an object with this shape. And it might be familiar to you if you do react prop types as well, things like that. I can say height is the z dot number here. All right.", "title": "Catch Type Errors at Runtime with Zod: An Intro to this JavaScript Library", "url": "https://www.youtube.com/watch?v=evX18f-n4AI"}, {"text": "height is the z dot number here. All right. And then let's say lightsaber colors. What we would do here is we do z dot array. And that's an array of what what's an array of z dot strings. See, it's kind of interesting, you pass it into this thing. Now we're almost there. But we just have a we have a variable. Now we don't have a type. So you might think you do type of but the way that you actually want to do this is you want to use Zod's inference type. So now we're going to say type person equals z dot and it has an infer method here. And then you do type of and this is person here, this variable, that might be a little confusing to you because it's uppercase person, you could do lowercase here if you want, it doesn't really matter. So now I have this type person. And then we are almost there. But we actually need to still parse it because notice that we didn't add Zod as a development dependency, this actually is in our dependencies, it's going to be part of our code. So we need at runtime for this to run and check the types and how we're going to do that is we say const, I'm just gonna name it parsed results. However you want to do it, you take the type, which is person here, and then you have this parse function. And then you're going to pass it in something to parse. And then you have that and then what I'm going to do is I'm going to return that parsed results. Okay. And then what I'll do here, well, let's just run this first. So let's see what happens. So when I run that, I still get an app crash, right? But notice that I get this nice little bit of syntax here, where if we kind of go all the way up, try to keep this higher so that I'm not blocking it, you'll notice that we get this Zod error and you can read it up here or down here, it actually is going to try and hone you in on right here, Zod intro index.ts, actually right here, index.ts 21. So this is where the error is occurring, line 21. But the main thing that I usually use just to kind of glance at it is you can see it has these two issues. And it says, expected a number and received a string. And then it also expected an array here and it received undefined. So essentially at runtime here, you're getting instead of it actually getting the point where it would randomly try to access this part in your code, which could be, you know, deeply nested somewhere in your logic, you're getting it right at runtime. Even if you don't use anything, let's actually show that that probably be better as a representation, huh? So we'll just console log person again here. And when I rerun this, let's give it a second here. There we go. I'm still going to get this. So even though we haven't illegally used this object, we're going to get an error while we're developing right away. And that's really the value here to me. This is the main thing that I think Zod is solving. This is the main thing I'm interested in for and I think many other people. So let's fix this real quick. And so we can kind of see it running normally and get some of the cool helpers and stuff like that. So I'll get rid of that old type. And then what I'm gonna do is I'm gonna get rid of this property because we know this doesn't really exist. But let's just hone in on this for a minute. This is pretty interesting. If we run this again, what's going to happen here is we're only going to have this one error issue now that it expected a number and it received a string. And this expected number received string here. So all I need to do is actually tell it that it's a string, because that's actually what it is. And then now we're going to be fine. And you probably can't see this, I'm kind of blocking it. But now we're just logging out this object here. Okay, let me hide myself real quick, just so you can see. Now there's this object here that's being printed out, because I can't make the terminal go down any further. And that's kind of interesting. So what's happening here is that if I console log right here, I'm going to say fetch results, and then I have just results here. So this is the original results we got from the fetch. And then right after it, I'm going to console.log, I'm just going to put some stuff here, Zod results, we'll say Zod parsed. And this is parsed results. And I'm already making an error because I'm a noob. Okay, so I'm just logging those two things out. And what I'm trying to show here is that when I when I log out the actual fetch results, it's the whole thing. But when I log out the Zod parsed results, it's just the things that we told it it would have, which is pretty cool. So it's actually paring down all this information and saying, look, you're only going to get what you expect out of this type, which is another nice little thing that kind of cleans that up, you don't have a bunch of dangling properties that you have access to that you don't know that you have access to, you can have to be explicit here, which I personally really like. Now, we can still use these properties, the way we expect here. So we can we can get auto completion and everything like that. But let's show a couple more features before we call it here on what what else Zod brings to the table besides this, you know, base functionality, which is really, really cool. But there's some other cool helpers that it has. So if I do person dot height, and we log this out, we're gonna see here that we get this, it's this color, because it's a string, we get this 172, we get Luke Skywalker for the name here. So let's actually grab a couple other properties real quick off of this. So I can show some of the cool helpers that you can get here. So first off, you can add these little chains onto this. And there's a little min helper here. So I could say, Hey, I want the name to be minimum between one, why'd you do that? One and then the max would be 100 characters here. It's not going to show anything right away when I do this. But if I were to pare this down to two, you'll see we get this too big error, this is pretty cool. So we're actually constraining even more than TypeScript right here, we're saying, hey, this string came in, and I only want it to be two characters here. This is what I expect. You know, that's what I've prepared my app to work with, for whatever reason. And you get a nice little message here. That's pretty cool. So we'll return that back, let's just leave that one. And if you look at some of our other data, we have like a homeworld, right? So let's say we want the homeworld, we can do z dot string. And we can do dot and it's a URL, they actually have a URL helper that will check this, this is pretty cool. So when I let's just put a URL on the height as an example to show what would happen if it was the wrong thing back. And here we'll get this validation error, invalid URL for that. Okay. So let's pair that back right here, we'll leave that. So it has a bunch of cool little helpers like that. It's got an email helper, it's got a UUID helper, you see this min and max, and there's a bunch of other stuff, we're just going to cover a couple real quick. So let's do one more like more complex type here, we could do the films. And we know that we can do z dot array, right? And then what we could do is z dot string. And then we can still keep chaining onto that and say each of those is a URL here. So that's going to pass but what if we did email here? All right, let's change this real quick. So now when I do email, it's going to give me a bunch of invalid emails, I can actually pass an object into this particular validation, there's a bunch of things I could pass, but I'm only going to show you the message at heart, I'm talking there, I can do this message here. And I can say something like, films must be an array of valid URLs. Okay, do a little bit of massaging reformatting here. So here we get this cool little message films must be an array of valid URLs. If I change that back to URL, like I expected it to be, there we go. Everything's working great. So you can actually build on the messages yourself, which is really cool and like kind of check this data in a bunch of different ways. So we had taken a step back there, we had films, we said that's an z dot array is odd array of strings that are of the URL type with this message if it fails, let me show you one more", "title": "Catch Type Errors at Runtime with Zod: An Intro to this JavaScript Library", "url": "https://www.youtube.com/watch?v=evX18f-n4AI"}, {"text": "if it fails, let me show you one more thing that gets really powerful here. This is really interesting. So if you want to go above and beyond just checking, you can actually transform the data to remember how I mentioned that 172 is just kind of this random number for height. Well, that's centimeters here. But I want the users to know that. So I can actually do transform on this height here. And I'm going to when I transform, I get a callback of the value. So let's just take Val, and then let's make a string interpolation of Val with centimeters tacked onto it like so. And then you'll see that's what we get back in our output here. 172 centimeters, which is pretty cool. And I can really do anything I want here. I could actually take this value. This is pretty nutty. And I could say number Val on this thing. So we could cast this to a number here. And what's going to be pretty nutty about this is notice that it changed its syntax highlighting down here. If I hover over this person type, notice the heights now a number is just automatically inferred that from the type that came back here. And now when we go to access this, I can say height dot to fixed, and that's actually going to auto complete and work correctly. There's another way to do this. Just so you know, you don't have to do transform if you're actually doing type coercion. They've added this in some recent version camera when but you can do z.coerce. Number, notice, I don't have to put the type I can just say, hey, whatever it is, if it's coercible to a number, go ahead and do that. And you can course to all the primitives. So you can see from that, that's as far as I'm going to go on this. But you can see that thought actually has a lot of powerful things you can do here. And what I like about this pattern is that you sort of have this source of truth pattern here where you, you kind of define above and beyond what the type is, you know what the constraints are of it, whether it's a URL, a min, a max, if you do this min and max on a number, it's going to change the error to say, oh, it has to be between this number range instead of this many characters. It's a really nice, friendly API to use. And when you come back and you look at the code, you can get a sense of what that data is being returned. And I really like that. So I've only got to use Zod so far in some of my little fun side projects, but I'm really looking forward to adding it to some enterprise apps that I work on that I want to see how it can pay out. I really do believe that this is going to be a really popular library coming up to pair with TypeScript so that you can catch bugs and errors early, right away, as soon as like the API changes or as soon as you try to use it in a specific way that you shouldn't be. As usual, I hope the way that I've covered this content has been helpful for you. You can go in the comments and let me know if not, or if you'd liked it. That's awesome. I'd love to hear that. But the way that I like to teach is kind of to take a more, a little bit more thorough step-by-step process of kind of digging into some of the initial properties. Like we obviously could have gotten a lot more depth here and I know it's an intro, but I'd rather actually go through and show you some of the patterns that I find very promising and that I've spent a little bit of time with and that hopefully capture kind of the spirit of why you should be intrigued about this and maybe why the TypeScript community in general has a growing interest in this project. If this was helpful for you, I'd appreciate it if you give a like and subscribe, and I hope that I will see you in the next one. Take care.", "title": "Catch Type Errors at Runtime with Zod: An Intro to this JavaScript Library", "url": "https://www.youtube.com/watch?v=evX18f-n4AI"}]