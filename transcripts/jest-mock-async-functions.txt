

Hello and welcome to Swashbuckling with code. I'm Jimmy Cleveland. We're going to be covering mocking asynchronous functions with Jest in this video. So mocking is a fundamental skill in testing for those of you who aren't familiar with it, and in this case it means to imitate and not to insult. So what mocking does is it allows you to avoid testing parts of your code that are outside of your control or to get reliable return values for that code. And one of the situations that's really desirable for mocking is an API request such as with Axios. And so that's what we're going to cover in this video. Now I have an accompanying blog post that I wrote some time back that you can use for a reference material if you'd rather read that than watch the video if that's your flavor, or if you just want to look at it afterward. It's on blog.jpdsa.com which I'll link in the description in case you want to check that out. But let's get to some mocking. Now let's start out with a brief overview of the project just so you know what's going on in it. I've just thrown together with a npm init really quickly, and then we have a test script that's just going to run Jest, and you'll notice that there's this Jest key here. That's a way that you can make a setup file, and I'll show you that in a moment. That's just for regenerator runtime for me so that I can use a sync await. And then we have Axios and Jest, and Axios is one of the things that we're going to be mocking to show that. Obviously we have Jest, and then we're going to have our Babel core, presetenv, and then that regenerator runtime. Okay? Now, what you're going to want to take a look at real quick is this setup test to show that it just has this import regenerator runtime. That's just a way that you can add like any sort of functionality that you want Jest to pick up, and I'd probably do this a little bit differently in a full project, but this is a pretty lean one just for an example so that you can see that. We have this Babel file that just has presetenv just so you know nothing's crazy is going on there, and that's pretty much it. The index we don't even need to really look at. So we have this swappy getter, which is what we're looking to test here, and I'm going to be doing this side by side here so that you can see the test running the entire time. So it'll be a little bit squished. Sorry about that, but you know we'll make do. I think it'll be okay. So we have this swappy getter, and what its functionality is is that it's going to import Axios, and then it'll export this function swappy getter, and it's going to hit the swappy API, the Star Wars API, if you're not familiar with it. You can use it. It's pretty cool. Here's the URL here, and you know I'll probably link it in the description just in case you haven't seen it, but it's a really nice little public API that lets you just kind of test out, you know, hitting things and getting data back. So in this case, we're going to look for people by ID that you pass in. We're going to return. I happen to know that it's res.data.name when it comes back, so I'm just trying to get back the name. It's a really simple contrived example, but I think it'll serve us for what we need. So the first thing we're going to want to do is, I guess, show that if I run npm run test, you'll see that we get this no test found, and you can actually do npm t for that just so that you know, and then you can also use a dash dash to pass on additional arguments, and then we're going to do dash dash watch in this instance. And so what that will do is start up our just watch command. You could, a lot of people will do this, make it so that your just just automatically starts out in watch mode. But typically I run this in CI and I use the same command, so I'm used to just passing the watch flag. So that's how I do it. You know, you do you, you do how you like. So what we're going to do is we're going to add a new file, and I'm going to do swappygetter.test.js. That will immediately update. It's pretty cool. And it'll tell you that you got to have at least one test. So, okay, let's start out here. I like to do mine with the describe block. I know some people aren't really a fan of the describe block anymore, but, you know, I still like it. I think it's cool to kind of group things, but if someone has pretty good arguments against it, I'd like to hear it. So then we're going to run this. I'm just using a little snippet library I have here, and I actually probably should enlarge that so you can see that. And then we're going to say should return a name. And so that's going to be our test. And then now we'll have our first test that doesn't do anything, and it's just, you know, successful, right? Nothing crazy. And then what we'll do is we'll import swappygetter from that directory, swappygetter. Now, because I'm just using Babel, I have to add the JS extension. You might be used to not having to do that just so you know. And stop formatting that. And then what I want here is I want to say const result equals and then we're going to call that function swappygetter. And then let's just log the results so that we can keep track of that so you can see what's going on. And then I'm going to say expect is a pretty standard test. Expect the result. We'll say to be, and then I'll just type the name in here. So in this case, it'd be like Luke Skywalker because it's number one. And you'll see what we get here on the left. Isn't this watch mode cool? It's just kind of like live updating as we test it. So we're getting this received an empty object. And that is because our swappygetter, just to take a look at that code again, it's returning this axios.get with a then returning it. So we're essentially getting a promise back, but we're not utilizing that yet. We're just trying to call it. Now, I know this is pretty obvious to most people, but I do see quite a lot when people are getting into mocks, especially for async stuff, like when I've been looking up stack overflow and stuff, I see often people thinking that their mock is not working right because they'll see received undefined here or they'll see just an empty object or something like that. And I just wanted to point out that that is what you're going to get if you're not even doing the prompts correctly in the first place. So maybe look for that if you ever run into that situation. Okay. Now I realize we're not even calling our function correctly here, right? It takes a number. So we might as well just pass that and say, yeah, it's still the same. It's still the same problem. Now you could use promise chaining here. In testing, I really prefer async await. I'm usually kind of 50-50 on either, but in testing, it's just a lot easier, in my experience, to use async await. So that's what we're going to do. And that's why, if you recall, well, let's actually look at that real quick. You'll see that this test passed now. Pretty neat, huh? And then save with, you know, make sure that it actually fails. And it does. It'll say expected Luke Skywalker. And now I've got Luke Skywalker. So what I was just saying was that remember in my setup tests, I have this, oops, I've got this regenerator runtime, and that's why I can use async await here in this case. I just want to point that out. So, you know, a lot of situations you'll be able to do that in your project already, but that's why and how I have mine set up. So, okay, cool. You know, we have an asynchronous test working here, but, you know, there's kind of an issue here that I want to talk about before I show you the mocking, and that's kind of the why of it. The issue here is that I'm actually hitting an API. So this is supposed to be a unit test for me. Obviously, it's a contrived example. You know, you'd probably have something doing something, and then, you know, the API you're hitting is just a side effect of that. That happens to go into it. But what I'm really trying to do is I'm trying to test this unit, not this integration. And where the problem commonly arises is that let's say the API is down for one, and now my tests fail, but my code is actually still working properly. The API just happens to be down. Or what if the API changes out from under me? You know, and I get different results back, and then I get false positives, and I think someone committed some different code that kind of messed my unit test up. It's not just a temporary blip in the API or an update or something like that. So these are some of the few reasons to get into mocks because really what you want to do is you want to test your code in isolation so that, you know, you're not relying on any sort of side effects here. So let me kind of show you what that looks like. So I can do a jest.mock, and since I'm in a test file, I can just call jest here. It'll be in the environment when the test is running. And I can actually just type axios. And you'll see that that fails, but what it says is cannot read property then of undefined. So what happens when you do jest.mock so that you know is there's actually a thing called jest.fn where you can create a mock function. It's a pretend function, but it has some additional functionality from, as a lot of saying function, it has a lot of functionality from jest that's allowing that. Let me show this real quick. If I go to SwappyGetter, I can log. This is when my test works. I can log axios. And you'll see that I have to scroll up a little bit here, but when it does it, you'll see it has this request, getUri, delete, get, there's our get method and all that stuff. So it's the actual function. But check this out. When I do jest.mock, it's kind of interesting, huh? You get this big long one. Wow, it goes far. It goes all the way up here, and you can see this isMock function is true, and then it has a bunch of methods on it. mockResolveValue, onceMockReturnValue. We're actually going to use a couple of these in a moment. So this is pretty neat. And if you're a little bit newer to this, this might kind of be weird to follow, but what's happening here is

our await is, or our test here, the await is calling SwappyGetter. Now, when we call that, it actually calls this code here, and so we are running through all of this code, and so I'm logging out Axios, but because I import Axios in that module, this is swapping it out here. That's what this jest.mock does. It's going to say, hey, any time, this is the way I think about it, I don't know if it's 100% accurate, but it kind of gets my head around the weirdness of it. It's like, if you were ever going to import the Axios function, what I'm going to do is I'm going to give you a pretend version of that. So when this gets imported, it's actually our little jest.mock function, and that's why when we log that out, that's how it works. And it's a way that you can just kind of do a sanity check to make sure that things are working how you expect. Okay, so for now, we're not going to need that. Maybe I'll leave it just in case we do. We'll go back to actually fixing this. Now, the other thing that you might want to know is that this is a package that we've installed. So the jest.mock, you can pretend that it's like an import statement, because if you happen to want to mock an actual file or local code that you have, you could just do it like this. But in our case, we just want to mock this package. Okay, so now there's a couple ways to proceed. I'll show you a different one after I show you this first one. I kind of preferred this one in this case, but you know, it's good to know a few of them. So I'll show you a couple. But what you can do here is you can import and I like to start it with the name mock. And I'm going to call it mockaxios from you actually import it from axios. It's kind of weird. So what this is going to do is it's going to allow you to have access to your mock. This here is still going to to mock it for you know, the whole run of the test. But this gives you access to it. So you can do something like mock axios here. And then from that point on, you can chain onto it and say, Okay, I want the dot get method to mock implementation. This is one way to do this. I'll show you a shorter one after this. And the mock implementation takes a function. And that function itself. In this case, we're just going to promise dot resolve running out of room. So this promise dot resolve, what we're saying is, what I want you to do is pretend that the get method on our axios that we're mocking returns this. That's what it does. Okay, so now, it says swappy getter should return a name. That's the test. Notice we're getting undefined. And that's a good step in the right direction. Because what we're doing here is we're just returning promise dot resolve with nothing, essentially. Alright, so let's actually mock that data. Now we know if we go back to the function, that there is this res dot data dot name is what we want to get back after we call our get method. So let's just pretend that we have that let's just make an object up and return it. And say this is data. And that's an object and that has name. And then from that point on, let's just do let's get it passing first, Skywalker. And now we get some formatting. And you will see that our test pass and where we log the result right here. It's actually logging it out correctly. So let me show you this. It's kind of neat. So I'm going to do mock, you know, Jedi or something fun. I like to name it a pretend value when I'm testing it out just so that I know that it's not a real one. And that's also it just came to me. Another good reason to be mocking something because every single time that you run your test suite, you don't probably don't want to be hitting their API, you'd want to do that and integration test suite, which you probably run a little bit less often. At least in my case, it is. Okay, so we can see coming back to it that the test properly fails when we don't get what we want. So let's actually change this to say, mock Jedi. And now it's passing. Now what's cool about this, and this is why I like to do the import, you know, mock axios from axios thing that we're doing here is because you can actually do something sweet like this where you say, hey, I that mock axios dot get method, I want to expect that to have been called, we'll start with this one. Okay, so it looks like it passes, right? And then let's see times just so you can see it not working there. Let's do two to make it fail. Come back up here. expected number of calls to receive one. That's pretty neat, huh? So we're essentially the mocks themselves. They keep a store of data on them. And it one of the things that is keeping track of us, how many times has it been called with this test suite here. And so within this block, we're calling it one time. Now it's preferred in from everything I've searched up, and this is how I do it to use to have been called times instead of just to have been called, there's nothing wrong with to have been called, it's just cool to know that you know, your your function got called. But times not only says that the function get called, but it also makes sure that only got called once, because what if we accidentally called it multiple times? Well, we definitely don't want that. So that's just a good little safety check that you can add on there. And importing that mock axios allows you to do that really easily. And I like that. Now, because this is such a common thing, you can actually shorthand this is really cool. mock implementation, you can do mock, oops, it's lowercase mock resolved value, you can get rid of this whole function here and this promise resolve that we're doing. And we can just return, let's actually do it here. And then we'll get rid of this one. This is so hard to see here. Actually, we want this. There we go. So what we're doing here, just formatted this to make it a little bit easier to read for a moment, we're saying mock axios dot get dot mock resolved value. And then we just turn whatever we want. So that's just a little bit of a shorthand for that way that we previously had it. And it's a little nicer if you do it a bunch instead of having to write a whole promise and return that just so you know. Now you could end right here and think that you've got this all solved and beautiful, but you've actually left the bomb for yourself or someone else maintaining your code base in the future. Let me show you that. So I'm going to copy this test. So we have two tests running. And you gotta can't have a duplicate name. So I'll just say duplicate test just to show that we're going to run the test twice and check this out. We fail because we received number of calls to so the first test passed. But then it says the second test had two calls in it. All right. And that's because we're still keeping track of that state of how many times it gets called. It's throughout this whole suite running here. And so if we were to say, you know, set that to two, that would make it pass. But that's not obviously what we want. If we want to test it multiple times, we want to make sure it only gets called one time each time. So there's this cool little method, you can go up here. And there's an after each and a before each that you can call here. And it kind of depends on your situation, which one you're using. Most of the time, I just stick to one, but there are occasions where you might want to do it before every test or after every test. And that's what it's going to do. So you can give it a callback function here and tell it, you know, things you want to do before each test, you can use this to do just about whatever you want, you can set up some like local variables or objects or anything like that that you'd like. But what we're going to do here is there is a method that we want to pass. That's just dot clear all mocks. So in this case, now my test will pass, I can get rid of this log. So needed. So I'll clean it up a little bit. And now my test will pass even though I'm running the same one, because what we're doing is the mock data, we're clearing that after each test runs. Okay, so I'm gonna get rid of this one. Now, we don't need that anymore. But you should leave this here. Because some unsuspecting person will come in and they'll add a test and then they'll have a huge headache if you don't have something like this. So it's just a good thing to know. Now earlier, I told you that I was going to show you a different way to do this. And so let's do that right now. The way that you can mock this, so you can actually pass a callback here. And so what this will be is I'm just returning an object, go away. So I'm returning an object here. And I want to say that whenever you mock this, this is what I want you to return for the module. So then you, in this case, you might think that you want a get method, but you actually import the default export here, and then you call get from that. So what we want to do is say, okay, we then must have a default, that's how you do it, object, and then we do get. And then we're going to do that same thing. But we can just create a just dot fn, like just to create it on the fly here, might be a different way to do this is just how I've done it before. And then we're going to do mock resolve value, just like we did before. And then we'll update data, and then we'll do name. And then for the name, we'll obviously do mock Jedi and see if it passes. Okay, so you can see that it says axios default dot get is not a function. Now, the reason that this happens, this is a really confusing one to get stuck on, is actually we are using es module imports. And so we need to do underscore underscore two underscores es module.

And so you can actually do named methods without that, or if you're just using require syntax, you don't need that. But in this case, because we're using es module imports and exports, and we want to use the default here, we need that. Now, I go back and forth between which way I like, you know, this is kind of nice to have it all encapsulated here. And then you don't even need to import this one if you don't use it for any of the other, you know, have been called methods or anything like that. So it's up to you, whichever you prefer. This other way is a little bit cleaner to me. And so I just kind of lean toward it, but it's your preference. You do how you like. There's also the option of globally mocking this, which I won't get into in this video. That's another way to do it. You know, if you're using axios all over, and you wanted to mock it, so that always returns the same thing. That's also an option. So you can check that out in the docs. But for here, I think that we have achieved the purpose of this video. And hopefully you have a bit a little bit better idea about mocking and how to mock asynchronous functions, in particular, the axios package in this case. And so wrapping up, I'll leave a blog post link to the one that I mentioned previously, the accompanying blog post for this, if you want to just review it quickly or you ever need to check up. It's a little bit older, so the material isn't exactly the same, but it's pretty dang close. And it's nice to just have a quick little syntax review every now and then, just in case you do. So thanks for watching the video, and I hope to see you in the next one.